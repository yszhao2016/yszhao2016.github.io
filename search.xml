<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo基础应用</title>
    <url>/2021/12/10/Hexo%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>1.首先安装node,具体参考<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p>
<p>2.初始化 项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<p>将会在当前目录下产生blog文件夹</p>
<p>3.新建文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n 文章标题  //完整命令 hexo new 文章标题</span><br></pre></td></tr></table></figure>
<p>相应会在source/_posts 目录下产生   文章标题.md</p>
<p>4.生成html</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g        //完整命令  hexo generate</span><br></pre></td></tr></table></figure>
<p>将会在public目录生成相应的html文件</p>
<p>5.开启本地测试环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s        //完整命令  hexo server</span><br></pre></td></tr></table></figure>
<pre><code>http://loaclhost:4000就可以访问了
</code></pre>
<p>6.发布代码到github.io</p>
<pre><code>配置修改_config.yml文件
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repo: https://github.com/github账号名称/github账号名称.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d       //发布到线上  hexo generate</span><br></pre></td></tr></table></figure>







]]></content>
  </entry>
  <entry>
    <title>docker学习2</title>
    <url>/2023/07/08/docker%E5%AD%A6%E4%B9%A02/</url>
    <content><![CDATA[<h1 id="Dockerfile-学习"><a href="#Dockerfile-学习" class="headerlink" title="Dockerfile 学习"></a>Dockerfile 学习</h1><h2 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h2><pre><code>FROM  scratch
ADD hello /
CMD [&quot;/hello&quot;]
</code></pre>
<h2 id="FROM语法"><a href="#FROM语法" class="headerlink" title="FROM语法"></a>FROM语法</h2><pre><code>FROM scratch   //制作  base image

FROM centos    //使用  base image

FROM ubuntu:14.4
</code></pre>
<h2 id="LABEL语法"><a href="#LABEL语法" class="headerlink" title="LABEL语法"></a>LABEL语法</h2><pre><code>LABEL maintainer=&quot;xiaoquwl@gmail.com&quot;
LABEL version=&quot;1.0&quot;
LABEL description=&quot;This is description&quot;
注：Metadata不可少
</code></pre>
<h2 id="RUN-语法"><a href="#RUN-语法" class="headerlink" title="RUN 语法"></a>RUN 语法</h2><pre><code>RUN yum update &amp;&amp; yum install -y vim \
python-dev 
注：反斜杠换行

RUN
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>docker学习3</title>
    <url>/2023/07/09/docker%E5%AD%A6%E4%B9%A03/</url>
    <content><![CDATA[<h1 id="docker-compose使用"><a href="#docker-compose使用" class="headerlink" title="docker-compose使用"></a>docker-compose使用</h1><h2 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h2>]]></content>
  </entry>
  <entry>
    <title>fail2ban软件使用</title>
    <url>/2023/07/09/fail2ban%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><pre><code>CentOS 中使用fail2ban和firewalld限制IP拦截cc攻击
</code></pre>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>yum -y install fail2ban
</code></pre>
<h1 id="新建规则"><a href="#新建规则" class="headerlink" title="新建规则"></a>新建规则</h1><pre><code>/etc/fail2ban/filter.d/  编写过滤规则的目录 

vi /etc/fail2ban/filter.d/nginx-cc.conf

[Definition]
#failregex = &lt;HOST&gt;-.*-.*HTTP/1.*(404|301|503).*$
failregex = ^&lt;HOST&gt; -.*&quot;(GET|POST).* HTTP\/.*$
ignoreregex =
</code></pre>
<h1 id="正则规则检查"><a href="#正则规则检查" class="headerlink" title="正则规则检查"></a>正则规则检查</h1><pre><code>fail2ban-regex /var/log/nginx/access.log &quot;&lt;HOST&gt; -.*- .*HTTP/1.* .* .*$&quot;  
</code></pre>
<h1 id="根据配置文件检查"><a href="#根据配置文件检查" class="headerlink" title="根据配置文件检查"></a>根据配置文件检查</h1><pre><code>fail2ban-regex /var/log/nginx/access.log /etc/fail2ban/filter.d/nginx-cc.conf  
</code></pre>
<h1 id="控制规则配置文件"><a href="#控制规则配置文件" class="headerlink" title="控制规则配置文件"></a>控制规则配置文件</h1><pre><code>[DEFAULT]
ignoreip = 127.0.0.1/8  117.89.130.84 117.89.134.183/16  218.2.244.241/16 49.82.132.215/16 122.195.252.237/16 114.238.64.157/16 180.110.114.152/16
#放行的ip 可以带网段
ignorecommand =
bantime  = 60
#屏蔽时间，-1是永久屏蔽
findtime  = 60
#设置限定时间内超过 最大尝试次数 限制次数即被封锁
maxretry = 5
#最大尝试次数
backend = auto
#日志修改后检测机制
usedns = warn
#ssh链接加速
logencoding = auto
enabled = false
[sshd]
## 分类设置（基于 SSHD 服务的防护） 
enabled = true
## 是否开启防护，false 为关闭 
filter = sshd
## 过滤规则 filter 名称，对应 filter.d 目录下的 sshd.conf  action   = iptables[name=SSH, port=22, protocol=tcp] 
#《###action = iptables[name=SSH, port=ssh, protocol=tcp] ## 动作参数
#sendmail-whois[name=SSH, dest=you@example.com, sender=fail2ban@example.com,   sendername=&quot;Fail2Ban&quot;]
## 邮件通知参数
## 收件人地址           ## 发件人地址####》   这是个例子 
logpath = /var/log/secure
## 检测系统登陆日志文件 
maxretry = 3
## 最大尝试次数
banaction=iptables-allports
bantime = 3600
[nginx-cc] 
#过滤规则名称 下方就是 规律规则 相关 限制条件
enabled = true
port=http,https
filter = nginx-cc
findtime = 1
#1秒钟检查一次
maxretry = 100
#最多100个
bantime = 3600
#封锁ip的时间
banaction=iptables-multiport
#匹配的哪些日志文件
logpath = /var/log/nginx/*access.log
          /var/log/nginx/access.log
</code></pre>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><pre><code>#启动
systemctl start fail2ban
#停止
systemctl stop fail2ban

#查看具体规则限制了哪些ip
fail2ban-client status 规则名称
示例：   fail2ban-client status nginx-cc

#解封某条过滤规则封锁的ip
fail2ban-client set nginx-cc unbanip  112.84.237.102
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>docker学习1-Docker基础命令</title>
    <url>/2023/07/08/docker%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<h1 id="Docker基础命令"><a href="#Docker基础命令" class="headerlink" title="Docker基础命令"></a>Docker基础命令</h1><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><pre><code>Docker image ls 
</code></pre>
<h3 id="查看运行中的容器container"><a href="#查看运行中的容器container" class="headerlink" title="查看运行中的容器container"></a>查看运行中的容器container</h3><pre><code>docker ps      展示 正在运行的

docker ps -a   所有  启动与未启动的 
</code></pre>
<h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><pre><code>docker run 容器名称

示例：
</code></pre>
<h3 id="查看运行中的容器container-1"><a href="#查看运行中的容器container-1" class="headerlink" title="查看运行中的容器container"></a>查看运行中的容器container</h3><pre><code>docker inspect  容器名称    查看容器信息
</code></pre>
<h3 id="根据dockerfile-文件生成image"><a href="#根据dockerfile-文件生成image" class="headerlink" title="根据dockerfile 文件生成image"></a>根据dockerfile 文件生成image</h3><pre><code>Docker build -t tag/镜像名称   dockerfile所在目录
    示例：
    docker build -t test/hello-word .
</code></pre>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><pre><code>docker rm 容器ID       

docker rm $(docker container ls -aq)    删除所有容器

docker rmi image名称   删除镜像
</code></pre>
<h3 id="进入容器内"><a href="#进入容器内" class="headerlink" title="进入容器内"></a>进入容器内</h3><pre><code>docker exec -it 容器名 /bin/bash

示例：docker exec it php71 /bin/bash
</code></pre>
<h3 id="docker-镜像-导出导入【必须成对使用】"><a href="#docker-镜像-导出导入【必须成对使用】" class="headerlink" title="docker 镜像 导出导入【必须成对使用】"></a>docker 镜像 导出导入【必须成对使用】</h3><pre><code>docker export：导出容器
docker import：导入容器为镜像


docker save：导出镜像

    -o:输出到的文件。

    导出示例：
        docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3
        docker save ubuntu:load&gt;/root/ubuntu.tar

docker load：导入镜像
    -i：指定导出的文件
    -q：精简输出信息
    
    导入示例：
        docker load -i ubuntu.tar
        docker load &lt; ubuntu.tar
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>搭建git服务（适用小团队开发）</title>
    <url>/2022/04/13/git-server/</url>
    <content><![CDATA[<p> #标签</p>
<ul>
<li><p>git<br>#添加账号<br>  useradd git </p>
<p>  useradd -g git test<br>  passwd test</p>
<p>  cd /home/git/<br>#创建项目<br>  git init –bare 项目名称.git</p>
</li>
</ul>
<p>#配置权限<br>    cd /home/git/项目名称.git</p>
<pre><code>git config core.sharedRepository 0770
</code></pre>
<p>第二种方法 公钥 方法</p>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>hj212环保协议-2007</title>
    <url>/2023/07/13/hj212%E7%8E%AF%E4%BF%9D%E5%8D%8F%E8%AE%AE-2007/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>jenkins-发布php项目</title>
    <url>/2023/07/19/jenkins-%E5%8F%91%E5%B8%83php%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>java学习1</title>
    <url>/2023/02/08/java%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p>1.JavaEE 全称 Java Platform, Enterprise Edition，</p>
<pre><code>它是对 JavaSE(Java Platform, Standard Edition) 的扩展
加入了面向企业开发（实际上就是网络和 Web 有关开发）的支持，包括 Servlet，WebSocket，EL，EJB 等
</code></pre>
<p>2.Servlet 和 Servlet Container</p>
<pre><code>Servlet

Servlet 是一套用于处理 HTTP 请求的 API 标准
JavaEE 当中只提供了 Servlet 的标准，
要真正运行 Servlet，需要使用 Servlet Container

Servlet Container

如果 Servlet 是电器，Servlet Container 就是电源插座
这层抽象让 Servlet 可以跑在任何一个 Container 当中，隔绝了对 Runtime 环境的依赖
比较常用支持 Servlet Container 的 Server 软件有 Apache Tomcat，Glassfish，JBoss，Jetty 等等。


Servlet 是 Java Web 开发的事实标准，不过也不代表所有 Java Web 框架都一定要使用或者兼容 Servlet。
不使用 Servlet 也可以进行 Java Web 开发，例如 Play Framework，就是完全自立门户的一个框架。
</code></pre>
<p>3.EJB 和 EJB Container</p>
<pre><code>EJB 全称 Enterprise JavaBean，和 Servlet 一样，也是 JavaEE 当中的一个组件，面向更加复杂的企业业务开发
有一个概念需要明确，和 Servlet 类似，运行 EJB 也需要专门的 EJB Container
Apache Tomcat 不支持 EJB，而 JBoss 提供了对 EJB 的支持。
</code></pre>
<p>4.JVM：java虚拟机，加载.class文件字节码文件并运行.class字节码文件    </p>
<h1 id="二、在系统跑Java程序必要软件"><a href="#二、在系统跑Java程序必要软件" class="headerlink" title="二、在系统跑Java程序必要软件"></a>二、在系统跑Java程序必要软件</h1><p>Java Development Kit (JDK) 是Java开发工具包,用于开发和编译和调试Java程序</p>
<pre><code>编译器（javac）：将Java源代码编译成字节码文件（.class文件），以便能够在Java虚拟机（JVM）上执行
JDK提供了一些调试工具，用于帮助开发人员在开发和测试Java程序时进行调试。
JDK用于开发和编译和调试Java程序
</code></pre>
<p>Java Runtime Environment (JRE)：JRE包含了运行Java程序所需的运行时环境。 用于运行Java程序</p>
<pre><code>JRE：java 程序运行时环境，包括JVM虚拟机（java.exe等）和基本的类库（rt.jar等）。
只包含Java虚拟机（JVM）和Java标准类库，用于执行Java程序
JRE则用于运行Java程序。
</code></pre>
<h1 id="三、JavaEE-Servlet-应用"><a href="#三、JavaEE-Servlet-应用" class="headerlink" title="三、JavaEE Servlet 应用"></a>三、JavaEE Servlet 应用</h1><pre><code> package，然后在 package 上右键，创建一个 Java Class
 
 Servlet API 是包含在 JavaEE 当中的。为了方便，我们直接使用 Tomcat 附带的 servlet-api.jar 包。
 
 
</code></pre>
<h2 id="3-1-Servlet接口"><a href="#3-1-Servlet接口" class="headerlink" title="3.1 Servlet接口"></a>3.1 Servlet接口</h2><pre><code>import javax.servlet.*;
public class MyFirstServlet implements Servlet&#123;

    public void init(ServletConfig config) throws ServletException &#123;
        System.out.println(&quot;Init&quot;);
    &#125;
    
    public void service(ServletRequest request, ServletResponse response)
            throws ServletException, IOException &#123;
        System.out.println(&quot;From service&quot;);
        PrintWriter out = response.getWriter();
        out.println(&quot;Hello, Java Web.&quot;);
    &#125;
    
    public void destroy() &#123;
        System.out.println(&quot;Destroy&quot;);
    &#125;
    public String getServletInfo() &#123;
        return null;
    &#125;
    
    public ServletConfig getServletConfig() &#123;
        return null;
    &#125;


&#125;
</code></pre>
<h2 id="3-2-GenericServlet抽象类"><a href="#3-2-GenericServlet抽象类" class="headerlink" title="3.2 GenericServlet抽象类"></a>3.2 GenericServlet抽象类</h2><p>GenericServlet使编写Servlet变得更容易。<br>它提生命周期方法init和destroy的简单实现，要编写一般的Servlet，只需要重写service方法即可。</p>
<pre><code>import javax.servlet.GenericServlet;
public class classname extends GenericServlet&#123;
&#125;     
</code></pre>
<h2 id="3-2-HttpServlet类"><a href="#3-2-HttpServlet类" class="headerlink" title="3.2 HttpServlet类"></a>3.2 HttpServlet类</h2><p>HttpServlet是在继承GenericServlet的基础上进一步的扩展。<br>提供将要被子类化以创建适用于Web站点的HTTP servlet的抽象类<br>要重写doGet和doPost方法</p>
<p>HTTPServlet的子类至少必须重写一个方法，该方法通常是：</p>
<p>doGet()：用于HTTP GET请求</p>
<p>doPost()：用于HTTP POST请求</p>
<p>doPut()：用于HTTP PUT请求</p>
<p>doDelete()：用于HTTP DELETE请求</p>
<pre><code>import javax.servlet.http.HttpServlet; 
public class classname extends HttpServlet&#123;

&#125;   
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>laravel源码学习2</title>
    <url>/2023/03/14/laravel%E5%AD%A6%E4%B9%A02/</url>
    <content><![CDATA[<p>#laravel 核心文件applications</p>
]]></content>
  </entry>
  <entry>
    <title>JS模块化</title>
    <url>/2022/02/26/js%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="CommonJs规范简"><a href="#CommonJs规范简" class="headerlink" title="CommonJs规范简"></a>CommonJs规范简</h2><pre><code>前端模块化

最初是服务于服务端的 但它的载体是前端语言 JavaScript
commonjs 随着 nodejs 的诞生而面世，主要是用来解决服务端模块化的问题
Node.js 应用由模块组成，每个文件就是一个模块，有自己的作用域。
在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见

 CommonJS 规范的模块时，无外乎就是使用了 require 、 exports 、 module 三个东西，
 然后一个 js 文件就是一个模块
 
 弊端require 多个文件  网络加载问题
</code></pre>
<h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><pre><code>用来加载某个模块
</code></pre>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><pre><code>module 代表当前模块，是一个对象，保存了当前模块的信息
exports 是 module 上的一个属性，保存了当前模块要导出的接口或者变量，
使用 require 加载的某个模块获取到的值就是那个模块使用 exports 导出的值
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// a.js</span><br><span class="line">var name = &#x27;morrain&#x27;</span><br><span class="line">var age = 18</span><br><span class="line">module.exports.name = name</span><br><span class="line">module.exports.getAge = function()&#123;</span><br><span class="line">    return age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//b.js</span><br><span class="line">var a = require(&#x27;a.js&#x27;)</span><br><span class="line">console.log(a.name) // &#x27;morrain&#x27;</span><br><span class="line">console.log(a.getAge())// 18</span><br></pre></td></tr></table></figure>

<h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><pre><code>为了方便，Node.js 在实现 CommonJS 规范时，为每个模块提供一个 exports的私有变量
为每个模块提供一个 exports的私有变量，指向 module.exports
你可以理解为 Node.js 在每个模块开始的地方，添加了如下这行代码。

exports 是模块内的私有局部变量，它只是指向了 module.exports
所以直接对 exports 赋值是无效的
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//a.js</span><br><span class="line">var name = &#x27;test&#x27;</span><br><span class="line">var age = 18</span><br><span class="line">exports.name = name</span><br><span class="line">exports.getAge = function()&#123;</span><br><span class="line">    return age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//b.js</span><br><span class="line"></span><br><span class="line">a = require(&#x27;a.js&#x27;)</span><br><span class="line">console.log(a.name)</span><br><span class="line">a.name</span><br></pre></td></tr></table></figure>
<h2 id="AMD-Asynchronous-Module-Definition-异步模块定义-require-js"><a href="#AMD-Asynchronous-Module-Definition-异步模块定义-require-js" class="headerlink" title="AMD(Asynchronous Module Definition 异步模块定义)   require.js"></a>AMD(Asynchronous Module Definition 异步模块定义)   require.js</h2><pre><code>　　（1）实现js文件的异步加载，避免网页失去响应；

　　（2）管理模块之间的依赖性，便于代码的编写和维护。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define(id?, dependencies?, factory)</span><br><span class="line"></span><br><span class="line">id：可选参数，用来定义模块的标识，如果没有提供该参数，就使用 js 文件名（去掉拓展名）对于一个 js 文件只定义了一个模块时，这个参数是可以省略的</span><br><span class="line"></span><br><span class="line">dependencies：可选参数，是一个数组，表示当前模块的依赖，如果没有依赖可以不传</span><br><span class="line"></span><br><span class="line">factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次，返回值便是模块要导出的值。</span><br><span class="line">如果是对象，此对象应该为模块的输出值</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// a.js</span><br><span class="line">define(function()&#123;</span><br><span class="line">    var name = &#x27;morrain&#x27;</span><br><span class="line">    var age = 18</span><br><span class="line">    return &#123;</span><br><span class="line">        name,</span><br><span class="line">        getAge: () =&gt; age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// b.js</span><br><span class="line">define([&#x27;a.js&#x27;], function(a)&#123;</span><br><span class="line">    var name = &#x27;lilei&#x27;</span><br><span class="line">    var age = 15</span><br><span class="line">    console.log(a.name) // &#x27;morrain&#x27;</span><br><span class="line">    console.log(a.getAge()) // 18</span><br><span class="line">    return &#123;</span><br><span class="line">        name,</span><br><span class="line">        getAge: () =&gt; age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="CMD-Common-Module-Definition-Sea-js"><a href="#CMD-Common-Module-Definition-Sea-js" class="headerlink" title="CMD (Common Module Definition)  Sea.js"></a>CMD (Common Module Definition)  Sea.js</h2><pre><code> Sea.js
 
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;sea.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">// a.js</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">    var name = &#x27;morrain&#x27;</span><br><span class="line">    var age = 18</span><br><span class="line"></span><br><span class="line">    exports.name = name</span><br><span class="line">    exports.getAge = () =&gt; age</span><br><span class="line">&#125;)</span><br><span class="line">// b.js</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">    var name = &#x27;lilei&#x27;</span><br><span class="line">    var age = 15</span><br><span class="line">    var a = require(&#x27;a.js&#x27;)</span><br><span class="line"></span><br><span class="line">    console.log(a.name) // &#x27;morrain&#x27;</span><br><span class="line">    console.log(a.getAge()) //18</span><br><span class="line"></span><br><span class="line">    exports.name = name</span><br><span class="line">    exports.getAge = () =&gt; age</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="ES6-Moudule"><a href="#ES6-Moudule" class="headerlink" title="ES6 Moudule"></a>ES6 Moudule</h2>]]></content>
  </entry>
  <entry>
    <title>laravel学习1</title>
    <url>/2023/03/14/laravel%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<h1 id="public-index-php文件解析"><a href="#public-index-php文件解析" class="headerlink" title="public/index.php文件解析"></a>public/index.php文件解析</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 引入自动加载文件</span><br><span class="line">require __DIR__.&#x27;/../bootstrap/autoload.php&#x27;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Turn On The Lights</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| We need to illuminate PHP development, so let us turn on the lights.</span><br><span class="line">| This bootstraps the framework and gets it ready for use, then it</span><br><span class="line">| will load up this application so that we can run it and send</span><br><span class="line">| the responses back to the browser and delight our users.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$app = require_once __DIR__.&#x27;/../bootstrap/app.php&#x27;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Run The Application</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| Once we have the application, we can handle the incoming request</span><br><span class="line">| through the kernel, and send the associated response back to</span><br><span class="line">| the client&#x27;s browser allowing them to enjoy the creative</span><br><span class="line">| and wonderful application we have prepared for them.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);</span><br><span class="line"></span><br><span class="line">$response = $kernel-&gt;handle(</span><br><span class="line">    $request = Illuminate\Http\Request::capture()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$response-&gt;send();</span><br><span class="line"></span><br><span class="line">$kernel-&gt;terminate($request, $response);</span><br></pre></td></tr></table></figure>


<h1 id="bootstrap-autoload-php文件解析"><a href="#bootstrap-autoload-php文件解析" class="headerlink" title="/bootstrap/autoload.php文件解析"></a>/bootstrap/autoload.php文件解析</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">#定义记录时间的常量</span><br><span class="line">define(&#x27;LARAVEL_START&#x27;, microtime(true));</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Register The Composer Auto Loader</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| Composer provides a convenient, automatically generated class loader</span><br><span class="line">| for our application. We just need to utilize it! We&#x27;ll require it</span><br><span class="line">| into the script here so that we do not have to worry about the</span><br><span class="line">| loading of any our classes &quot;manually&quot;. Feels great to relax.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line">#引入外部库   自动加载文件</span><br><span class="line">require __DIR__.&#x27;/../vendor/autoload.php&#x27;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Include The Compiled Class File</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| To dramatically increase your application&#x27;s performance, you may use a</span><br><span class="line">| compiled class file which contains all of the classes commonly used</span><br><span class="line">| by a request. The Artisan &quot;optimize&quot; is used to create this file.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line">#引入laravel缓存文件</span><br><span class="line">$compiledPath = __DIR__.&#x27;/cache/compiled.php&#x27;;</span><br><span class="line"></span><br><span class="line">if (file_exists($compiledPath)) &#123;</span><br><span class="line">    require $compiledPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>搭建lnmp环境</title>
    <url>/2022/04/13/make-lnmp/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>linux硬盘以及分区</title>
    <url>/2023/03/16/linux%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<h1 id="一、-硬盘分区基础知识"><a href="#一、-硬盘分区基础知识" class="headerlink" title="一、 硬盘分区基础知识"></a>一、 硬盘分区基础知识</h1><pre><code>磁盘分区类型：硬盘分区最常见的类型为msdos和gpt，
前者表示MBR分区，而后者表示GPT分区。传统的BIOS只支持MBR分区硬盘启动，
一个硬盘只能分成四个分区，并且单个分区最大不超过2TB。
GPT(即GUID分区表)是源自EFI标准的一种较新的磁盘分区表结构的标准，是未来磁盘分区的主要形式。
与MBR分区方式相比，突破MBR4个主分区限制，每个磁盘最多支持128个分区，持大于2T的分区，最大卷可达18EB。
1、MBR分区：
MBR的意思是“主引导记录”，它有自己的启动器，也就是启动代码，
一旦启动代码被破坏，系统就没法启动，只有通过修复才能启动系统。最大支持2TB容量（T; terabytes,1TB=1024GB），
对分区的设限：最多4个主分区或3个主分区加一个扩展分区。创建工具典型有fdisk。

2、GPT分区：GPT意为GUID分区表，这是一个正逐渐取代MBR的新标准，它由UEFI辅住而形成的，
这样就有了UEFI用于取代老旧的BIOS，而GPT则取代老旧的MBR。这个标准没有MBR的那些限制比如：容量2T限制、分区个数限制等。磁盘驱动器容量可以大得多，
大到操作系统和文件系统都没法支持。它同时还支持几乎无限个分区数量，限制只在于操作系统，Windows支持最多128个GPT分区。GPT和MBR是不同的分区表类型。
使用MBR分区表的硬盘最多只能划分4个主分区磁盘，并且MBR最大仅支持2TB的硬盘。如果需要分区的硬盘容量超过2TB了，则需要使用GPT分区表类型，
此分区表类型不受分区个数、硬盘大小的限制。创建GPT分区典型工具有parted,gdisk,sgdisk等,fdisk不支持创建GPT分区。
我们管理的服务器可能会随着业务量的不断增长而造成磁盘数据空间不足的情况（不考虑inode），这个时候我们就可能需要增加磁盘或挂载一些其他的块设备，
这里我主要介绍如何使用fdisk分区工具创建磁盘分区和挂载分区。最重要的三步就是：
1、创建主分区。（主分区创建之后可以马上被使用但不能再分区）
2、创建扩展分区 (扩展分区必须再进行二次分区后才能被使用)
3、在扩展分区上创建逻辑分区（扩充分区再分下去的是什么呢？它就是逻辑分区（Logical Partion））
Linux下单个磁盘最多可以有15个分区。3个主分区 + 1个扩展分区 + 11个逻辑分区。
建议的分区方法是：先分3个主分区，第四个分区为扩展分区，然后在扩展分区中再分成11个逻辑分区。
在unix/linux系统中，一切都是文件。
所有硬盘、软盘、键盘等设备都用文件来代表，对应 着/dev下面的文件。
对于应用程序来说，可以像对待普通文件一样打开，关闭、读写这些设备文件。
但是这种文件名，比如/dev/sda、/dev /raw/raw1都是用户空间名称，
OS Kernel根本不知道这个名称指的是什么。在内核空间是通过major、minor device number 来区分设备的

块设备也是通过/dev目录下的文件系统节点来访问。块设备上能够容纳文件系统。
常见的块设备如磁盘、emmc flash、nand flash、 SD卡等。

在linux系统中/dev目录下使用ls -l命令查看详细信息，第一个字母“b”为块设备文件的标识。/dev下每个块设备文件对应一个磁盘的分区。
</code></pre>
<h1 id="二、创建分区"><a href="#二、创建分区" class="headerlink" title="二、创建分区"></a>二、创建分区</h1><pre><code>虽然支持mbr的硬盘（容量小于等于2T）分区表中最多能存储四个分区，但我们实际使用时一般只分为两个分区，
一个是主分区（Primary Partion）一个是扩展分区(extended partition)两种，主分区可以马上被使用但不能再分区，
扩展分区必须再进行分区后才能使用，也就是说它必须还要进行二次分区。那么由扩充分区再分下去的是什么呢？它就是逻辑分区（Logical Partion）。 
对习惯于使用Dos或Windows的朋友来说，有几个分区就有几个驱动器，并且每个分区都会获得一个字母标识符，然后就可以选用这个字母来指定在这个分区上的文件和目录，
它们的文件结构都是独立的，非常好理解。 
因为对Linux用户来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构。
 Linux中每个分区都是用来组成整个文件系统的一部分，因为它采用了一种叫“挂载点”的处理方法，它的整个文件系统中包含了一整套的文件和目录，
 且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。
 
 
 1、 fdisk -l 查看块设备情况（块设备包括硬盘，U盘，SD卡） 
</code></pre>
<h1 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h1><pre><code>虚拟文件系统(VFS) 操作模型，通过mkfs.xxx等这种系列性的命令创建格式化很多不同的文件系统，
比如：mkfs.ext4 /dev/sda 、 mkfs.btrfs /dev/sdb等,但这些不同的文件系统都有各自的API接口，而用户想要的是，不管你是什么API，
他们只关心mount/umount，或open/close等操作，等于屏蔽了底层的文件系统类型，运维层面只关心mount等操作即可。不同的文件系统类型有不同的特点，
因而根据存储设备的硬件特性、系统需求等有不同的应用场合,什么意思呢，也就是说假如你用了不同设备都是硬盘，那么建立这个硬盘可以用不同的文件系统来做映射，
可能就会获得不同的性能提升。还是要看相关的设备种类和厂商设计的目的。


文件系统    描 述
Ext    Linux 中最早的文件系统，由于在性能和兼容性上具有很多缺陷，现在已经很少使用,是为 Linux 核心所做的第一个文件系统，最大可支持 2GB 的文件系统。

Ext2    是 Ext 文件系统的升级版本，Red Hat Linux 7.2 版本以前的系统默认都是 Ext2 文件系统。于 1993 年发布，
        支持最大 16TB 的分区和最大 2TB 的文件（1TB=1024GB=1024x1024KB)
        Linux正统的文件系统(如ext2、ext3)一个文件由目录项、inode和数据块组成。
        目录项:包括文件名和inode节点号。
        Inode：又称文件索引节点，是文件基本信息的存放地和数据块指针存放地。
        数据块：文件的具体内容存放地。
        将硬盘分区时会划分出目录块、inode Table区块和data block数据区域。一个文件由一个目录项、inode和数据区域块组成。
        Inode包含文件的属性(如读写属性、owner等，以及指向数据块的指针)，数据区域块则是文件内容。
        当查看某个文件时，会先从inode table中查出文件属性及数据存放点，再从数据块中读取数据

Ext3    是 Ext2 文件系统的升级版本，最大的区别就是带日志功能，以便在系统突然停止时提高文件系统的可靠性。支持最大 16TB 的分区和最大 2TB 的文件

Ext4    是 Ext3 文件系统的升级版。Ext4 在性能、伸缩性和可靠性方面进行了大量改进。Ext4 的变化可以说是翻天覆地的，
        比如向下兼容 Ext3、最大 1EB 文件系统和 16TB 文件、无限数量子目录、Extents 连续数据块 概念、多块分配、延迟分配、
        持久预分配、快速 FSCK、日志校验、无日志模式、在线碎片整理、inode 增强、
        默认启用 barrier 等。它是 CentOS 6.3 的默认文件系统
        
        
xfs        被业界称为最先进、最具有可升级性的文件系统技术，由 SGI 公司设计，目前最新的 CentOS 7 版本默认使用的就是此文件系统。

swap    swap 是 Linux 中用于交换分区的文件系统（类似于 Windows 中的虚拟内存)，
当内存不够用时，使用交换分区暂时替代内存。一般大小为内存的 2 倍，但是不要超过 2GB。它是 Linux 的必需分区

NFS    NFS 是网络文件系统（Network File System）的缩写，是用来实现不同主机之间文件共享的一种网络服务，本地主机可以通过挂载的方式使用远程共享的资源
iso9660    光盘的标准文件系统。Linux 要想使用光盘，必须支持 iso9660 文件系统

fat    就是 Windows 下的 fatl6 文件系统，在 Linux 中识别为 fat

vfat    就是 Windows 下的 fat32 文件系统，在 Linux 中识别为 vfat。支持最大 32GB 的分区和最大 4GB 的文件
</code></pre>
<p><font color='red'>VFAT 是一种早期的文件系统，通常用于与 Windows 系统兼容的可移动设备。由于 VFAT 文件系统不支持类似 UNIX 文件系统的权限和所有权概念，<br>因此在挂载后无法执行 chown 命令来更改文件和目录的所有者。</font></p>
<pre><code>NTFS    就是 Windows 下的 NTFS 文件系统，不过 Linux 默认是不能识别 NTFS 文件系统的，如果需要识别，则需要重新编译内核才能支持。
        它比 fat32 文件系统更加安全，速度更快，支持最大 2TB 的分区和最大 64GB 的文件
ufs    Sun 公司的操作系统 Solaris 和 SunOS 所采用的文件系统

proc    Linux 中基于内存的虚拟文件系统，用来管理内存存储目录 /proc

sysfs    和 proc —样，也是基于内存的虚拟文件系统，用来管理内存存储目录 /sysfs

tmpfs    也是一种基于内存的虚拟文件系统，不过也可以使用 swap 交换分区

现在一般是Ext4 xfs格式
</code></pre>
<h1 id="分区工具"><a href="#分区工具" class="headerlink" title="分区工具"></a>分区工具</h1><pre><code>fdisk命令可以用于对2TB以内的磁盘进行添加、删除、转换分区的功能,用户可以根据实际情况进行合理划分。


parted -l命令

parted一款功能强大的磁盘分区和分区大小调整工具。

parted -l同fdisk -l命令类似，但是它可以识别2TB以上的硬盘，也能查看 GPT 磁盘的分区
</code></pre>
<p>#具体操作  </p>
<h2 id="基本命令介绍"><a href="#基本命令介绍" class="headerlink" title="基本命令介绍"></a>基本命令介绍</h2><pre><code>df -h
      查看分区情况 相对比较直观
      
fdisk -l
      查看系统有几块硬盘  分标有多大  分了那几个区
      
      
lsblk
lsblk -f  
查看分区信息  -f更详细
令可以列出所有可用块设备的信息,而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。块设备有硬盘,闪存盘,CD-ROM等等

用 blkid  获取磁盘的uuid和属性
</code></pre>
<h2 id="详细操作"><a href="#详细操作" class="headerlink" title="详细操作"></a>详细操作</h2><pre><code>分区
1.fdisk   盘符    示例：fidisk /dev/sdb

2.输入n 是创建分区（一般下面多是默认）

3.然后选择分区类型
                p   primary(主分区)
                e   extende（扩展）
                
4.设置分区号（一般默认）  
              

5.然后设置     起始扇区
              结束扇区  
                
6.设置完 输入w    保存     

7.特殊操作需要删除分区 输入d 然后选择分区号                   


格式化  
        mkfs -t ext3 /dev/sdb2
        mkfs -t ext4 /dev/sdb2 
        mkfs.xfs -f /dev/sdb2
        
        
查看分区信息       
lsblk
lsblk -f  更详细


用 blkid  获取磁盘的uuid和属性

vim /etc/fstab


配置模板：UUID=*************  挂载路径  格式  defaults  1  1 
示例   UUID=b2cc970b-7cf4-453e-b3f5-916497b9530e  /apps  xfs  defaults  1  1 
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>linux系统后台运行任务</title>
    <url>/2023/07/19/linux%E7%B3%BB%E7%BB%9F%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>搭建 mysql_server</title>
    <url>/2022/04/17/mysql-server/</url>
    <content><![CDATA[<h1 id="centos-mysql安装"><a href="#centos-mysql安装" class="headerlink" title="centos mysql安装"></a>centos mysql安装</h1><p>1.网站：<a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p>
<p>2.mysql官网找到相应版本安装包</p>
<p>3.然后下载本地 tar -xvf mysql-5.7.21-1.el7.x86_64.rpm-bundle.tar</p>
<p>4.rpm -qa|grep mariadb 查看是否安装mariadb数据库，有就卸载  yum remove 包名 <font color='red'>不卸载干净，会报错哦</font></p>
<p>5.按下列包顺序安装</p>
<pre><code>rpm -ivh mysql-community-common-5.7.19-1.el7.x86_64.rpm

rpm -ivh mysql-community-libs-5.7.19-1.el7.x86_64.rpm

rpm -ivh mysql-community-devel-5.7.19-1.el7.x86_64.rpm

rpm -ivh mysql-community-libs-compat-5.7.19-1.el7.x86_64.rpm

rpm -ivh mysql-community-client-5.7.19-1.el7.x86_64.rpm

rpm -ivh mysql-community-server-5.7.19-1.el7.x86_64.rpm
</code></pre>
<p>6 安装完毕 初始密码一般在/var/log/mysqld.log文件中   cat   /var/log/mysqld.log |grep password</p>
<p>7.登录数据库 修改密码 mysql -u root -p</p>
<p>8.登录后修改密码 </p>
<pre><code>SET PASSWORD = PASSWORD(&#39;xxx@520Flzx3qc&#39;);
</code></pre>
<p>9.优化配置    </p>
<pre><code>port=3306
设置端口号

datadir=/data/mysqldata
#数据存在目录
    
############## Slow Log   ######################
slow_query_log=ON
# 开启慢查询日志

slow_query_log_file=/data/mysql/logs/slow.log
# # 慢查询日志存放路径

long_query_time=10
# # 超过10秒的查询，记录到慢查询日志，默认值10

log_queries_not_using_indexes=ON
# # 没有使用索引的查询，记录到慢查询日志，可能引起慢查询日志快速增长

log_slow_admin_statements=ON
# # 执行缓慢的管理语句，记录到慢查询日志
# # 例如 ALTER TABLE, ANALYZE TABLE, CHECK TABLE, CREATE INDEX, DROP INDEX, OPTIMIZE TABLE, and REPAIR TABLE.


###################     Error Log   ####################
log_error=/data/mysql/logs/mysqld.log
## 错误日志存放路径
log_error_verbosity = 2
## 全局动态变量，默认3，范围：1～3


###################     Bin Log    ######################
server_id = 6
###################     Error Log   ####################
log_error=/data/mysql/logs/mysqld.log
</code></pre>
<p>10.相关命令</p>
<pre><code>开机启动
systemctl enable mysqld

systemctl stop mysqld
systemctl start mysqld
systemctl restart mysqld
</code></pre>
<p>#安装报错解决</p>
<pre><code>Error: 
 Problem: cannot install the best candidate for the job
  - nothing provides libcrypto.so.10()(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libssl.so.10()(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libcrypto.so.10(libcrypto.so.10)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libssl.so.10(libssl.so.10)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libcrypto.so.10(OPENSSL_1.0.1_EC)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libcrypto.so.10(OPENSSL_1.0.2)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64




解决方案

yum install compat-openssl10
yum install http://mirror.centos.org/centos/8-stream/AppStream/x86_64/os/Packages/compat-openssl10-1.0.2o-3.el8.x86_64.rpm
</code></pre>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>搭建 nginx_server</title>
    <url>/2022/04/17/nginx-server/</url>
    <content><![CDATA[<h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><h2 id="1-yum-安装（默认情况下使用yum安装的nginx包含ssl模块）"><a href="#1-yum-安装（默认情况下使用yum安装的nginx包含ssl模块）" class="headerlink" title="1.yum 安装（默认情况下使用yum安装的nginx包含ssl模块）"></a>1.yum 安装（默认情况下使用yum安装的nginx包含ssl模块）</h2><pre><code>    官方 yum 源链接 http://nginx.org/en/linux_packages.html#RHEL-CentOS
    
    vim /etc/yum.repos.d/nginx.repo
    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line"></span><br><span class="line">[nginx-mainline]</span><br><span class="line">name=nginx mainline repo</span><br><span class="line">baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br></pre></td></tr></table></figure>
    
    yum-config-manager --enable nginx-stable
    
    yum install nginx
</code></pre>
<h2 id="2-源码编译安装"><a href="#2-源码编译安装" class="headerlink" title="2.源码编译安装"></a>2.源码编译安装</h2><pre><code>下载源码包  http://nginx.org/en/download.html  下载稳定版本

Mainline version：Mainline 是 Nginx 目前主力在做的版本，可以说是开发版
Stable version：最新稳定版，生产环境上建议使用的版本
Legacy versions：遗留的老版本的稳定版

下载命令
wget http://nginx.org/download/nginx-1.22.0.tar.gz

解压缩
tar -zxvf nginx-1.22.0.tar.gz
    
 ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre
 
 make &amp;&amp; make install
 
 ln -s /usr/local/nginx/conf  /etc/nginx
 
 
 
</code></pre>
<h1 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h1><pre><code>vim /lib/systemd/system/nginx.service     
     
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx</span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

软连接etc目录
ln -s /usr/local/nginx/conf /etc/nginx   

systemctl status nginx
systemctl reload nginx
systemctl start nginx

开机启动
systemctl enable nginx

添加用户
groupadd www
useradd -g www -s /sbin/nologin www  
</code></pre>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h6 id="etc-nginx-nginx-conf"><a href="#etc-nginx-nginx-conf" class="headerlink" title="/etc/nginx/nginx.conf"></a>/etc/nginx/nginx.conf</h6><pre><code>   user  www;
   #cpu 几核 这进程就多少
   worker_processes  2;
   worker_cpu_affinity 01 10;
   
   worker_rlimit_nofile 65535;  # 一般等于ulimit -n系统值
   
   #error_log  logs/error.log;
   #error_log  logs/error.log  notice;
   #error_log  logs/error.log  info;
   
   #pid        logs/nginx.pid;
   
   
   events &#123;
       worker_connections  10240;
       use epoll;
   &#125;
   
   
   http &#123;
       include       mime.types;
       default_type  application/octet-stream;
       server_tokens off;
   
       #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
       #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
       #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
   
       #access_log  logs/access.log  main;
   
       sendfile        on;
       #tcp_nopush     on;
   
       #keepalive_timeout  0;
       keepalive_timeout  65;
   
       gzip on;       #表示开启压缩功能
       gzip_min_length  1k; #表示允许压缩的页面最小字节数，页面字节数从header头的Content-Length中获取。默认值是0，表示不管页面多大都进行压缩，建议设置成大于1K。如果小于1K可能会&gt;越压越大
       gzip_buffers     4 32k; #压缩缓存区大小
       gzip_http_version 1.1; #压缩版本
       gzip_comp_level 6; #压缩比率， 一般选择4-6，为了性能
       gzip_types text/css text/xml application/javascript;
       #指定压缩的类型 gzip_vary on;　#vary header支持
   
   
       #配置空主机头 404
       server &#123;
           listen 80 default;
           server_name _;
           root html;
           location / &#123; return 404;&#125;
           location ~ /.ht &#123; deny all; &#125;
   
       &#125;
       include vhost/*.conf;
   &#125;
</code></pre>
<h6 id="vhost-conf"><a href="#vhost-conf" class="headerlink" title="vhost/*.conf"></a>vhost/*.conf</h6><pre><code>server&#123;
    listen 80;
    server_name tp.webstudy.cc;
    set $wwwroot /home/www/htdocs/tp.webstudy.cc;
    root $wwwroot;
    access_log  logs/ai.access.log;
    error_log logs/ai.error.log debug;

    #ssl_certificate     /usr/local/nginx/conf/ssl/jinju.utooo.com/Nginx/1_jinju.utooo.com_bundle.crt;
    #ssl_certificate_key /usr/local/nginx/conf/ssl/jinju.utooo.com/Nginx/2_jinju.utooo.com.key;
    #ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    location / &#123;
        index  index.php index.html index.htm;
        # 这里使用try_files进行url重写，不用rewrite了
        # try_files $uri $uri/ /index.php?$query_string;
    &#125;

   #error_page   500 502 503 504  /50x.html;
   location = /50x.html &#123;
        root   html;
    &#125;
    location ~ .*\.php&#123;
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME   $document_root$fastcgi_script_name;
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
    &#125;

&#125;


  
</code></pre>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>openEuler搭建lnmp</title>
    <url>/2023/07/09/openEuler%E6%90%AD%E5%BB%BAlnmp/</url>
    <content><![CDATA[<p>#openEuler搭建lnmp</p>
<p>##安装php<br>wget <a href="https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm">https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</a></p>
<p>rpm -ivh –nodeps epel-release-latest-7.noarch.rp</p>
<p>wget <a href="https://rpms.remirepo.net/enterprise/remi-release-7.rpm">https://rpms.remirepo.net/enterprise/remi-release-7.rpm</a></p>
<p>rpm -ivh –nodeps remi-release-7.rpm </p>
<p>yum-config-manager –enable remi-php73</p>
<p>yum install php73 php73-php-fpm php73-php-opcache php73-php-gd php73-php-mbstring php73-php-xml php73-php-pdo php73-php-mysqlnd php73-php-pecl-mysql php73-php-bcmath</p>
<p>##rpm包安装mysql</p>
<pre><code>Error: 
 Problem: cannot install the best candidate for the job
  - nothing provides libcrypto.so.10()(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libssl.so.10()(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libcrypto.so.10(libcrypto.so.10)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libssl.so.10(libssl.so.10)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libcrypto.so.10(OPENSSL_1.0.1_EC)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libcrypto.so.10(OPENSSL_1.0.2)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  
</code></pre>
<p>此报错处理办法      </p>
<pre><code>yum install compat-openssl10
yum install http://mirror.centos.org/centos/8-stream/AppStream/x86_64/os/Packages/compat-openssl10-1.0.2o-3.el8.x86_64.rpm
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>nginx-vhost-安全配置模版</title>
    <url>/2023/07/13/nginx-vhost-%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E6%A8%A1%E7%89%88/</url>
    <content><![CDATA[<p>#nginx-vhost-安全配置模版</p>
<pre><code>server&#123;
        listen 443 ssl ;
        server_name  [域名或者ip];
        index        index.php index.html index.htm;
        root [项目路径];
        access_log  /var/log/nginx/[项目名称].access.log;
        error_log   /var/log/nginx/[项目名称].error.log;

        #证书文件名称
        ssl_certificate [证书路径 公钥];
        #私钥文件名称
        ssl_certificate_key [证书路径 私钥];
        ssl_session_timeout 5m;
        #请按照以下协议配置
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;
        ssl_prefer_server_ciphers on


        #允许cookie
        add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;
        #安全头
        add_header X-Xss-header &quot;1;mode=block&quot;;
        add_header Set-Cookie &quot;HttpOnly&quot;;
        add_header Set-Cookie &quot;Secure&quot;;
        add_header X-Frame-Options &quot;SAMEORIGIN&quot;;

        location ~ \.(json|lock|git)$ &#123;
                 deny all;
        &#125;
        location ~ ^/(uploads|assets)/.*\.(php|php5|jsp|shtml)$ &#123;
            deny all;
        &#125;
        location ~ .*\.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx)$ &#123;
            add_header Content-Disposition attachment;
        &#125;
        location =/assets/libs/bootstrap/Gemfile &#123;
                       return 404;
        &#125;
        location ~ /\. &#123;
            deny  all;
        &#125;

        location / &#123;
                proxy_cookie_path / &quot;/; httponly; secure; SameSite=None&quot;;
                if (!-e $request_filename) &#123;
                        rewrite  ^(.*)$  /index.php?s=/$1  last;
                        break;
                &#125;

        &#125;

        location ~ \.php(.*)$ &#123;
                fastcgi_pass   [访问php方式];
                fastcgi_index  index.php;
                fastcgi_split_path_info  ^((?U).+\.php)(/?.+)$;
                fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
                fastcgi_param  PATH_INFO  $fastcgi_path_info;
                fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;
                include        fastcgi_params;
        &#125;

        #timeout
        large_client_header_buffers 4 16k;
        client_max_body_size 180m;
        client_body_buffer_size 128k;
        fastcgi_connect_timeout 600;
        fastcgi_read_timeout 600;
        fastcgi_send_timeout 600;
        fastcgi_buffer_size 128k;
        fastcgi_buffers   2 256k;
        fastcgi_busy_buffers_size 256k;
        fastcgi_temp_file_write_size 256k;
        proxy_read_timeout  240s;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>php扩展编译安装</title>
    <url>/2023/07/19/php%E6%89%A9%E5%B1%95%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="一、找点phpize-和-php-config路径"><a href="#一、找点phpize-和-php-config路径" class="headerlink" title="一、找点phpize 和 php-config路径"></a>一、找点phpize 和 php-config路径</h1><pre><code>find / -name phpize

find / -name php-config
</code></pre>
<h1 id="二、找到"><a href="#二、找到" class="headerlink" title="二、找到"></a>二、找到</h1><p>项目目录下执行 查找到的phpize </p>
<pre><code>/opt/remi/php74/root/usr/bin/phpize

如报错
Can&#39;t find PHP headers in /usr/include/php The php-devel package is required for use of this command...

安装php-devel即可

yum install -y php-devel

remi安装如下安装
yum install -y php73-php-devel
</code></pre>
<h1 id="三、编译"><a href="#三、编译" class="headerlink" title="三、编译"></a>三、编译</h1><pre><code> 1.进入项目目录下
 ./configure --with-php-config=【第一步查询到的路径】
 
 示例
    ./configure --with-php-config=/www/server/php/71/bin/php-config

 2. 执行
 
 make &amp;&amp; make install
</code></pre>
<h1 id="四、添加配置"><a href="#四、添加配置" class="headerlink" title="四、添加配置"></a>四、添加配置</h1><pre><code>vi /具体路径/php.ini
 
extension=swoole.so

如是remi 安装的php 
在/etc/opt/remi/php73/php.d下新建
新建ini文件  参考其他设置下

万变方案 phpinfo 看下是如何加载扩展的 具体的目录 多有
</code></pre>
<h1 id="五、重启服务"><a href="#五、重启服务" class="headerlink" title="五、重启服务"></a>五、重启服务</h1><pre><code>systemctl restart php-fpm   
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>shell脚本学习1</title>
    <url>/2023/07/13/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>nginx之logrotate</title>
    <url>/2023/07/19/nginx%E4%B9%8Blogrotate/</url>
    <content><![CDATA[<h1 id="一、logrotate介绍"><a href="#一、logrotate介绍" class="headerlink" title="一、logrotate介绍"></a>一、logrotate介绍</h1><p>logrotate是centos自带命令，其他linux操作系统可能需要自行安装，用来进行日志切割和定期删除，</p>
<p>简单来说就是将某个日志文件按照时间或大小分割成多份，删除时间久远的日志。</p>
<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><pre><code>yum install -y logrotate     #centos 系统

apt install -y logrotate    #ubuntu 系统
</code></pre>
<h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><p>/etc/logrotate.conf是全局配置</p>
<pre><code>#指定日志文件保留几个副本
rotate 4

# 指定当发生滚动后，创建一个新的空日志文件（权限不变）
create

# 指定滚动文件的后缀是当前的日期
dateext  

# 指定是否对滚动日志进行压缩
#compress

# 加载子配置
include /etc/logrotate.d

# 指定对特定文件的滚动规则
/var/log/wtmp &#123;
    monthly
    create 0664 root utmp
    minsize 1M  #指定文件小于1m就不滚动
    rotate 1
&#125;

/var/log/btmp &#123;
    missingok
    monthly
    create 0600 root utmp
    rotate 1
&#125;
</code></pre>
<p>/etc/logrotate.d/*（子配置）</p>
<h1 id="三、执行"><a href="#三、执行" class="headerlink" title="三、执行"></a>三、执行</h1><p>方案一<br>    通过 /etc/cron.daily/logrotate 配置<br>方案二<br>    crontab -e写入，内容为“  59 23 * * * /usr/sbin/logrotate -f /home/zmq/daily_logrotate  </p>
<h1 id="四、具体的配置文件"><a href="#四、具体的配置文件" class="headerlink" title="四、具体的配置文件"></a>四、具体的配置文件</h1><pre><code>/var/log/nginx/*.log &#123;
          daily
          missingok
          rotate 52
          compress
          delaycompress
          notifempty
          create 640 nginx adm
          sharedscripts
          postrotate
                 if [ -f /var/run/nginx.pid ]; then
                         kill -USR1 `cat /var/run/nginx.pid`
                 fi
          endscript
 &#125;
 
 
 
 /var/opt/remi/php71/log/php-fpm/*log &#123;
        missingok
        notifempty
        sharedscripts
        delaycompress
        postrotate
            /bin/kill -SIGUSR1 `cat /var/opt/remi/php71/run/php-fpm/php-fpm.pid 2&gt;/dev/null` 2&gt;/dev/null ||     true
        endscript
  &#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>搭建php环境</title>
    <url>/2022/04/17/php/</url>
    <content><![CDATA[<h1 id="一、安装Remi源："><a href="#一、安装Remi源：" class="headerlink" title="一、安装Remi源："></a>一、安装Remi源：</h1><pre><code># CentOS 6 / RHEL 6
yum install http://rpms.famillecollet.com/enterprise/remi-release-6.rpm
# CentOS 7 / RHEL 7
yum install http://rpms.remirepo.net/enterprise/remi-release-7.rpm
</code></pre>
<h1 id="二、配置Remi源-可以不操作-："><a href="#二、配置Remi源-可以不操作-：" class="headerlink" title="二、配置Remi源(可以不操作)："></a>二、配置Remi源(可以不操作)：</h1><pre><code> 编辑remi源repo文件 /etc/yum.repos.d/remi.repo
 启用 Remi Repository修改 enabled=0 为 enabled=1。
 为 Remi Repository 设置合适的优先级在 [remi] 那一节的结尾另起一行添加下面的代码：
 priority=3    
</code></pre>
<h1 id="三、安装-php"><a href="#三、安装-php" class="headerlink" title="三、安装 php"></a>三、安装 php</h1><pre><code> yum install php73 php73-php-fpm php73-php-opcache php73-php-gd php73-php-mbstring php73-php-xml php73-php-pdo php73-php-mysqlnd php73-php-pecl-mysql php73-php-bcmath
php73-php-mcrypt   
</code></pre>
<h1 id="四-开机启动"><a href="#四-开机启动" class="headerlink" title="四.开机启动"></a>四.开机启动</h1><pre><code>systemctl enable  php73-php-fpm
</code></pre>
<h1 id="五-服务相关命令"><a href="#五-服务相关命令" class="headerlink" title="五.服务相关命令"></a>五.服务相关命令</h1><pre><code>systemctl start  php73-php-fpm
systemctl stop  php73-php-fpm
systemctl status  php73-php-fpm
</code></pre>
<h1 id="六-加入系统命令"><a href="#六-加入系统命令" class="headerlink" title="六.加入系统命令"></a>六.加入系统命令</h1><pre><code>ln -s  /opt/remi/php73/root/usr/bin/php /usr/bin/php
</code></pre>
<h1 id="七-添加用户"><a href="#七-添加用户" class="headerlink" title="七.添加用户"></a>七.添加用户</h1><pre><code>groupadd www
useradd -g www -s /sbin/nologin www
    
</code></pre>
<h1 id="八-PHP-FPM配置文件www-conf"><a href="#八-PHP-FPM配置文件www-conf" class="headerlink" title="八.PHP-FPM配置文件www.conf"></a>八.PHP-FPM配置文件<a href="http://www.conf/">www.conf</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[www]</span><br><span class="line"></span><br><span class="line">user = www</span><br><span class="line">group = www</span><br><span class="line"></span><br><span class="line">;listen = 127.0.0.1:9000</span><br><span class="line">listen = /dev/shm/php71-fpm.socket</span><br><span class="line"></span><br><span class="line">listen.owner = www</span><br><span class="line">listen.group = www</span><br><span class="line">listen.mode = 0660</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">listen.allowed_clients = 127.0.0.1</span><br><span class="line"></span><br><span class="line">#如果选择static，则进程数就数固定的，由pm.max_children指定固定的子进程数。</span><br><span class="line">pm = static</span><br><span class="line">pm.max_children = 256</span><br><span class="line">pm.start_servers = 5</span><br><span class="line">#随着php-fpm一起启动时创建的子进程数目。默认值：min_spare_servers + (max_spare_servers - min_spare_servers) / 2。</span><br><span class="line">#这里表示，一起启动会有20个子进程</span><br><span class="line">pm.min_spare_servers = 5</span><br><span class="line">#设置服务器空闲时最小php-fpm进程数量。必须设置。如果空闲的时候，会检查如果少于10个，就会启动几个来补上。</span><br><span class="line">pm.max_spare_servers = 35</span><br><span class="line">#设置服务器空闲时最大php-fpm进程数量。必须设置。如果空闲时，会检查进程数，多于30个了，就会关闭几个，达到30个的状态。</span><br><span class="line">pm.max_requests = 5000</span><br><span class="line">#设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. </span><br><span class="line">#如果设置为 &#x27;0&#x27; 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.</span><br><span class="line">pm.status_path = /php7-php-fpm-status</span><br><span class="line"></span><br><span class="line">#当request_slowlog_timeout 设为一个具体秒时request_slowlog_timeout =5，表</span><br><span class="line">#示如果哪个脚本执行时间大于5秒，会记录这个脚本到慢日志文件中</span><br><span class="line">request_slowlog_timeout =10</span><br><span class="line">slowlog = /var/opt/remi/php71/log/php-fpm/www-slow.log</span><br><span class="line"></span><br><span class="line">php_admin_value[error_log] = /var/opt/remi/php71/log/php-fpm/www-error.log</span><br><span class="line">php_admin_flag[log_errors] = on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">php_value[session.save_handler] = files</span><br><span class="line">php_value[session.save_path]    = /var/opt/remi/php71/lib/php/session</span><br><span class="line">php_value[soap.wsdl_cache_dir]  = /var/opt/remi/php71/lib/php/wsdlcache</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="九、php-ini配置文件"><a href="#九、php-ini配置文件" class="headerlink" title="九、php.ini配置文件"></a>九、php.ini配置文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#关闭PHP版本信息</span><br><span class="line">expose_php = On</span><br><span class="line"></span><br><span class="line">#.单个脚本等待输入的最长时间</span><br><span class="line">max_input_time = 60</span><br><span class="line"></span><br><span class="line">memory_limit = 128M</span><br><span class="line">error_reporting = E_ALL &amp; ~E_DEPRECATED &amp; ~E_STRICT</span><br><span class="line"></span><br><span class="line">#每个脚本最大允许执行时间(秒)，0表示没有限制</span><br><span class="line">max_execution_time = 300</span><br><span class="line"></span><br><span class="line">#上传文件的最大许可大小</span><br><span class="line">upload_max_filesize = 20M</span><br><span class="line"></span><br><span class="line">#post上传的大小，要&gt;=upload_max_filesize</span><br><span class="line">post_max_size = 20M</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改成如下设置：</span><br><span class="line">session.save_handler = memcache</span><br><span class="line">session.save_path = &quot;tcp://10.0.0.18:11211&quot;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>ubuntu搭建lnmp环境</title>
    <url>/2023/07/09/ubuntn%E6%90%AD%E5%BB%BAlnmp%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>通过vsftpd搭建ftp服务器</title>
    <url>/2022/04/15/vsftpd-server/</url>
    <content><![CDATA[<p>1.yum 安装</p>
<pre><code>yum install vsftpd
</code></pre>
<p>2.编译安装</p>
<pre><code>yum -y install epel-release &amp;&amp; yum -y install pam pam-devel db4-utils
wget https://security.appspot.com/downloads/vsftpd-3.0.5.tar.gz

tar xf vsftpd-3.0.3.tar.gz

make clean &amp;&amp; make -j 4 &amp;&amp; make install


如果编译的时候报错
/usr/bin/ld: cannot find -lcap
查找该 .so 文件
find / -name &quot;*libcap.so*&quot;
/usr/lib64/libcap.so.2.22
/usr/lib64/libcap.so.2
ln -sv /usr/lib64/libcap.so.2 /usr/lib64/libcap.so
</code></pre>
<p>3./etc/vsftpd/vsftp.conf  配置文件    </p>
<pre><code>配置文件  vsftp.conf 
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#关闭匿名访问</span><br><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">#启用虚拟账户</span><br><span class="line">guest_enable=YES</span><br><span class="line">##把虚拟账户映射到系统账户virftp</span><br><span class="line">guest_username=virftp</span><br><span class="line">##使用虚拟用户验证（PAM验证）</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">#设置存放各虚拟用户配置文件的目录（此目录下与虚拟用户名相同的文件为他的配置文件）</span><br><span class="line">user_config_dir=/etc/vsftpd/vsftpd_viruser</span><br><span class="line">##启用chroot时，虚拟用户根目录允许写入</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line"></span><br><span class="line"># Uncomment this to enable any form of FTP write command.</span><br><span class="line">write_enable=YES</span><br><span class="line">#</span><br><span class="line"># Default umask for local users is 077. You may wish to change this to 022,</span><br><span class="line"># if your users expect that (022 is used by most other ftpd&#x27;s)</span><br><span class="line">local_umask=022</span><br><span class="line">#监听端口 默认21</span><br><span class="line">listen_port=10021</span><br><span class="line">#数据传输端口 默认20</span><br><span class="line">ftp_data_port=10020</span><br><span class="line"></span><br><span class="line">#被动模式 配置</span><br><span class="line">pasv_enable=YES</span><br><span class="line">pasv_min_port=20000</span><br><span class="line">pasv_max_port=20010</span><br><span class="line"># 可以发送消息当访问某个目录时</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line"># 开启上传下载记录</span><br><span class="line">xferlog_enable=YES</span><br><span class="line"># 日志标准输出</span><br><span class="line">xferlog_std_format=YES</span><br><span class="line"></span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">#监听ipv4</span><br><span class="line">listen=NO</span><br><span class="line"># 监听IPv6和监听IPv4</span><br><span class="line">listen_ipv6=YES</span><br><span class="line"></span><br><span class="line">userlist_enable=YES</span><br><span class="line"># 访问控制</span><br><span class="line">tcp_wrappers=YES</span><br></pre></td></tr></table></figure>
<p><strong>注意 根据需求自行修改<b><i>vsftp.conf</i></b>端口号以及模式：</strong><br><font color="#FF0000">#监听端口 默认21<br/>listen_port=10021<br/>#数据传输端口 默认20<br/>ftp_data_port=10020<br/>#被动模式 配置<br/>pasv_enable=YES<br/>pasv_min_port=20000<br/> pasv_max_port=20010<br/></font> </p>
<p>4、生成虚拟用户数据库：</p>
<pre><code>touch /etc/vsftpd/vir_user
vir_user文件内容：
    user1
    password1
    user2
    password2

yum -y install libdb-utils
db_load -T -t hash -f /etc/vsftpd/vir_user /etc/vsftpd/vir_user.db
chmod 700 /etc/vsftpd/vir_user.db
</code></pre>
<p>5、将auth及account的所有配置行均注释掉，添加如下两行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/pam.d/vsftpd</span><br><span class="line"></span><br><span class="line">auth                 required     pam_userdb.so   db=/etc/vsftpd/vir_user </span><br><span class="line">account              required     pam_userdb.so   db=/etc/vsftpd/vir_user</span><br></pre></td></tr></table></figure>

<p>6、增加一个系统用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /home/ftproot</span><br><span class="line">useradd -d /home/ftproot -s /sbin/nologin virftp</span><br><span class="line">chown -R virftp:virftp /home/ftproot</span><br></pre></td></tr></table></figure>

<p>7、创建和配置虚拟用户各自的配置文件，文件名称是‘虚拟用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/vsftpd/vsftpd_viruser/根据创建虚拟用户密码文件来(user1,user2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#允许写入</span><br><span class="line">write_enable=YES</span><br><span class="line">#允许浏览FTP目录和下载</span><br><span class="line">anon_world_readable_only=NO</span><br><span class="line">#允许虚拟用户上传文件</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line">#允许虚拟用户创建目录</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">#允许虚拟用户执行其他操作（如改名、删除）</span><br><span class="line">anon_other_write_enable=YES</span><br><span class="line">#上传文件的掩码,如022时，上传目录权限为755,文件权限为644</span><br><span class="line">anon_umask=022</span><br><span class="line">#指定虚拟用户的虚拟目录（虚拟用户登录后的主目录） 可以指定其他目录  注意权限（给虚拟账号权限chown -R virftp:virftp 目录）</span><br><span class="line">local_root=/ftproot/admin/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>8、各配置文件说明：</p>
<pre><code>/etc/vsftpd/vsftpd.conf                             ：vsftpd的主配置文件
/etc/vsftpd/vir_user                                   ：虚拟用户的账号密码文件  
/etc/vsftpd/vsftpd_viruser/user1            ：虚拟用户‘user1’的配置文件
/etc/pam.d/vsftpd                                     ：启用虚拟用户验证功能的配置文件
</code></pre>
<p>9、命令</p>
<pre><code>rename [filename]  [newfilename]，重命名远程Linux FTP服务器上指定的文件｡
rename 1111.xlsx   processed/1111.xlsx
</code></pre>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>webpack学习笔记1</title>
    <url>/2022/01/01/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p>#1. webpack 安装</p>
<pre><code>全局安装 nodejs
    验证  node -v
          npm -v
npm install webpack -g
npm install webpack-cli -g
正常情况下 安装webpack-cli 会自动安装webpack
npm uninstall webpack -g 全局卸载

单独项目内安装
npm install webpack webpack-cli --save-dev
或者
npm install webpack webpack-cli -D

运行npx webpack -v   //注 npx 会在node_module文件夹中找

安装特定版本
npm info webpack   //查看webpack有那些版本
npm install webpack@4.16.5 webpack-cli -D
</code></pre>
<p>#2.webpack 基本使用</p>
<pre><code>npm init    增加package.json文件
npm init -y
</code></pre>
<p>#3.一些语法</p>
<pre><code>ES Module 模块引入方式
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>web备份方案</title>
    <url>/2021/12/23/web%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="一、服务器环境"><a href="#一、服务器环境" class="headerlink" title="一、服务器环境"></a>一、服务器环境</h2><pre><code>    192.168.100.230 web服务器
    192.168.100.20  备份服务器 （rsync服务端）
</code></pre>
<h2 id="二、备份服务器安装-rsync-服务端"><a href="#二、备份服务器安装-rsync-服务端" class="headerlink" title="二、备份服务器安装 rsync 服务端"></a>二、备份服务器安装 rsync 服务端</h2><pre><code>rpm -qa|grep rsync    //检查是否安装 rsync

yum install -y rsync

vim /etc/rsyncd.conf   //编辑rsyncd服务

rsyncd.conf配置文件如下
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#rsyncd.conf start</span><br><span class="line">uid = rsync                                </span><br><span class="line">gid = rsync</span><br><span class="line">use chroot=no</span><br><span class="line">max connections=200</span><br><span class="line">timeout = 300</span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">lock file = /var/run/rsyncd.lock</span><br><span class="line">log file = /var/log/rsyncd.log</span><br><span class="line">ignore errors</span><br><span class="line">read only = false</span><br><span class="line">list = false </span><br><span class="line">hosts allow = 172.16.1.0/24</span><br><span class="line">#hosts deny = 0.0.0.0/32</span><br><span class="line">auth users = rsync_backup</span><br><span class="line">secrets file = /etc/rsync.password</span><br><span class="line">fake super = yes</span><br><span class="line">[backup]</span><br><span class="line">comment = &quot;backup dir by oldboy&quot;</span><br><span class="line">path = /home/backup  </span><br><span class="line">#备份的目录</span><br></pre></td></tr></table></figure>
<pre><code>创建rsync 服务管理用户
useradd -s /sbin/nologin -M rsync

创建数据备份存储目录
chown -R rsyn.rsync /home/backup

创建认证用户密码文件
echo &quot;rsync_backup:admin.123!@#$&quot;  &gt;/etc/rsync.password
chmod 600 /etc/rsync.password

启动rsync服务
systemctl start rsyncd       
</code></pre>
<h2 id="三、配置web-服务器端（192-168-100-230）"><a href="#三、配置web-服务器端（192-168-100-230）" class="headerlink" title="三、配置web 服务器端（192.168.100.230）"></a>三、配置web 服务器端（192.168.100.230）</h2><pre><code>    确认 rsync是否安装
        rpm -qa|grep rsync
    
    建立认证文件
    
        echo &quot;密码字符串（与rsync一致）&quot;  &gt;/etc/rsync.password
        chmod 600 /etc/rsync.password
    
    web01主机数据传输到backup主机测试测试传输
    
        Push: rsync [OPTION...] SRC... [USER@]HOST::DEST
        交互式：rsync -avz /etc/hosts  rsync_backup@172.16.1.41::backup
        非交互式：rsync -avz /etc/hosts  rsync_backup@172.16.1.41::backup --password-file=/etc/rsync.password
        
        
    shell 脚本
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objectFilename=(&#x27;文件夹名称&#x27;);</span><br><span class="line">sourcePath=&#x27;/apps/web/&#x27;;</span><br><span class="line">for(( i=0;i&lt;$&#123;#objectFilename[@]&#125;;i++)) </span><br><span class="line">do </span><br><span class="line">    tar zcf /home/backup/web/source/$&#123;objectFilename[i]&#125;-$(date +%Y-%m-%d).tar.gz -C $&#123;sourcePath&#125; $&#123;objectFilename[i]&#125;; </span><br><span class="line">    rsync -avz /home/backup/web/source/  rsync_backup@192.168.100.20::backup --password-file=/etc/rsync.password</span><br><span class="line">    rm -rf /home/backup/web/source/$&#123;objectFilename[i]&#125;-$(date +%Y-%m-%d).tar.gz</span><br><span class="line">done;</span><br></pre></td></tr></table></figure>

<h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><pre><code>特殊情况 总是提示权限问题修改 服务端

    uid = root                                
    gid = root
    fake super = no


脚本备份大文件有问题
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>vue学习1</title>
    <url>/2023/02/22/vue%E5%AD%A6%E4%B9%A01/</url>
    <content><![CDATA[<h1 id="vuecli-vue脚手架"><a href="#vuecli-vue脚手架" class="headerlink" title="vuecli  vue脚手架"></a>vuecli  vue脚手架</h1><pre><code>vue 它是一个插件  最基础的项目架构 帮集成webpack 构建 打包 编译 包含基本的架子

安装命令：    npm install -g @vue/cli
            npm i -g @vue/cli
            -g      表示全局安装


查看脚手架版本         vue --version
</code></pre>
<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><pre><code>vue create [项目名称]
默认安装项   [babel]  编译es6的语法    [eslint]     项目语法检查  可开关


vue ui 启动vue ui操作界面
</code></pre>
<h1 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h1><pre><code>/src/assets  目录存放 icon 图片
/src/api     存放  api  文件夹
/src/util    存放  一些工具方法
/src/storage 存放 数据存储的工具箱
/src/pages
/src/router.js
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>windows搭建apache+php+mysql5.6</title>
    <url>/2023/02/25/windows%E6%90%AD%E5%BB%BAapache-php-mysql5-6/</url>
    <content><![CDATA[<h1 id="安装mysql服务"><a href="#安装mysql服务" class="headerlink" title="安装mysql服务"></a>安装mysql服务</h1><pre><code>1.下载地址：https://downloads.mysql.com/archives/community/

2.下载相应windows版本

3.解压后cmd cd到文件目录mysqld.exe  执行   mysqld.exe install【mysqld remove 移除服务 mysqld start 启动服务】

4.设置开机启动  然后再win+r 输入services.msc  打开后找到mysql 右键点击属性   将启动类型设置为自动即可

【注：期间不同版本可能会报奇奇怪怪的错，百度安装相关的版本vc库】
</code></pre>
<h1 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a>安装php</h1><pre><code>1.下载地址：https://windows.php.net/downloads/releases/archives/

2.下载版本必须有  php7apache2_4.dll  vc版本最好跟apache的版本一样

3.配置php.ini 开启相应 扩展

4.测试是否能用  到相应目录 执行 php.exe -v


【注：期间不同版本可能会报奇奇怪怪的错，百度安装相关的版本vc库】
</code></pre>
<h1 id="安装apache-服务器"><a href="#安装apache-服务器" class="headerlink" title="安装apache 服务器"></a>安装apache 服务器</h1><p>##apache 安装对接php<br>    下载：<a href="https://www.apachelounge.com/download/VC14/">https://www.apachelounge.com/download/VC14/</a></p>
<pre><code>到apache/config/httpd.conf文件
找到&lt;IfModule unixd_module&gt;配置行 在其上面添加

LoadModule php7_module C:/php/php7apache2_4.dll  【php7apache2_4.dll 不同版本不同  具体目录根据自己的配置】
AddType application/x-httpd-php .php .html .htm
PHPIniDir c:/php                                 【配置PHP所在目录  具体目录根据自己的配置】  


然后通过bin目录下   **httpd.exe  -t** 测试配置是否通过

bin目录下 ApacheMonitor.exe 可以用来启动关闭 httpd服务
</code></pre>
<h2 id="配置apache项目访问"><a href="#配置apache项目访问" class="headerlink" title="配置apache项目访问"></a>配置apache项目访问</h2><h3 id="1-配置项"><a href="#1-配置项" class="headerlink" title="1.配置项"></a>1.配置项</h3><pre><code>    httpd.exe -k install -n &quot;apache2.4&quot;



    1.ServerName     配置域名访问地址
    例：ServerName 192.168.100.34:8080    ServerName www.baidu.com
    
    2.ServerRoot  配置apache安装目录
    
             例     Define SRVROOT &quot;c:/httpd&quot;
                    ServerRoot &quot;$&#123;SRVROOT&#125;&quot;   
                             
    3.Listen      监听端口
    
             例     Listen 8080
             
    4.DocumentRoot    配置项目目录
    
             例：  DocumentRoot &quot;$&#123;SRVROOT&#125;/htdocs/jnyy.iguanwei.com/public&quot;
    
    5.&lt;Directory 目录&gt;
        权限
    &lt;/&gt;Directory&gt;
    配置目录权限相关
    
        例：
        &lt;Directory &quot;$&#123;SRVROOT&#125;/htdocs/jnyy.iguanwei.com/public&quot;&gt;
                    Options Indexes FollowSymLinks
                    AllowOverride All
                    Require all granted
         &lt;/Directory&gt;
         
    6.配置默认访问文件
    
        &lt;IfModule dir_module&gt;
              DirectoryIndex  index.php index.html
        &lt;/IfModule&gt;     
     
    
</code></pre>
<h3 id="伪静态"><a href="#伪静态" class="headerlink" title="伪静态"></a>伪静态</h3><pre><code>1. httpd.conf配置文件 启动rewrite模块 如下：

    LoadModule rewrite_module modules/mod_rewrite.so


2.项目根目录.htaccess文件配置入下  没有则新建

    &lt;IfModule mod_rewrite.c&gt;
     RewriteEngine on
     RewriteBase /
     RewriteCond %&#123;REQUEST_FILENAME&#125; !-d
     RewriteCond %&#123;REQUEST_FILENAME&#125; !-f
     RewriteRule ^(.*)$ index.php?s=/$1 [QSA,PT,L]
    &lt;/IfModule&gt;


3.对应apache  httpd.conf配置文件

     AllowOverride All

    &lt;Directory 项目目录&gt;
                            Options Indexes FollowSymLinks
                            AllowOverride All
                            Require all granted
    &lt;/Directory&gt;
    
  
</code></pre>
<h3 id="配置开机启动"><a href="#配置开机启动" class="headerlink" title="配置开机启动"></a>配置开机启动</h3><pre><code>   1.将apache加入windows服务   
   
        apache的bin目录下 执行 httpd.exe -thttpd.exe -k install -n &quot;apache2.4&quot;
   
   
   2.设置开机启动  然后再win+r 输入services.msc  打开后找到mysql 右键点击属性   将启动类型设置为自动即可
   
</code></pre>
<h1 id="apache相关知识"><a href="#apache相关知识" class="headerlink" title="apache相关知识"></a>apache相关知识</h1><h2 id="windows下apache常用命令"><a href="#windows下apache常用命令" class="headerlink" title="windows下apache常用命令"></a>windows下apache常用命令</h2><pre><code>httpd -k install                           安装apache服务
httpd -k uninstall                         移除apache服务

httpd -k start                             启动apache服务
httpd -k restart                           重启apache服务
httpd -k stop                              关闭已安装的apache服务

httpd -v                                   查看apache版本
httpd -t                                   查看apache配置文件状态    
</code></pre>
<h2 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h2><pre><code>网站根目录下创建  .htaccess  文件

1) R[=code](force redirect)  #强制外部重定向
强制在替代字符串加上http://thishost[:thisport]/前缀重定向到外部的URL.如果code不指定，将用缺省的302 HTTP状态码。
2) F(force URL to be forbidden)  #禁用URL,返回403HTTP状态码。
3) G(force URL to be gone)  # 强制URL为GONE，返回410HTTP状态码。
4) P(force proxy) # 强制使用代理转发。
5) L(last rule) # 表明当前规则是最后一条规则，停止分析以后规则的重写。
6) N(next round) # 重新从第一条规则开始运行重写过程。
7) C(chained with next rule) # 与下一条规则关联
如果规则匹配则正常处理，该标志无效，如果不匹配，那么下面所有关联的规则都跳过。
8) T=MIME-type(force MIME type) # 强制MIME类型
9) NS (used only if no internal sub-request) # 只用于不是内部子请求
10) NC(no case) # 不区分大小写
11) QSA(query string append) # 追加请求字符串
12) NE(no URI escaping of output) # 不在输出转义特殊字符
例如：RewriteRule /foo/(.*) /bar?arg=P1%3d$1 [R,NE] # 将能正确的将/foo/zoo转换成/bar?arg=P1=zoo
13) PT(pass through to next handler) # 传递给下一个处理
例如：
RewriteRule ^/abc(.*) /def$1 [PT] # 将会交给/def规则处理
Alias /def /ghi
14) S=num(skip next rule(s)) # 跳过num条规则
15) E=VAR:VAL(set environment variable) # 设置环境变量
</code></pre>
<h2 id="HTTP-跳转至-HTTPS-示例"><a href="#HTTP-跳转至-HTTPS-示例" class="headerlink" title="HTTP 跳转至 HTTPS 示例"></a>HTTP 跳转至 HTTPS 示例</h2><pre><code>RewriteEngine on  # 开启重写
RewriteCond %&#123;SERVER_PORT&#125; !^443$  # 如果访问的不是 443 端口
RewriteCond %&#123;REQUEST_URI&#125; !^/tz.php  #如果访问的url 不是 /tz.php
RewriteRule (.*) https://%&#123;SERVER_NAME&#125;/$1 [R]     # 跳转到  https：//域名+$1
</code></pre>
<h2 id="HTTP-80-强制转-HTTPS"><a href="#HTTP-80-强制转-HTTPS" class="headerlink" title="HTTP 80 强制转 HTTPS"></a>HTTP 80 强制转 HTTPS</h2><pre><code>RewriteEngine On
RewriteCond %&#123;SERVER_PORT&#125; 80  # 如果访问的是80 端口
RewriteRule ^(.*)$ https://%&#123;HTTP_HOST&#125;/$1 [R,L]  # 跳转 https 
</code></pre>
<h2 id="强制301重定向-HTTPS"><a href="#强制301重定向-HTTPS" class="headerlink" title="强制301重定向 HTTPS"></a>强制301重定向 HTTPS</h2><pre><code>&lt;IfModule mod_rewrite.c&gt;
RewriteEngine on
RewriteBase /  # 表示项目根目录
RewriteCond %&#123;SERVER_PORT&#125; !^443$  # 如果访问的不是443 端口
RewriteRule (.*) https://%&#123;SERVER_NAME&#125;/$1 [R=301,L]  # 重定向到 301
&lt;/IfModule&gt;
</code></pre>
<h2 id="重命名目录"><a href="#重命名目录" class="headerlink" title="重命名目录"></a>重命名目录</h2><pre><code>RewriteRule   ^/?old_directory/([a-z\.]+)$   new_directory/$1   [R=301,L]
</code></pre>
<h2 id="图片防盗链"><a href="#图片防盗链" class="headerlink" title="图片防盗链"></a>图片防盗链</h2><p>   RewriteCond   %{HTTP_REFERER}   !^$ # 如果上个页面地址为空<br>   RewriteCond    %{HTTP_REFERER}   !^http://(www.)?example.com/   [NC]    #或者不是来自你自己的域名<br>   RewriteRule   .(gif|jpg|png)$   - [F]  #禁止访问</p>
<h2 id="如果文件不存在重定向到404页面"><a href="#如果文件不存在重定向到404页面" class="headerlink" title="如果文件不存在重定向到404页面"></a>如果文件不存在重定向到404页面</h2><pre><code>RewriteCond   %&#123;REQUEST_FILENAME&#125;   !-f  # 如果访问的不是一个文件
RewriteCond   %&#123;REQUEST_FILENAME&#125;   !-d  #如果访问的不是一个目录
RewriteRule   .?   /404.php   [L]   #跳转到网站根目录
# 也可携带参数
#RewriteRule ^/?(.*)$ /404.php?url=$1 [L]
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>web安全</title>
    <url>/2023/07/09/web%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>守护进程-supervisor</title>
    <url>/2023/07/19/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-supervisor/</url>
    <content><![CDATA[<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><pre><code>yum install supervisor    #centos 系统

apt install supervisor    #ubuntu 系统
</code></pre>
<h1 id="二、配置守护进程"><a href="#二、配置守护进程" class="headerlink" title="二、配置守护进程"></a>二、配置守护进程</h1><p><font color='red'>在/etc/supervisord.d/下新建后缀名为ini的文件</font></p>
<pre><code>; 设置进程的名称，使用 supervisorctl 来管理进程时需要使用该进程名
[program:myblog] 
directory = /home/web/myblog          ; 程序的启动目录
command=./start.sh start              ; 启动命令 最好绝对路径
autostart = true                      ; 在 supervisord 启动的时候也自动启动
numprocs=1                            ; 默认为1
RestartSec=30
process_name=%(program_name)s         ; 默认为 %(program_name)s，即 [program:x] 中的 x
user=root                             ; 使用 root 用户来启动该进程
autorestart=true                      ; 程序崩溃时自动重启，重启次数是有限制的，默认为3次
redirect_stderr=true                  ; 重定向输出的日志
stderr_logfile= /home/web/myblog/myblog_stderr.log
stdout_logfile = /home/web/myblog/myblog_stdout.log
loglevel=info
</code></pre>
<h1 id="三、supervisord管理"><a href="#三、supervisord管理" class="headerlink" title="三、supervisord管理"></a>三、supervisord管理</h1><pre><code>systemctl status  supervisord
systemctl start  supervisord  
systemctl stop  supervisord  
systemctl restart  supervisord  
</code></pre>
<h1 id="四、supervisorctl管理"><a href="#四、supervisorctl管理" class="headerlink" title="四、supervisorctl管理"></a>四、supervisorctl管理</h1><pre><code>supervisorctl start server:myblog
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>普通心理学笔记1</title>
    <url>/2021/12/21/%E6%99%AE%E9%80%9A%E5%BF%83%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<p>#心理学</p>
<pre><code>心理学研究行为和心理过程
一门多个专业领域的的科学
</code></pre>
<p>#心理学三大分支</p>
<pre><code>实验心理学 
    实验心理学家 最少的
心理学教学
    心理学教师
应用心理学
    工业与组织心理学家
    运动心里学家
    学校心理学家
    临床和咨询心理学家
    法医心理学家
    环境心理学家
</code></pre>
<p>#心理学与精神病学区别</p>
<pre><code>精神病学是医学 接受过治疗精神与行为疾病的训练
具有开具处方的执照
从医学角度看问题

心理学关注更为广泛 人类的行为和心理过程
大脑功能到社会交往
心里健康到心理障碍
心理学角度 来访者
</code></pre>
<p>#批判性思考技巧</p>
<pre><code>1.其来源出自哪里 问题的来源

    提出问题的人 是否擅长啊
    由于什么原因 提出了这个问题

2.这个观点是合理的还是极端的

3.证据是什么

4.是否有影响结论的偏差
    验证性偏差 只记得验证成功的那一面

5.推理是否避开了常见谬误
    避免 常识

6.看待这个问题是否需要多种角度
</code></pre>
]]></content>
      <categories>
        <category>心理学</category>
      </categories>
  </entry>
  <entry>
    <title>普通心理学笔记2</title>
    <url>/2021/12/21/%E6%99%AE%E9%80%9A%E5%BF%83%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h1 id="现代心理学6个视角"><a href="#现代心理学6个视角" class="headerlink" title="现代心理学6个视角"></a>现代心理学6个视角</h1><pre><code>起源：古希腊哲学家 苏格拉底 柏拉图 亚里士多德 意识和疯癫的理解
亚洲和非洲 瑜伽和佛教 探索意识 通过冥想控制意识
天主教
1.生物视角
    
    大脑、神经系统、内分泌系统（激素）和基因        笛卡尔

2.认知视角

    每个人有各自的知觉模式、解释、预期、信念和记忆   威廉。冯特 威廉詹姆斯     
    
3.行为视角
    
    环境的刺激和先前行为的结果                   约翰。华生 斯金纳

4.全人视角                                   弗洛伊德 古希腊   
    
    心理动力：无意识心理的过程
    人本主义
    特质和气质：

5.发展视角                                   安斯沃思

    遗传和环境的交互作用，在毕生发展中塑造
    
6.社会文化视角                                津巴多
    
    环境的影响。社会和文化比其他因素更能决定行为
</code></pre>
<p>笛卡尔 精神和肉体是分离的  由此生物学视角诞生</p>
<p>生物学主题</p>
<pre><code>神经科学
进化心理学
</code></pre>
<p>德国科学家  威廉 冯特 |内省法  格式塔心理学家</p>
<pre><code>科学心理学和现代认知视角的建立
元素周期表  研究自然世界的科学方法  结构主义
纳克立方体
</code></pre>
]]></content>
      <categories>
        <category>心理学</category>
      </categories>
  </entry>
  <entry>
    <title>Linux服务之crond</title>
    <url>/2023/07/19/Linux%E6%9C%8D%E5%8A%A1%E4%B9%8Bcrond/</url>
    <content><![CDATA[<h1 id="一、Cron介绍"><a href="#一、Cron介绍" class="headerlink" title="一、Cron介绍"></a>一、Cron介绍</h1><p>Cron被用来进行Linux系统的计划任务执行</p>
<h1 id="二、相关目录"><a href="#二、相关目录" class="headerlink" title="二、相关目录"></a>二、相关目录</h1><p>cron.d/*用来存放一些软件的Cron设置</p>
<p>cron.daily/每天执行一次的任务</p>
<p>cron.hourly/每小时执行一次的任务</p>
<p>cron.monthly/每个月执行一次的任务</p>
<p>cron.weekly/，每周执行一次的任务</p>
<p>每分钟执行一次脚本</p>
<pre><code>crontab -e
</code></pre>
<h1 id="三、crontab使用"><a href="#三、crontab使用" class="headerlink" title="三、crontab使用"></a>三、crontab使用</h1><pre><code>*  *  *   *  *  命令/脚本
分 时 日 月 周

1  *  *   *  *  命令/脚本   指的是每个小时的第一分钟
*/1 * * * *     命令/脚本   每分钟执行脚本


crontab -l
查看计划任务列表   
</code></pre>
<h1 id="四、-etc-cron-daily-与crontab-e-定义的区别"><a href="#四、-etc-cron-daily-与crontab-e-定义的区别" class="headerlink" title="四、/etc/cron.daily 与crontab -e 定义的区别"></a>四、/etc/cron.daily 与crontab -e 定义的区别</h1><pre><code>/etc/cron.daily 和 crontab -e 都是用来设置定时任务的方式，但它们有一些不同之处。

/etc/cron.daily 是一个目录，里面存放着以 &quot;cron&quot; 格式命名的脚本文件。这些脚本会每天执行一次，通常在系统闲置时执行。这个目录中的脚本是全局的，适用于整个系统的所有用户。

而 crontab -e 则是一个命令，用于编辑和管理用户个人的 crontab 文件。crontab 文件中定义了用户的定时任务计划。通过编辑 crontab 文件，用户可以设置自己的定时任务，包括每天、每周、每月或其他时间间隔的执行。

因此，主要区别在于：

/etc/cron.daily 适用于全局系统级别的定时任务，而 crontab -e 是用户级别的定时任务。
/etc/cron.daily 中的脚本在每天执行一次，而 crontab -e 可以更精确地设置时间间隔。
/etc/cron.daily 中的脚本对所有用户有效，而 crontab -e 只对当前用户有效。
需要注意的是，修改 /etc/cron.daily 目录中的文件需要 root 权限，而 crontab -e 只需要用户自己的权限
</code></pre>
<h1 id="五、Linux-anacron"><a href="#五、Linux-anacron" class="headerlink" title="五、Linux anacron"></a>五、Linux anacron</h1><p> 执行由于关机  忘记执行的任务</p>
<p> 配置好 /etc/anacrontab 文件</p>
<p> 更具体学习参考<a href="http://c.biancheng.net/view/1095.html">http://c.biancheng.net/view/1095.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>跨域问题总结</title>
    <url>/2023/07/21/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>session和cookie</title>
    <url>/2023/07/21/session%E5%92%8Ccookie/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>php常用函数总结</title>
    <url>/2023/07/25/php%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、字符串处理函数"><a href="#一、字符串处理函数" class="headerlink" title="一、字符串处理函数"></a>一、字符串处理函数</h1><h2 id="1-1-str-pad"><a href="#1-1-str-pad" class="headerlink" title="1.1 str_pad()"></a>1.1 str_pad()</h2><p>str_pad(【必填 需要处理的字符串】,【必填 填充的长度】，【 可选 填充的字符串，默认空白】，【可选 填充字符串的哪边】)</p>
<pre><code>规定填充字符串的哪边 可能的值：

STR_PAD_BOTH - 填充字符串的两侧。如果不是偶数，则右侧获得额外的填充。
STR_PAD_LEFT - 填充字符串的左侧。
STR_PAD_RIGHT - 填充字符串的右侧。这是默认的。
</code></pre>
<p>示例 $str=10 ; echo str_pad($str,4,”0”,STR_PAD_LEFT);  <font color="red">意思就4位长度 不够就往左边补0</font></p>
<h2 id="2-1-strpos、stripos-、strrpos"><a href="#2-1-strpos、stripos-、strrpos" class="headerlink" title="2.1 strpos、stripos 、strrpos"></a>2.1 strpos、stripos 、strrpos</h2><h2 id="2-3-substr"><a href="#2-3-substr" class="headerlink" title="2.3 substr"></a>2.3 substr</h2><h2 id="2-4-strtolower-strtouplower-strlen-mb-strlen-trim-ltrim-rtrim-explode-implode常用"><a href="#2-4-strtolower-strtouplower-strlen-mb-strlen-trim-ltrim-rtrim-explode-implode常用" class="headerlink" title="2.4 strtolower strtouplower strlen mb_strlen trim ltrim rtrim explode implode常用"></a>2.4 strtolower strtouplower strlen mb_strlen trim ltrim rtrim explode implode常用</h2><pre><code>比较常用，不在赘述
</code></pre>
<h1 id="二、数组处理函数"><a href="#二、数组处理函数" class="headerlink" title="二、数组处理函数"></a>二、数组处理函数</h1>]]></content>
  </entry>
  <entry>
    <title>linux-iptables使用总结</title>
    <url>/2023/07/26/linux-iptables%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>一、iptables<br>    iptables防火墙没有启用,iptables命令仍然会显示默认的规则.</p>
<p>二、常用命令</p>
<p>常用参数</p>
<pre><code>-n 参数表示将 IP 地址和端口号显示为数字形式，而不是解析为主机名和服务名。

-L 选项用于列出防火墙规则。

-t nat 参数指定了要操作的表为 NAT 表，NAT 表用于处理网络地址转换相关的规则。
</code></pre>
<p>iptables -n -L           显示当前防火墙规则列表。</p>
<p>iptables -t nat -n -L    看 iptables 中 NAT（Network Address Translation）表的规则。</p>
<p>结果怎么看</p>
<pre><code>Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0            state NEW udp dpt:2333
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:2333

Chain FORWARD (policy DROP)
target     prot opt source               destination         
DOCKER-USER  all  --  0.0.0.0/0            0.0.0.0/0           
DOCKER-ISOLATION-STAGE-1  all  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED
DOCKER     all  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         

Chain DOCKER (1 references)
target     prot opt source               destination         
ACCEPT     udp  --  0.0.0.0/0            172.17.0.2           udp dpt:60050
ACCEPT     udp  --  0.0.0.0/0            172.17.0.2           udp dpt:60049
ACCEPT     udp  --  0.0.0.0/0            172.17.0.2           udp dpt:60048
ACCEPT     udp  --  0.0.0.0/0            172.17.0.2           udp dpt:60047

Chain DOCKER-ISOLATION-STAGE-1 (1 references)
target     prot opt source               destination         
DOCKER-ISOLATION-STAGE-2  all  --  0.0.0.0/0            0.0.0.0/0           
RETURN     all  --  0.0.0.0/0            0.0.0.0/0           

Chain DOCKER-ISOLATION-STAGE-2 (1 references)
target     prot opt source               destination         
DROP       all  --  0.0.0.0/0            0.0.0.0/0           
RETURN     all  --  0.0.0.0/0            0.0.0.0/0           

Chain DOCKER-USER (1 references)
target     prot opt source               destination         
RETURN     all  --  0.0.0.0/0            0.0.0.0/0 
 
&quot;LIBVIRT_FWI&quot;是一个iptables防火墙的链，并且该链已经被引用了一次

允许所有协议（all）的流量从任意源IP地址（0.0.0.0/0）进入到目标IP地址为172.17.0.2  60047端口


REJECT 拒绝

ACCEPT 允许

DROP   丢弃
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>git总结</title>
    <url>/2022/01/08/git%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><pre><code>工作区(workspace)      就是你平时存放项目代码的地方
暂存区(stage)          git add
仓库区/版本库(Repository)     git commit
远程仓库
</code></pre>
<h1 id="二、回退问题"><a href="#二、回退问题" class="headerlink" title="二、回退问题"></a>二、回退问题</h1><h2 id="1-git-add-后回退"><a href="#1-git-add-后回退" class="headerlink" title="1.git add 后回退"></a>1.git add 后回退</h2><p>git status 先看一下add 中的文件<br>git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了<br>git reset HEAD XXX/XXX/XXX.java 就是对某个文件进行撤销了</p>
<h2 id="2-git-commit后回退"><a href="#2-git-commit后回退" class="headerlink" title="2.git commit后回退"></a>2.git commit后回退</h2><pre><code>git log    命令显示从最近到最远的提交日志

    [root@localhost test-jenkins]# git log
    commit e2c7f2d567cbdc36e4503479e15ea51d19816d33
    Author: root &lt;root@localhost.localdomain&gt;
    Date:   Fri Jan 7 11:17:27 2022 +0800

    dev branch change

    commit 8943166480734ac5a760e482a887ee8da0140ec8
    Author: root &lt;root@localhost.localdomain&gt;
    Date:   Fri Jan 7 10:56:22 2022 +0800

    dev branch add index.php
    。。。。

git reest --hard  commit_id
                  上一个版本就是HEAD^，
                  上上一个版本就是HEAD^^，
                  当然往上100个版本写100个^比较容易数不过来，
                  所以写成HEAD~100。
例：
    git reset --hard 139dcfaa558e3276b30b6b2e5cbbb9c00bbdca96
    git reset --hard HEAD^

将会删除此版本之前添加

强制push到对应的远程分支（如提交到develop分支）
git push -f -u origin develop
</code></pre>
<h2 id="3-回退后悔药"><a href="#3-回退后悔药" class="headerlink" title="3.回退后悔药"></a>3.回退后悔药</h2><p>git reflog用来记录你的每一次命令</p>
<pre><code>[root@localhost test-jenkins]# git reflog
8943166 HEAD@&#123;0&#125;: reset: moving to 8943166480734ac5a760e482a887ee8da0140ec8
e2c7f2d HEAD@&#123;1&#125;: commit: dev branch change
8943166 HEAD@&#123;2&#125;: commit: dev branch add index.php
1ca6f06 HEAD@&#123;3&#125;: checkout: moving from release to dev
1ca6f06 HEAD@&#123;4&#125;: pull origin release: Fast-forward
14fbb47 HEAD@&#123;5&#125;: checkout: moving from master to release
14fbb47 HEAD@&#123;6&#125;: clone: from ssh://git@117.89.131.220:44222/zhaoyoushui/test-jenkins.git

git reset --hard e2c7f2d
</code></pre>
<h2 id="4-已经提交远程分支"><a href="#4-已经提交远程分支" class="headerlink" title="4.已经提交远程分支"></a>4.已经提交远程分支</h2><p>git reset 方法回退<br>拉过的错误版本的本地分支  多需要回退<br>回退  强制推送  远程</p>
<p>git revert 版本号<br>git revert HEAD 上个版本<br>git revert HEAD~n 上n个版本<br>git push 远程<br>其他客户端正常拉取就可以</p>
<h1 id="三、Git-Reset-三种模式"><a href="#三、Git-Reset-三种模式" class="headerlink" title="三、Git Reset 三种模式"></a>三、Git Reset 三种模式</h1><p>–hard: 会清空工作目录和暂存区的改动</p>
<pre><code>    git reset --hard  c3b320427ad2560140e20af23225d803b2fed6e0
    
</code></pre>
<p><font color="red">–soft：保留工作目录，并把重置 HEAD 所带来的新的差异放进暂存区  <strong>变得只是仓库区</strong></font></p>
<pre><code>    git reset --soft  c3b320427ad2560140e20af23225d803b2fed6e0
    
</code></pre>
<p>–mixed reset 不加参数(mixed)：保留工作目录，并清空暂存区</p>
<pre><code>    git reset c3b320427ad2560140e20af23225d803b2fed6e0
</code></pre>
<h1 id="四、修改远程url"><a href="#四、修改远程url" class="headerlink" title="四、修改远程url"></a>四、修改远程url</h1><pre><code>1.方法一
    git remote set-url origin [url]
    git remote -v 查看

2.方法二
    git remote rm origin
    git remote add origin [url]
    git remote -v 查看

3.方法三
    直接修改config 文件
</code></pre>
<h1 id="五、常用命令"><a href="#五、常用命令" class="headerlink" title="五、常用命令"></a>五、常用命令</h1><p>git branch  :查看本地所有分钟</p>
<pre><code>示例 ：git branch
</code></pre>
<p>git branch -a ：查看所有分支 包括远程</p>
<pre><code>示例：git branch -a 
</code></pre>
<p>git branch 【分支名]：新建分支</p>
<pre><code>示例：git branch  dev
</code></pre>
<p>git branch  -d 【分支名】    删除分支</p>
<pre><code>示例 : git branch  -d  test
</code></pre>
<p>git branch -D 【分支名】     强制删除 分支</p>
<pre><code>示例 : git branch  -D  test
</code></pre>
<p>git merge 【分支名】 ：合并分支，到当前分支</p>
<pre><code>示例：git merge dev
</code></pre>
<p>git checkout 【分支名】：切换到那个分支</p>
<pre><code>示例：git checkout dev
</code></pre>
<p><font color="red">git checkout -b 【分支名】 【远程分支名】：新建一个分支，来自远程分支</font></p>
<pre><code>示例：git checkout -b  dev origin/dev
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>nginx配置</title>
    <url>/2023/07/27/nginx%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一-、配置详解"><a href="#一-、配置详解" class="headerlink" title="一 、配置详解"></a>一 、配置详解</h1><h2 id="1-1nginx配置文件"><a href="#1-1nginx配置文件" class="headerlink" title="1.1nginx配置文件"></a>1.1nginx配置文件</h2><pre><code>#nginx 已那个用户身份访问文件
user  www;  

#指定nginx使用的worker进程数
worker_processes 8;   

#worker_cpu_affinity是一个用于配置工作进程CPU亲和性的选项。
#CPU亲和性是指将进程或线程绑定到特定的CPU核心上，以提高性能和效率。
#通常cpu几核，就配置几个
worker_cpu_affinity 0000001 00000010 00000011 00000100 00000101 00000110 00000111 00001000;

#PID配置项是用于指定保存主进程ID的文件路径
pid        /var/run/nginx.pid;

#用于限制每个worker进程可以打开的最大文件描述符数量。
#ulimit -n 查看系统文件句柄数   设置为系统允许的最大文件句柄数的 80% - 90%
worker_rlimit_nofile 65535;


#用于控制Nginx服务器的事件模型和并发处理方式。
events &#123;
    #用于设置每个worker进程的最大并发连接数 即每个worker进程可以同时处理的最大客户端连接数
    worker_connections 1024;
    
    #常见的事件模型包括epoll、kqueue和select等。
    use epoll;
    
    #用于指定是否允许一个worker进程同时接受多个新连接
    multi_accept on;
&#125;

#用于代理TCP和UDP流量，允许将Nginx作为代理服务器来处理网络流量
#使用stream模块可以使Nginx具备代理TCP和UDP流量的能力
stream &#123;
       include /etc/nginx/stream/*.conf;
&#125;

#此模块用于配置HTTP服务器，允许主机作为Web服务器来处理HTTP请求
http &#123;
    #引入mime头文件  定义了Nginx的mime类型    
    include       mime.types;
    
    #指令用于设置在请求无法匹配到任何MIME类型时的默认类型
    default_type  application/octet-stream;
    
    #定义日志格式  main 为日志格式 名称
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
                      
    #定义访问日志路径 main 指用那个日志格式名称                  
    access_log  /var/log/nginx/access.log  main;
    
    # 当将sendfile设置为on时，Nginx使用sendfile()系统调用来直接将文件从磁盘传输到网络，
    # 而无需将文件数据复制到用户空间。这样可以显着提高文件传输速度和效率。
    sendfile on;
    
    #将tcp_nopush设置为on时，Nginx会禁用TCP_CORK
    #允许在nginx worker进程发送数据时立即将响应发送到客户端，而无需等待TCP缓冲区填满。
    #将tcp_nopush设置为on可以提高响应的实时性，允许立即发送数据到客户端
    tcp_nopush on;
    
    #将tcp_nodelay设置为on时，Nginx会打开TCP_NODELAY，这将禁用TCP的Nagle算法，
    #以便在发送小数据包或有延迟要求的数据时能够及时发送数据。
    #将tcp_nodelay设置为on可以减少TCP延迟，适用于实时性要求高的应用场景。
    tcp_nodelay on;
    
    
    #配置空主机头 404 就是禁用http通过ip访问
    server &#123;
       listen 80 default;
       server_name _;
       root html;
       location / &#123; return 404;&#125;
       location ~ /.ht &#123; deny all; &#125;
    &#125;
    
    include /etc/nginx/conf.d/*.conf;
&#125;
</code></pre>
<h2 id="1-2log-format可用变量"><a href="#1-2log-format可用变量" class="headerlink" title="1.2log_format可用变量"></a>1.2log_format可用变量</h2><pre><code>$remote_addr：客户端的IP地址。
$remote_user：客户端的用户名称（如果有授权）。
$time_local：访问时间和日期（格式：[day/month/year:hour:minute:second zone]）。
$request_method：HTTP请求的方法（例如GET或POST）。
$request_uri：完整的请求URI。
$request_length：请求的长度（包括请求行，请求头和请求体）。
$status：HTTP响应的状态码。
$body_bytes_sent：发送给客户端的响应体的字节数。
$http_referer：请求中的“Referer”头部字段，包含了前一个页面的URL。
$http_user_agent：请求的用户代理头部字段，表示发起请求的客户端工具或库。
</code></pre>
<h2 id="1-3host配置文件"><a href="#1-3host配置文件" class="headerlink" title="1.3host配置文件"></a>1.3host配置文件</h2><h3 id="upstream-模块"><a href="#upstream-模块" class="headerlink" title="upstream 模块"></a>upstream 模块</h3><pre><code>#定义负载均衡
#放置在 http 或 server 块
upstream name &#123;
    
     #用于指定上游服务器的地址和端口。可以指定多个server来定义多个上游服务器。
     server backend1.example.com;
     
     #max_fails 和 fail_timeout：用于设置上游服务器的故障处理策略
     #max_fails 指定在多少次失败请求后将服务器标记为不可用
     #fail_timeout 指定在服务器被标记为不可用后，多长时间内不再尝试请求。
     server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;
    
    #设置与上游服务器的连接保持活动的时间。可以提高性能并减少连接建立的开销。
    keepalive:32;

&#125;

#weight：用于设置服务器的权重。权重越高，Nginx 转发给该服务器的请求越多。
#示例：
upstream backend &#123;
    server backend1.example.com weight=3;
    server backend2.example.com weight=2;
&#125;



#ip_hash：使用客户端的IP地址进行负载均衡，使得来自同一IP地址的请求始终被转发到同一台上游服务器。
#示例：
upstream backend &#123;
    ip_hash;
    server backend1.example.com;
    server backend2.example.com;
&#125;
</code></pre>
<h3 id="Server模块"><a href="#Server模块" class="headerlink" title="Server模块"></a>Server模块</h3><pre><code>server：定义一个虚拟主机
server&#123;
    listen：指定服务器监听的端口
    server_name：配置域名或IP地址
    root：指定网站文件的根目录
    index：定义当访问网站时默认显示的文件
    location：定义请求的URL匹配规则和对应的处理方法。
    proxy_pass：用于反向代理服务器的配置。
    ssl_certificate和ssl_certificate_key：配置SSL/TLS证书。
    try_files：定义文件检查规则
    
    gzip on;    将 Gzip 压缩功能开启。
    
    将所有类型的文件都进行 Gzip 压缩。这意味着无论是文本文件、图像文件还是视频文件，
    都将进行压缩传输。如果你希望只压缩特定类型的文件，可以指定具体的文件类型，
    例如 gzip_types text/plain text/css application/javascript;。
    gzip_types *;
   
    (gzip_proxied on or gzip_proxied off or gzip_proxied expired no-cache no-store private auth) 指定需要压缩的响应类型，
    并且设置允许或者不允许使用代理服务器进行压缩。any 表示无论何时都进行压缩。
    gzip_proxied any;
&#125;
</code></pre>
<h1 id="二、常用示例"><a href="#二、常用示例" class="headerlink" title="二、常用示例"></a>二、常用示例</h1><h2 id="2-1-mysql-代理示例"><a href="#2-1-mysql-代理示例" class="headerlink" title="2.1 mysql 代理示例"></a>2.1 mysql 代理示例</h2><pre><code>stream &#123;
        server &#123;
            listen 63306;
            proxy_connect_timeout 8s;
            proxy_timeout 24h;
            proxy_pass 192.168.0.108:3306;
        &#125;
&#125;
</code></pre>
<h2 id="2-3-带upstream的写法"><a href="#2-3-带upstream的写法" class="headerlink" title="2.3 带upstream的写法"></a>2.3 带upstream的写法</h2><pre><code>upstream rd_servers &#123;
  server 127.0.0.1:5000;
&#125;

server&#123;
  server_tokens off;
  listen 80;
  server_name redash.xxxxx.com;
  access_log /var/log/nginx/rd.access.log;

  gzip on;
  gzip_types *;
  gzip_proxied any;

  location / &#123;
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_pass       http://rd_servers;
  &#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>shell脚本学习1</title>
    <url>/2023/07/29/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A01-1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>nginx之location</title>
    <url>/2023/07/29/nginx%E4%B9%8Blocation/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>升级openssh</title>
    <url>/2023/08/01/%E5%8D%87%E7%BA%A7openssh/</url>
    <content><![CDATA[<h1 id="centos系统"><a href="#centos系统" class="headerlink" title="centos系统"></a>centos系统</h1><h2 id="查看是否安装openssh"><a href="#查看是否安装openssh" class="headerlink" title="查看是否安装openssh"></a>查看是否安装openssh</h2><pre><code>rpm -qa|grep openssh
有则卸载

卸载用rpm -e 如果出现依赖包导致无法卸载，在最后面加上--nodeps即可
rpm -e openssl --nodeps
yum remove openssh-server

卸载还可以手动删除
  /etc/init.d/sshd 
  /etc/ssh
  /usr/bin/ssh
  /usr/sbin/sshd
      
</code></pre>
<h2 id="查当前openssh版本是否需要升级"><a href="#查当前openssh版本是否需要升级" class="headerlink" title="查当前openssh版本是否需要升级"></a>查当前openssh版本是否需要升级</h2><pre><code>ssh -V
</code></pre>
<h2 id="备份配置文件"><a href="#备份配置文件" class="headerlink" title="备份配置文件"></a>备份配置文件</h2><pre><code>mv /etc/ssh /etc/ssh.bak
</code></pre>
<h2 id="下载最新版本"><a href="#下载最新版本" class="headerlink" title="下载最新版本"></a>下载最新版本</h2><pre><code>https://www.openssh.com/openbsd.html    
</code></pre>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><pre><code>./configure \
  --prefix=/usr \
  --sysconfdir=/etc/ssh \
  --with-md5-passwords \
  --with-pam \
  --with-tcp-wrappers \
  --with-ssl-dir=/usr/local/ssl
  
  
  make &amp;&amp; make install
    
</code></pre>
<h2 id="修改相关配置"><a href="#修改相关配置" class="headerlink" title="修改相关配置"></a>修改相关配置</h2><pre><code>cp -p contrib/redhat/sshd.init /etc/init.d/sshd 

chmod u+x /etc/init.d/sshd 

/etc/init.d/sshd start 此命令后就加入systemctl

systemctl enable sshd 加入开机启动

# vim /etc/ssh/sshd_config
PermitRootLogin yes                #允许root账户登录，单root账户必须加上，其他的参数请自行修改
</code></pre>
<h2 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h2><pre><code>1.编译时报错

    configure: error: PAM headers not found
    
解决方法
    
    yum -y install pam-devel
    
    
2.编译别的目录，然后通过相应文件覆盖或者软连接方式更新
  如果密码正确 就是登录不上
  
  删除重装     
</code></pre>
<h1 id="ubutun系统"><a href="#ubutun系统" class="headerlink" title="ubutun系统"></a>ubutun系统</h1><h2 id="查看是否安装"><a href="#查看是否安装" class="headerlink" title="查看是否安装"></a>查看是否安装</h2><pre><code>dpkg --list|grep ssh
卸载
sudo apt-get remove openssh-server 
</code></pre>
<h2 id="编译过程参考centos即可"><a href="#编译过程参考centos即可" class="headerlink" title="编译过程参考centos即可"></a>编译过程参考centos即可</h2>]]></content>
  </entry>
  <entry>
    <title>springboot学习</title>
    <url>/2023/08/01/springboot%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="创建基于springboot-项目"><a href="#创建基于springboot-项目" class="headerlink" title="创建基于springboot 项目"></a>创建基于springboot 项目</h2><h2 id="1-maven方式"><a href="#1-maven方式" class="headerlink" title="1.maven方式"></a>1.maven方式</h2><pre><code>pom.xml文件加入

  &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.6&lt;/version&gt;
   &lt;/parent&gt;
   
   
   &lt;dependencies&gt;
       &lt;!-- Web 依赖 --&gt;
       &lt;dependency&gt;
           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
       &lt;/dependency&gt;
       &lt;!-- Web 依赖 --&gt;
   &lt;/dependencies&gt;

更新库就可以
</code></pre>
<h2 id="2-通过官网的spring-initializr安装"><a href="#2-通过官网的spring-initializr安装" class="headerlink" title="2. 通过官网的spring initializr安装"></a>2. 通过官网的spring initializr安装</h2><pre><code>https://start.spring.io/  
</code></pre>
<h2 id="3-idea旗舰版-新建时-可以选"><a href="#3-idea旗舰版-新建时-可以选" class="headerlink" title="3.idea旗舰版 新建时 可以选"></a>3.idea旗舰版 新建时 可以选</h2><h2 id="Spring-Boot-应用启动类，"><a href="#Spring-Boot-应用启动类，" class="headerlink" title="Spring Boot 应用启动类，"></a>Spring Boot 应用启动类，</h2><p> 在package创建类加上@SpringBootApplication</p>
<pre><code>package com.zysstudy;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class StartApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(StartApplication.class,args);
    &#125;

&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>搭建openvpn</title>
    <url>/2023/08/28/%E6%90%AD%E5%BB%BAopenvpn/</url>
    <content><![CDATA[<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><h2 id="1-1、安装epel库和openvpn软件"><a href="#1-1、安装epel库和openvpn软件" class="headerlink" title="1.1、安装epel库和openvpn软件"></a>1.1、安装epel库和openvpn软件</h2><pre><code>yum -y install openvpn easy-rsa firewalld

yum install epel-release -y
</code></pre>
<h2 id="1-2、开启路由转发"><a href="#1-2、开启路由转发" class="headerlink" title="1.2、开启路由转发"></a>1.2、开启路由转发</h2><pre><code> echo  &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt;/etc/sysctl.conf
 sysctl -p
</code></pre>
<h2 id="1-3、创建OpenVPN相关的密钥"><a href="#1-3、创建OpenVPN相关的密钥" class="headerlink" title="1.3、创建OpenVPN相关的密钥"></a>1.3、创建OpenVPN相关的密钥</h2><pre><code> cp -rf /usr/share/easy-rsa/3.0/* /etc/openvpn/easy-rsa/
 cp -p /usr/share/doc/easy-rsa-3.0.6/vars.example /etc/openvpn/easy-rsa/vars
 cd /etc/openvpn/easy-rsa/
</code></pre>
<h3 id="1-3-1、创建ca证书"><a href="#1-3-1、创建ca证书" class="headerlink" title="1.3.1、创建ca证书"></a>1.3.1、创建ca证书</h3><pre><code>/usr/share/easy-rsa/3/easyrsa init-pki
/usr/share/easy-rsa/3/easyrsa build-ca nopass
</code></pre>
<h3 id="1-3-2、创建client证书和签名"><a href="#1-3-2、创建client证书和签名" class="headerlink" title="1.3..2、创建client证书和签名"></a>1.3..2、创建client证书和签名</h3><pre><code>/usr/share/easy-rsa/3/easyrsa gen-req client1 nopass           #Enter
/usr/share/easy-rsa/3/easyrsa sign-req client client1          #需要输入yes
创建dh、tls、crl（证书撤销秘钥）
/usr/share/easy-rsa/3/easyrsa gen-dh
openvpn --genkey --secret /etc/openvpn/easy-rsa/ta.key
/usr/share/easy-rsa/3/easyrsa  gen-crl
</code></pre>
<h3 id="1-3-3、将秘钥拷贝至相应目录"><a href="#1-3-3、将秘钥拷贝至相应目录" class="headerlink" title="1.3.3、将秘钥拷贝至相应目录"></a>1.3.3、将秘钥拷贝至相应目录</h3><pre><code>cp -p pki/ca.crt /etc/openvpn/server/
cp -p pki/issued/server1.crt /etc/openvpn/server/
cp -p pki/private/server1.key /etc/openvpn/server/
cp -p ta.key /etc/openvpn/server/
cp -p pki/ca.crt /etc/openvpn/client/
cp -p pki/issued/client1.crt /etc/openvpn/client/
cp -p pki/private/client1.key /etc/openvpn/client/
cp -p ta.key /etc/openvpn/client/
cp pki/dh.pem /etc/openvpn/server/
cp pki/crl.pem /etc/openvpn/server/
cp /usr/share/doc/openvpn-2.4.11/sample/sample-config-files/server.conf /etc/openvpn/
</code></pre>
<h1 id="二、配置-openvpn"><a href="#二、配置-openvpn" class="headerlink" title="二、配置 openvpn"></a>二、配置 openvpn</h1><h2 id="2-1、编辑配置文件-etc-openvpn-server-conf"><a href="#2-1、编辑配置文件-etc-openvpn-server-conf" class="headerlink" title="2.1、编辑配置文件 /etc/openvpn/server.conf"></a>2.1、编辑配置文件 /etc/openvpn/server.conf</h2><pre><code>cp /usr/share/doc/openvpn-2.4.11/sample/sample-config-files/server.conf /etc/openvpn/      
#拷贝实例修改或直接拷贝以下内容
vim /etc/openvpn/server.conf

local 0.0.0.0    #监听地址
port 1194        #监听端口
proto tcp        #监听协议
dev tun          #采用路由隧道模式
ca /etc/openvpn/server/ca.crt              #ca证书路径
cert /etc/openvpn/server/server1.crt       #服务器证书
key /etc/openvpn/server/server1.key        #服务器秘钥
dh /etc/openvpn/server/dh.pem              #密钥交换协议文件
#####注意在设备中加一条到10.100.100.0虚拟网段的路由！！！！
server 10.100.100.0 255.255.255.0          
####给客户端分配地址池，注意：不能和VPN服务器内网网段有相同
#####注意在设备中加一条到10.100.100.0虚拟网段的路由！！！！
ifconfig-pool-persist ipp.txt
#push &quot;redirect-gateway def1 bypass-dhcp&quot;      #推送默认路由（所有流量走vpn）
push &quot;route 192.168.0.0 255.255.255.0&quot;           
#推送客户端常用路由（根据自己内网网段来写或修改客户端配置添加路由）
push &quot;dhcp-option DNS 192.168.5.251&quot;           #dhcp分配dns
client-to-client       #客户端之间互相通信
keepalive 10 120       #存活时间，10秒ping一次,120 如未收到响应则视为断线
comp-lzo               #传输数据压缩
max-clients 100        #最多允许 100 客户端连接
user openvpn           #用户
group openvpn          #用户组
cipher AES-256-CBC     #加密方式--客户端必须一致
persist-key
persist-tun
status /var/log/openvpn-status.log
log         /var/log/openvpn.log
verb 3
#以下参数为用户认证使用
script-security 3
auth-user-pass-verify /etc/openvpn/checkpsw.sh via-env    #指定用户认证脚本
username-as-common-name
verify-client-cert none
</code></pre>
<h2 id="2-2虚拟网段的路由"><a href="#2-2虚拟网段的路由" class="headerlink" title="2.2虚拟网段的路由"></a>2.2虚拟网段的路由</h2><pre><code>iptables -t nat -A POSTROUTING -s 10.100.100.0/24 -j MASQUERADE
</code></pre>
<h1 id="三、用户认证"><a href="#三、用户认证" class="headerlink" title="三、用户认证"></a>三、用户认证</h1><h2 id="3-1编写用户认证脚本文件-脚本是由openvpn官网提供"><a href="#3-1编写用户认证脚本文件-脚本是由openvpn官网提供" class="headerlink" title="3.1编写用户认证脚本文件 (脚本是由openvpn官网提供)"></a>3.1编写用户认证脚本文件 (脚本是由openvpn官网提供)</h2><pre><code>vim /etc/openvpn/checkpsw.sh
#!/bin/sh
###########################################################
# checkpsw.sh (C) 2004 Mathias Sundman 
# This script will authenticate OpenVPN users against
# a plain text file. The passfile should simply contain
# one row per user with the username first followed by
# one or more space(s) or tab(s) and then the password.

PASSFILE=&quot;/etc/openvpn/psw-file&quot;
LOG_FILE=&quot;/etc/openvpn/openvpn-password.log&quot;
TIME_STAMP=`date &quot;+%Y-%m-%d %T&quot;`
###########################################################

if [ ! -r &quot;$&#123;PASSFILE&#125;&quot; ]; then
  echo &quot;$&#123;TIME_STAMP&#125;: Could not open password file \&quot;$&#123;PASSFILE&#125;\&quot; for reading.&quot; &gt;&gt;$&#123;LOG_FILE&#125;
  exit 1
fi

CORRECT_PASSWORD=`awk &#39;!/^;/&amp;&amp;!/^#/&amp;&amp;$1==&quot;&#39;$&#123;username&#125;&#39;&quot;&#123;print $2;exit&#125;&#39; $&#123;PASSFILE&#125;`

if [ &quot;$&#123;CORRECT_PASSWORD&#125;&quot; = &quot;&quot; ]; then 
  echo &quot;$&#123;TIME_STAMP&#125;: User does not exist: username=\&quot;$&#123;username&#125;\&quot;, password=\&quot;$&#123;password&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;
  exit 1
fi

if [ &quot;$&#123;password&#125;&quot; = &quot;$&#123;CORRECT_PASSWORD&#125;&quot; ]; then 
  echo &quot;$&#123;TIME_STAMP&#125;: Successful authentication: username=\&quot;$&#123;username&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;
  exit 0
fi

echo &quot;$&#123;TIME_STAMP&#125;: Incorrect password: username=\&quot;$&#123;username&#125;\&quot;,     password=\&quot;$&#123;password&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;
exit 1
</code></pre>
<h2 id="3-2-加权限及添加用户账号"><a href="#3-2-加权限及添加用户账号" class="headerlink" title="3.2 加权限及添加用户账号"></a>3.2 加权限及添加用户账号</h2><pre><code>给脚本添加执行权限
chmod 755 /etc/openvpn/checkpsw.sh


编辑密码文件
vim /etc/openvpn/psw-file
tom  123456
Jerry 654321
#前面为用户名，后面为密码。 中间使用空格分开
</code></pre>
<h1 id="四、客户端配置"><a href="#四、客户端配置" class="headerlink" title="四、客户端配置"></a>四、客户端配置</h1><pre><code>client.ovpn

##---------以下为将ca.crt证书写入到客户端文件的方式（直接给一个client.ovpn文件即可）------------##
client
dev tun
proto tcp   #根据服务端的来
remote utnanjing.tpddns.cn 11194
resolv-retry infinite
nobind
persist-key
persist-tun
&lt;ca&gt;
-----BEGIN CERTIFICATE-----
MIIDNTCCAh2gAwIBAgIJAJgy1QReG9VmMA0GCSqGSIb3DQEBCwUAMBYxFDASBgNV
BAMMC0Vhc3ktUlNBIENBMB4XDTIzMDgyNDA5NTgzN1oXDTMzMDgyMTA5NTgzN1ow
FjEUMBIGA1UEAwwLRWFzeS1SU0EgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw
ggEKAoIBAQDLutXX/OaN1muPGKQV2uiEaZbQy9F0PptJxM3ZTHdyn+HuQ/3xqYHz
z6hgIr2IjWtD5pqZXGMwIxbpNFKfPfJtwU5xpuUA6hxWV3yYtaXGsaLvFA0StL/N
P5/3VgL1KpdcivjMejgVCwX5CkN97hsS6uk9Z/PUB9OEAWygeRHS8CYQ37PhXmDC
h/1VeXWZDHJzxCD1fqoo2dB8MGFJjvg3FVQ0o8Gf0XE9cvj5dtk73f6AyiuYTeLL
nD8vY8jbCVGeLcnoDnduK6y6ZLFOUHWfEPH+a1jDFLpXIby0oo3yBWcldzaKJMzf
UP7HoczkDaUo5ykecDjxGkD8kpTmwyQPAgMBAAGjgYUwgYIwHQYDVR0OBBYEFPCY
FNHxZ/eBKLRh009Bm08j8zurMEYGA1UdIwQ/MD2AFPCYFNHxZ/eBKLRh009Bm08j
8zuroRqkGDAWMRQwEgYDVQQDDAtFYXN5LVJTQSBDQYIJAJgy1QReG9VmMAwGA1Ud
EwQFMAMBAf8wCwYDVR0PBAQDAgEGMA0GCSqGSIb3DQEBCwUAA4IBAQCYFaym5wCr
lti+7p9MqLm4UF7pOmZQ2NamZjP1cQuMh2SgdJphddZEhEUO5NOQms8gMJsZ3sd7
DIul+XkDcbhjKNNxD4oeXiITR8BgLsCkqtLStwWtOSLGxgHHWD3S+IBSM21A4Rxy
hE4VUr81i9XUM2lI7ml5RgCVTvbWosCnVFuXypaYs4/c1yJJ1I578M6oVWjahJOx
ENoeYYSI/V+2ySTtRQlW8HQEc4GhSeybhmXgrfLKhmHTVl/ZqZg5zp3kwBcnsrUQ
junuLBLMMYSLPXhJQFU/10EMxv/9AAdBGiO3RL0G2qYc0JF11qVpmD9nwP9f/YR3
Yvs7E2kwDViH
-----END CERTIFICATE-----
&lt;/ca&gt;
cipher AES-256-CBC
comp-lzo
verb 3
auth-user-pass              #使用用户名密码登录openvpn服务器
auth-nocache


证书方式

client
dev tun
proto tcp
remote 公网ipxxx.xxx.xxx.xxx 1194
resolv-retry infinite
nobind
persist-key
persist-tun
ca ca.crt
cert client1.crt  #拷贝自服务端
key client1.key   #拷贝自服务端 
remote-cert-tls server
cipher AES-256-CBC
comp-lzo
verb 3
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>vmvare-esxi虚拟机扩容</title>
    <url>/2023/08/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<p>修改硬盘大小</p>
<pre><code>先虚拟机管理页面修改硬盘大小
    注：不删除快照是 无法修改成功的
</code></pre>
<p>分区  </p>
<pre><code>fdisk /dev/sda    
n
p
默认确定
w
</code></pre>
<p>手动同步磁盘到系统内核</p>
<pre><code>partprobe
</code></pre>
<p>创建物理卷</p>
<pre><code>pvcreate /dev/sda3          #【/dev/sda3 是根据fdisk来的】
</code></pre>
<p>查看卷组</p>
<pre><code>vgdisplay
</code></pre>
<p>添加物理卷（/dev/sda3）到卷组（centos）</p>
<pre><code>vgextend centos /dev/sda3   #此处的centos根据vgdisplay查看得来
</code></pre>
<p>将空闲的空间都分配给root文件系统 </p>
<pre><code> lvextend -L +250G /dev/centos/root   【/dev/centos/root  就是要扩容的目录通过df 可查看】
</code></pre>
<p>对root文件系统执行扩容</p>
<pre><code>xfs_growfs /dev/centos/root
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>搭建nps内网穿透</title>
    <url>/2023/08/29/%E6%90%AD%E5%BB%BAnps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>内网穿透的方式有很多种，什么Frp、Ngrok、NPS、蒲公英等等，</p>
<h1 id="NPS简介"><a href="#NPS简介" class="headerlink" title="NPS简介"></a>NPS简介</h1><p>nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，<br>可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），<br>此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端</p>
<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><pre><code>配置docker阿里云 镜像
yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
    
yum install docker-ce docker-ce-cli containerd.io
</code></pre>
<h1 id="安装nps"><a href="#安装nps" class="headerlink" title="安装nps"></a>安装nps</h1><pre><code>拉取镜像
docker pull ffdfgdfg/nps

添加配置文件
创建nps挂载文件目录(自己随意设置)
mkdir -p /docker/nps/conf

配置下载地址 https://github.com/ehang-io/nps/blob/master/conf
修改刚下载的conf文件夹里的/docker/nps/conf/nps.conf文件：

web_host=a.o.com   #修改为你的域名admin.nps.youdomain.com
web_username=admin 
web_password=123   #修改为一个强密码，毕竟是放在公网上的服务
web_port = 8090    访问的端口号
web_ip=0.0.0.0


运行nps
docker run -d   --restart=always --name nps --net=host -v /docker/nps/conf:/conf ffdfgdfg/nps
</code></pre>
<h1 id="客户端安装npc"><a href="#客户端安装npc" class="headerlink" title="客户端安装npc"></a>客户端安装npc</h1><pre><code>拉取npc镜像
docker pull ffdfgdfg/npc


docker run -d --restart=always --name npc-227 --net=host ffdfgdfg/npc -server=111.231.69.227:8024 -vkey=dle31e3ry1yl616p
【参数 -server 服务端获取  -vkey 服务端获取】 
</code></pre>
<h1 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h1><pre><code>http://ip/8090  账号密码 配置文件中   
</code></pre>
]]></content>
  </entry>
</search>
