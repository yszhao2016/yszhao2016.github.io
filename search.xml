<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo基础应用</title>
    <url>/posts/cc20be5e.html</url>
    <content><![CDATA[<p>1.首先安装node,具体参考<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p>
<p>2.初始化 项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>
<p>将会在当前目录下产生blog文件夹</p>
<p>3.新建文章</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n 文章标题  //完整命令 hexo new 文章标题</span><br></pre></td></tr></table></figure>
<p>相应会在source/_posts 目录下产生   文章标题.md</p>
<p>4.生成html</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g        //完整命令  hexo generate</span><br></pre></td></tr></table></figure>
<p>将会在public目录生成相应的html文件</p>
<p>5.开启本地测试环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s        //完整命令  hexo server</span><br></pre></td></tr></table></figure>
<pre><code>http://loaclhost:4000就可以访问了
</code></pre>
<p>6.发布代码到github.io</p>
<pre><code>配置修改_config.yml文件
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  repo: https://github.com/github账号名称/github账号名称.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d       //发布到线上  hexo generate</span><br></pre></td></tr></table></figure>







]]></content>
  </entry>
  <entry>
    <title>Linux-firewalld使用总结</title>
    <url>/posts/34fa5185.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Linux之LVM(逻辑卷管理)</title>
    <url>/posts/427bdc6a.html</url>
    <content><![CDATA[<h1 id="一、基础"><a href="#一、基础" class="headerlink" title="一、基础"></a>一、基础</h1><p>一个  分区 对应 一个PV <font color="red">【pvcreate /dev/sdb1 /dev/sdb2 /dev/sdc1 /dev/sdc2】</font></p>
<p>多个PV 对应 一个VG <font color="red">【 vgcreate vgdata /dev/sdb1 /dev/sdb2 /dev/sdc1 /dev/sdc2】 </font></p>
<p>一个VG 中可以  分出多个LV <font color="red">【 lvcreate -L 11G -n lv001 vgdata 】</font></p>
<p><font color="red">查看命令 【pvdisplay vgdisplay lvdisplay】</font></p>
<pre><code> PV(Physical Volume)：物理卷，处于LVM最底层，可以是物理硬盘或者分区。

 VG(Volume Group)：卷组，建立在PV之上，可以含有一个到多个PV  
 
 LV(Logical Volume)：逻辑卷，建立在VG之上，相当于原来分区的概念。不过大小可以动态改变。  
 
 

 
 创建PV   pvcreate /dev/sdb1
 
 查看PV   pvscan
 
 创建一个名为vgdata的VG，并且将所有的新建的PV加入vgdata
 vgcreate vgdata /dev/sdb1 
 
 从VG vgdata中创建一个大小为11G的名为lv001的LV
 lvcreate -L 11G -n lv001 vgdata
 
 格式化
 mkfs.ext3    mkfs.ext4    mkfs.xfs
 mkfs.ext4  /dev/mapper/【vg名称】-【lv名称】
 示例mkfs.ext4 /dev/mapper/vgdata-lv001
 
 挂载
 mount /dev/mapper/vgdata-lv001 /data
 
 卸载
  umount 【设备名】
  
 xfs格式不支持缩容，只支持扩容
 
</code></pre>
<h1 id="二、新硬盘-扩容-根目录"><a href="#二、新硬盘-扩容-根目录" class="headerlink" title="二、新硬盘 扩容 根目录 /"></a>二、新硬盘 扩容 根目录 /</h1><h2 id="lsblk查看"><a href="#lsblk查看" class="headerlink" title="lsblk查看"></a>lsblk查看</h2><pre><code>     NAME               MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
     sda                  8:0    0   60G  0 disk 
     ├─sda1               8:1    0    1G  0 part /boot
     └─sda2               8:2    0   59G  0 part 
       ├─openeuler-root 253:0    0 40.4G  0 lvm  /
       ├─openeuler-swap 253:1    0    6G  0 lvm  
       └─openeuler-home 253:2    0 17.4G  0 lvm  /home
     sdb                  8:16   0    5G  0 disk 
     ├─sdb1               8:17   0  1.9G  0 part 
     └─sdb2               8:18   0  3.1G  0 part 
       └─vgdata-lv001   253:3    0    8G  0 lvm  
     sdc                  8:32   0    5G  0 disk 
     ├─sdc1               8:33   0  2.5G  0 part 
     │ └─vgdata-lv001   253:3    0    8G  0 lvm  
     └─sdc2               8:34   0  2.5G  0 part 
       └─vgdata-lv001   253:3    0    8G  0 lvm  
     sdd                  8:48   0    5G  0 disk 
     └─sdd1               8:49   0    5G  0 part 
       └─openeuler-root 253:0    0 40.4G  0 lvm  /
     sr0                 11:0    1  3.5G  0 rom
</code></pre>
<h2 id="分区新的硬盘"><a href="#分区新的硬盘" class="headerlink" title="分区新的硬盘"></a>分区新的硬盘</h2><pre><code>fdisk /dev/sdd
默认值 回车 就可以了
</code></pre>
<h2 id="查看vg"><a href="#查看vg" class="headerlink" title="查看vg"></a>查看vg</h2><pre><code>vgscan      

[root@k8snode-2 ~]# vgscan
Found volume group &quot;vgdata&quot; using metadata type lvm2
Found volume group &quot;openeuler&quot; using metadata type lvm2

vgdisplay  查看vg还有多少空余空间
</code></pre>
<h2 id="扩展-vg"><a href="#扩展-vg" class="headerlink" title="扩展 vg"></a>扩展 vg</h2><pre><code>#将新建的分区/dev/sdd1  加入openeuler vg中
vgextend openeuler /dev/sdd1   
</code></pre>
<h2 id="扩充逻辑卷"><a href="#扩充逻辑卷" class="headerlink" title="扩充逻辑卷"></a>扩充逻辑卷</h2><pre><code>lvextend -L +5G /dev/mapper/openeuler-root

df -h 可以查看目录挂载的 逻辑卷

[root@k8snode-2 ~]# df -h
文件系统                    容量  已用  可用 已用% 挂载点
devtmpfs                    4.0M     0  4.0M    0% /dev
tmpfs                       3.7G     0  3.7G    0% /dev/shm
tmpfs                       1.5G  147M  1.4G   10% /run
tmpfs                       4.0M     0  4.0M    0% /sys/fs/cgroup
/dev/mapper/openeuler-root   40G  5.0G   33G   14% /
tmpfs                       3.7G     0  3.7G    0% /tmp
/dev/sda1                   974M  151M  756M   17% /boot
/dev/mapper/openeuler-home   17G  709M   16G    5% /home

  
</code></pre>
<h2 id="更新文件系统（争对不同的文件系统，其更新的命令也不一样"><a href="#更新文件系统（争对不同的文件系统，其更新的命令也不一样" class="headerlink" title="更新文件系统（争对不同的文件系统，其更新的命令也不一样"></a>更新文件系统（争对不同的文件系统，其更新的命令也不一样</h2><pre><code>e2fsck -f /dev/datavg/lvdata1 #ext4文件系统，检查lv的文件系统

resize2fs /dev/VG/LV01 #ext4文件系统命令，该命令后面接lv的设备名就行

xfs_growfs /nas #xfs文件系统，该命令后面直接跟的是挂载点

当更新文件系统后，你就会发现，df -h正常了
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>Linux服务之crond</title>
    <url>/posts/ceed82ea.html</url>
    <content><![CDATA[<h1 id="一、Cron介绍"><a href="#一、Cron介绍" class="headerlink" title="一、Cron介绍"></a>一、Cron介绍</h1><p>Cron被用来进行Linux系统的计划任务执行</p>
<h1 id="二、相关目录"><a href="#二、相关目录" class="headerlink" title="二、相关目录"></a>二、相关目录</h1><p>cron.d/*用来存放一些软件的Cron设置</p>
<p>cron.daily/每天执行一次的任务</p>
<p>cron.hourly/每小时执行一次的任务</p>
<p>cron.monthly/每个月执行一次的任务</p>
<p>cron.weekly/，每周执行一次的任务</p>
<p>每分钟执行一次脚本</p>
<pre><code>crontab -e
</code></pre>
<h1 id="三、crontab使用"><a href="#三、crontab使用" class="headerlink" title="三、crontab使用"></a>三、crontab使用</h1><pre><code>*  *  *   *  *  命令/脚本
分 时 日 月 周

1  *  *   *  *  命令/脚本   指的是每个小时的第一分钟
*/1 * * * *     命令/脚本   每分钟执行脚本


crontab -l
查看计划任务列表   
</code></pre>
<h1 id="四、-etc-cron-daily-与crontab-e-定义的区别"><a href="#四、-etc-cron-daily-与crontab-e-定义的区别" class="headerlink" title="四、/etc/cron.daily 与crontab -e 定义的区别"></a>四、/etc/cron.daily 与crontab -e 定义的区别</h1><pre><code>/etc/cron.daily 和 crontab -e 都是用来设置定时任务的方式，但它们有一些不同之处。

/etc/cron.daily 是一个目录，里面存放着以 &quot;cron&quot; 格式命名的脚本文件。这些脚本会每天执行一次，通常在系统闲置时执行。这个目录中的脚本是全局的，适用于整个系统的所有用户。

而 crontab -e 则是一个命令，用于编辑和管理用户个人的 crontab 文件。crontab 文件中定义了用户的定时任务计划。通过编辑 crontab 文件，用户可以设置自己的定时任务，包括每天、每周、每月或其他时间间隔的执行。

因此，主要区别在于：

/etc/cron.daily 适用于全局系统级别的定时任务，而 crontab -e 是用户级别的定时任务。
/etc/cron.daily 中的脚本在每天执行一次，而 crontab -e 可以更精确地设置时间间隔。
/etc/cron.daily 中的脚本对所有用户有效，而 crontab -e 只对当前用户有效。
需要注意的是，修改 /etc/cron.daily 目录中的文件需要 root 权限，而 crontab -e 只需要用户自己的权限
</code></pre>
<h1 id="五、Linux-anacron"><a href="#五、Linux-anacron" class="headerlink" title="五、Linux anacron"></a>五、Linux anacron</h1><p> 执行由于关机  忘记执行的任务</p>
<p> 配置好 /etc/anacrontab 文件</p>
<p> 更具体学习参考<a href="http://c.biancheng.net/view/1095.html">http://c.biancheng.net/view/1095.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>ansible学习-playbook之nginx安装</title>
    <url>/posts/78909e13.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"> - name: install nginx</span><br><span class="line">   hosts: test</span><br><span class="line">   tasks:</span><br><span class="line">    - name: Print ansible_os_family</span><br><span class="line">      debug:</span><br><span class="line">       var: ansible_os_family    </span><br><span class="line">    #关闭selinux     </span><br><span class="line">    - name: disable selinux</span><br><span class="line">      shell: &quot;setenforce 0&quot;</span><br><span class="line">      ignore_errors: true</span><br><span class="line">    - name: Update apt package cache</span><br><span class="line">      apt:</span><br><span class="line">        update_cache: yes</span><br><span class="line">      ignore_errors: true</span><br><span class="line">      when: ansible_os_family in [&quot;Debian&quot;,&quot;ubuntu&quot;]     </span><br><span class="line">    - name: ubuntu install nginx</span><br><span class="line">      apt:</span><br><span class="line">        name: nginx</span><br><span class="line">        state: present   </span><br><span class="line">      when: ansible_os_family in [&quot;Debian&quot;,&quot;ubuntu&quot;]</span><br><span class="line">    - name: Add repo </span><br><span class="line">      yum_repository:</span><br><span class="line">       name: nginx</span><br><span class="line">       description: nginx repo</span><br><span class="line">       baseurl: http://nginx.org/packages/centos/7/$basearch/</span><br><span class="line">       gpgcheck: no</span><br><span class="line">       enabled: 1</span><br><span class="line">      when: ansible_os_family in  [&quot;RedHat&quot;,&quot;openEuler&quot;]</span><br><span class="line">    - name: redhat install nginx</span><br><span class="line">      yum:</span><br><span class="line">       name: nginx</span><br><span class="line">       state: latest</span><br><span class="line">      when: ansible_os_family in [&quot;RedHat&quot;,&quot;openEuler&quot;]</span><br><span class="line">    - name: start nginx server</span><br><span class="line">      service: name=nginx state=started</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>ansible学习-playbook之nginx配置</title>
    <url>/posts/45805688.html</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- name: install nginx</span><br><span class="line">  hosts: test</span><br><span class="line">  gather_facts: yes      </span><br><span class="line">#  vars:</span><br><span class="line">#       createuser:</span><br><span class="line">#        - tomcat</span><br><span class="line">#        - www</span><br><span class="line">#        - mysql</span><br><span class="line">  vars:</span><br><span class="line">   username: www      </span><br><span class="line">  tasks:</span><br><span class="line">   - name: Print ansible_os_family</span><br><span class="line">     debug:</span><br><span class="line">   #利用循环创建多个用户</span><br><span class="line">   # - name: create user</span><br><span class="line">   #  user: name=&#123;&#123;item&#125;&#125; state=present</span><br><span class="line">   #  with_items: &quot;&#123;&#123;createuser&#125;&#125;&quot;     </span><br><span class="line">   - name: Create Nginx User</span><br><span class="line">     user: name=&#123;&#123;username&#125;&#125; state=present createhome=no shell=/sbin/nologin</span><br><span class="line">   - name: template config to remote hosts</span><br><span class="line">     template: src=template/nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">#   - name: add virtualhost config</span><br><span class="line">#      copy: src=my.conf dest=/etc/nginx/conf.d/</span><br><span class="line">#      tags: updateconfig</span><br><span class="line">   #检查nginx是否运行</span><br><span class="line">   - name: check nginx running</span><br><span class="line">     stat: path=/var/run/nginx.pid</span><br><span class="line">     register: nginxrunning</span><br><span class="line">     tags: updateconfig</span><br><span class="line">   #检查nginx配置文件是否有问题          </span><br><span class="line">   - name: check nginx syntax</span><br><span class="line">     command: /usr/sbin/nginx -t</span><br><span class="line">     register: nginxsyntax   </span><br><span class="line">     check_mode: False   </span><br><span class="line">#     changed_when: true</span><br><span class="line">#     ignore_errors: true   </span><br><span class="line">     tags: updateconfig</span><br><span class="line">#删除上一步产生的pid</span><br><span class="line">#   - name: delete pid</span><br><span class="line">#     shell: rm -rf /var/run/nginx.pid</span><br><span class="line">   #debug  nginx状态</span><br><span class="line">   - name: print nginx syntax</span><br><span class="line">     debug:</span><br><span class="line">      var: &quot;nginxrunning, nginxsyntax&quot;</span><br><span class="line">   - name: reload nginx server</span><br><span class="line">     service: name=nginx state=reloaded</span><br><span class="line">     when: nginxsyntax.rc == 0  and nginxrunning.stat.exists == true</span><br><span class="line">     tags: updateconfig     </span><br><span class="line">   - name: start nginx server</span><br><span class="line">     service: name=nginx state=started</span><br><span class="line">     when: </span><br><span class="line">      - nginxsyntax.rc == 0</span><br><span class="line">      - nginxrunning.stat.exists == false</span><br><span class="line">     tags: updateconfig</span><br><span class="line">     </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>ansible学习</title>
    <url>/posts/901bc739.html</url>
    <content><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p> yum install -y epel-release</p>
<p> yum install -y ansible</p>
<p> ansible配置文件：</p>
<pre><code>/etc/ansible/ansible.cfg
/etc/ansible/hosts
</code></pre>
<p> 生成秘钥：</p>
<pre><code>ssh-keygen -t rsa  #在/root/.ssh/目录下生成秘钥
#被控端：(复制主机端公钥到被控端)
ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.7.99 
ssh-copy-id  被控端ip
</code></pre>
<h2 id="二、管理服务器：Inventory文件"><a href="#二、管理服务器：Inventory文件" class="headerlink" title="二、管理服务器：Inventory文件"></a>二、管理服务器：Inventory文件</h2><p>用于管理主机与主机组的文件 也叫主机清单<br>默认文件  /etc/ansible/hosts 最好不要用这  不然一不小心  没指定hosts 就执行这个了</p>
<p>文件示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[gs]</span><br><span class="line">gs157 ansible_ssh_host=1.11.1.11 ansible_ssh_port=65022</span><br><span class="line">[remote]</span><br><span class="line">kh251 ansible_ssh_host=2.22.222.2</span><br></pre></td></tr></table></figure>
<h2 id="三、基础命令"><a href="#三、基础命令" class="headerlink" title="三、基础命令"></a>三、基础命令</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>查看具体主机配置</p>
<pre><code>grep -v ^# /etc/ansible/hosts |grep -v ^$

ansible all --list-host     
</code></pre>
<h3 id="基础参数"><a href="#基础参数" class="headerlink" title="基础参数"></a>基础参数</h3><p>-m 指定模块【command copy shell】<br><font color="red">   忽略时，就默认是 -m command </font></p>
<pre><code>示例：  ansible -i ./hosts -a ifconfig  test
</code></pre>
<p>-a 模块中使用的参数</p>
<pre><code>示例：  ansible -i ./hosts -m shell -a &quot;free -mh&quot;  test
</code></pre>
<p>-i 指定hosts文件</p>
<pre><code>示例  ansible -i ./hosts -m ping test
</code></pre>
<h3 id="检查能否在受管主机上运行python模块"><a href="#检查能否在受管主机上运行python模块" class="headerlink" title="检查能否在受管主机上运行python模块"></a>检查能否在受管主机上运行python模块</h3><pre><code>ansible host-pattern -m module [-a &#39;module arguments&#39;] [-i inventory]
示例
    ansible gsweb -m ping
    
    ansible -i /etc/ansible/hosts gsweb -m ping

   
</code></pre>
<h3 id="command模块"><a href="#command模块" class="headerlink" title="command模块"></a>command模块</h3><pre><code>执行shell命令
-m 不使用 默认使用command模块

ansible -m command -a &quot;frem -mh&quot; test   

ansible -m command -a &quot;frem -mh&quot; test     

ansible  -a &quot;frem -mh&quot; test 
</code></pre>
<h3 id="shell模块"><a href="#shell模块" class="headerlink" title="shell模块"></a>shell模块</h3><p> 与command模块有些相似,但是command 有些命令无法执行</p>
<p>  命令行示例</p>
<pre><code> ansible -m shell -a &quot;cat /etc/*release&quot; test
</code></pre>
<h3 id="copy模块"><a href="#copy模块" class="headerlink" title="copy模块"></a>copy模块</h3><p>   参数</p>
<pre><code>src：    待copy的文件或目录

dest：   目标copy到远程主机的具体目录（必要参数）

owner：  目标copy到远程主机后的属主（远程主机上必须有对应的用户，否则报错）

group：  目标copy到远程主机后的属组（远程主机上必须有对应的组，否则报错）

mode：   目标copy到远程主机后的权限

content： 若不用src指定拷贝的文件，必须用content直接指定文件内容，2选一。 

force：   当远程主机的目标路径中已经存在同名文件，并且与ansible主机中的文件内容不同时，
          是否强制覆盖，可选值有yes和no。默认值为yes，表示覆盖，
          如果设置为no，则不会执行覆盖拷贝操作，远程主机中的文件保持不变。
          
backup：  当远程主机的目标路径中已经存在同名文件，并且与ansible主机中的文件内容不同时，
          是否对远程主机的文件进行备份，
          可选值有yes和no，当设置为yes时，会先备份远程主机中的文件，
          然后再将ansible主机中的文件拷贝到远程主机。
</code></pre>
<p>   命令行 示例</p>
<pre><code>   ansible khweb  -m copy -a &quot;src=/home/soft/node_exporter-1.6.1.linux-amd64.tar.gz  dest=/home/soft/  backup=yes mode=644&quot;
</code></pre>
<p>   playbook 示例</p>
<pre><code>   - name: Copy a file from local to remote
     copy:
      src: /path/to/local/file.txt
      dest: /path/to/remote/file.txt
      
      
   - name: &quot;copy files&quot;
         copy:
         src: &quot;&#123;&#123; item.src &#125;&#125;&quot;
         dest: &quot;&#123;&#123; item.dest &#125;&#125;&quot;
         owner: root
         group: root
         mode: 755
         with_items:
            - &#123;src: &quot;/root/aaa.txt&quot;, dest: &quot;/tmp&quot; &#125;
            - &#123;src: &quot;/root/bbb.txt&quot;, dest: &quot;/tmp&quot; &#125;
</code></pre>
<h3 id="setup模块"><a href="#setup模块" class="headerlink" title="setup模块"></a>setup模块</h3><h3 id="file模块"><a href="#file模块" class="headerlink" title="file模块"></a>file模块</h3><h3 id="debug模块"><a href="#debug模块" class="headerlink" title="debug模块"></a>debug模块</h3><h3 id="yum模块"><a href="#yum模块" class="headerlink" title="yum模块"></a>yum模块</h3><h3 id="user模块"><a href="#user模块" class="headerlink" title="user模块"></a>user模块</h3><h3 id="register模块"><a href="#register模块" class="headerlink" title="register模块"></a>register模块</h3><p> register 捕获 task 的输出，并将它保存到一个变量中，方便在以后的任务中调用</p>
<p> change： 表示执行命令的状态，如果命令执行了，则为 true；</p>
<p> cmd： 表示的则是你当前执行的命令；</p>
<p> delta： 表示命令执行所花费的时间</p>
<p> start： 表示命令开始执行的时间</p>
<p> end： 表示命令结束的时间</p>
<p> failed： 表示命令执行的结果，如果为 false 则表示命令执行成功，true 则表示命令执行失败</p>
<p> rc： 表示命令执行的返回码（return code），0 表示执行成功；</p>
<p> stderr：命令输出的标准错误信息</p>
<p> stderr_lines： 按换行符分割输出的内容，在多行输出时，显示的效果比 stderr 更加直观</p>
<p> stdout： 命令的标准输出信息</p>
<p> stdout_lines： 按换行符分割输出的内容，在多行输出时，结果更加直观    </p>
<pre><code>示例：
- name: View the logged in user name
  shell: whoami
  register: user
- debug:
    var: user  
     
- name: check nginx running
   stat: path=/var/run/nginx.pid
   register: nginxrunning   
- name: check nginx syntax
  shell: /usr/sbin/nginx -t
  register: nginxsyntax
# check_mode  true  -C测试 会跳过
  check_mode: false
  debug:
    var: &quot;nginxsyntax,nginxrunning&quot;
- name: reload nginx server
  service: name=nginx state=reloaded
  when: nginxsyntax.rc == 0  and nginxrunning.stat.exists == true   
    
    
</code></pre>
<h2 id="when模块"><a href="#when模块" class="headerlink" title="when模块"></a>when模块</h2><h2 id="debug与when连用"><a href="#debug与when连用" class="headerlink" title="debug与when连用"></a>debug与when连用</h2><h2 id="剧本（Playbooks）"><a href="#剧本（Playbooks）" class="headerlink" title="剧本（Playbooks）"></a>剧本（Playbooks）</h2><pre><code>Playbook可以运行多个任务，并提供一些更高级的功能。
让我们将上述任务移到一本剧本中。在ansible中剧本（playbooks）和角色（roles）都使用Yaml文件定义
</code></pre>
<h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><pre><code>gather_facts: no
只要是使用了ansible-playbook，默认情况，第 1 个步骤总是执行 Gathering Facts 这个TASK 
这个主要收集目标主机的常用信息，如：主机名、内核版本、网卡接口、IP 地址、操作系统版本、CPU、内存、磁盘 等等

tag标签可以单独使用
#启动nginx
    - name: start nginx server
      service: name=nginx state=started
      when: 
        - nginxsyntax.rc == 0
        - nginxrunning.stat.exists == false
      tags: updateconfig
      
 ansible-playbook -i hosts site.yml -t updateconfig     
      
通过debug模块去确认返回结果的数据结构   
- name: print nginx syntax result
  debug: var=nginxsyntax   
</code></pre>
<h3 id="定义变量-循环示例"><a href="#定义变量-循环示例" class="headerlink" title="定义变量 循环示例"></a>定义变量 循环示例</h3><pre><code> vars:
    createuser:
      - tomcat
      - www
      - mysql
      
  tasks:
   #利用循环创建多个用户
    - name: create user
      user: name=&#123;&#123;item&#125;&#125; state=present
      with_items: &quot;&#123;&#123;createuser&#125;&#125;&quot;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>docker学习2-DockerFile</title>
    <url>/posts/ad46b1ee.html</url>
    <content><![CDATA[<h1 id="Dockerfile-学习"><a href="#Dockerfile-学习" class="headerlink" title="Dockerfile 学习"></a>Dockerfile 学习</h1><h2 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h2><pre><code>FROM  scratch
ADD hello /
CMD [&quot;/hello&quot;]
</code></pre>
<h2 id="FROM语法"><a href="#FROM语法" class="headerlink" title="FROM语法"></a>FROM语法</h2><pre><code>FROM scratch   //制作  base image

FROM centos    //使用  base image

FROM ubuntu:14.4
</code></pre>
<h2 id="LABEL语法（类似注释作用）"><a href="#LABEL语法（类似注释作用）" class="headerlink" title="LABEL语法（类似注释作用）"></a>LABEL语法（类似注释作用）</h2><pre><code>LABEL maintainer=&quot;xiaoquwl@gmail.com&quot;
LABEL version=&quot;1.0&quot;
LABEL description=&quot;This is description&quot;
注：Metadata(元数据)不可少

示例：
LABEL org.opencontainers.image.authors=&quot;yeasy&quot;
LABEL org.opencontainers.image.documentation=&quot;https://yeasy.gitbooks.io&quot;
</code></pre>
<h2 id="RUN-语法"><a href="#RUN-语法" class="headerlink" title="RUN 语法"></a>RUN 语法</h2><pre><code>RUN yum update &amp;&amp; yum install -y vim \
python-dev 
注：反斜杠换行

RUN
</code></pre>
<h2 id="WORKDIR-语法"><a href="#WORKDIR-语法" class="headerlink" title="WORKDIR 语法"></a>WORKDIR 语法</h2><pre><code>设置工作目录，目录不存在，会自动创建

示列：
WORKDIR /test
WORKDIR abc
这样就工作在/test/abc目录下
注：
    1、RUN cd 能实现类似效果 但不推荐
    2、目录尽量示绝对目录
</code></pre>
<h2 id="ADD-amp-amp-COPY-语法"><a href="#ADD-amp-amp-COPY-语法" class="headerlink" title="ADD&amp;&amp;COPY 语法"></a>ADD&amp;&amp;COPY 语法</h2><pre><code>功能类似添加文件到容器
ADD 有解压缩功能

示列：
 ADD test.tar.gz /app/web
</code></pre>
<h2 id="ENV-语法"><a href="#ENV-语法" class="headerlink" title="ENV 语法"></a>ENV 语法</h2><pre><code>定义变量
示列：
    ENV  MYSQL_VERSION 5.6
    RUM yum install mysql_server=&quot;$&#123;MYSQL_VERSION&#125;&quot;
</code></pre>
<h2 id="VOLUME-amp-amp-EXPOSE"><a href="#VOLUME-amp-amp-EXPOSE" class="headerlink" title="VOLUME&amp;&amp;EXPOSE"></a>VOLUME&amp;&amp;EXPOSE</h2><pre><code>存储和网络
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>docker学习1-Docker基础命令</title>
    <url>/posts/2cb0387a.html</url>
    <content><![CDATA[<h1 id="Docker基础命令"><a href="#Docker基础命令" class="headerlink" title="Docker基础命令"></a>Docker基础命令</h1><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><pre><code>Docker image ls 
</code></pre>
<h3 id="查看运行中的容器container"><a href="#查看运行中的容器container" class="headerlink" title="查看运行中的容器container"></a>查看运行中的容器container</h3><pre><code>docker ps      展示 正在运行的

docker ps -a   所有  启动与未启动的 

docker ps -q
</code></pre>
<h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><pre><code>docker run 容器名称

示例：
</code></pre>
<h3 id="查看运行中的容器container-1"><a href="#查看运行中的容器container-1" class="headerlink" title="查看运行中的容器container"></a>查看运行中的容器container</h3><pre><code>docker inspect  容器名称    查看容器信息
</code></pre>
<h3 id="根据dockerfile-文件生成image"><a href="#根据dockerfile-文件生成image" class="headerlink" title="根据dockerfile 文件生成image"></a>根据dockerfile 文件生成image</h3><pre><code>Docker build -t tag/镜像名称   dockerfile所在目录
    示例：
    docker build -t test/hello-word .
</code></pre>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><pre><code>docker rm 容器ID       

docker rm $(docker container ls -aq)    删除所有容器

docker rmi image名称   删除镜像
</code></pre>
<h3 id="进入容器内"><a href="#进入容器内" class="headerlink" title="进入容器内"></a>进入容器内</h3><pre><code>docker exec -it 容器名 /bin/bash

示例：docker exec it php71 /bin/bash
</code></pre>
<h3 id="docker-镜像-导出导入【必须成对使用】"><a href="#docker-镜像-导出导入【必须成对使用】" class="headerlink" title="docker 镜像 导出导入【必须成对使用】"></a>docker 镜像 导出导入【必须成对使用】</h3><pre><code>docker export：导出容器
docker import：导入容器为镜像


docker save：导出镜像

    -o:输出到的文件。

    导出示例：
        docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3
        docker save ubuntu:load&gt;/root/ubuntu.tar

docker load：导入镜像
    -i：指定导出的文件
    -q：精简输出信息
    
    导入示例：
        docker load -i ubuntu.tar
        docker load &lt; ubuntu.tar
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>docker学习4-网络</title>
    <url>/posts/32b808f5.html</url>
    <content><![CDATA[<h1 id="原理linux-network-namespace"><a href="#原理linux-network-namespace" class="headerlink" title="原理linux network namespace"></a>原理linux network namespace</h1><h1 id="docker-bridge-网络"><a href="#docker-bridge-网络" class="headerlink" title="docker  bridge 网络"></a>docker  bridge 网络</h1><h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><h2 id="自定义-docker-网络"><a href="#自定义-docker-网络" class="headerlink" title="自定义 docker 网络"></a>自定义 docker 网络</h2><h1 id="docker端口映射"><a href="#docker端口映射" class="headerlink" title="docker端口映射"></a>docker端口映射</h1><h1 id="docker-host-网络"><a href="#docker-host-网络" class="headerlink" title="docker host 网络"></a>docker host 网络</h1>]]></content>
  </entry>
  <entry>
    <title>fail2ban软件使用</title>
    <url>/posts/f44631de.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><pre><code>CentOS 中使用fail2ban和firewalld限制IP拦截cc攻击
</code></pre>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>yum -y install fail2ban
</code></pre>
<h1 id="新建规则"><a href="#新建规则" class="headerlink" title="新建规则"></a>新建规则</h1><pre><code>/etc/fail2ban/filter.d/  编写过滤规则的目录 

vi /etc/fail2ban/filter.d/nginx-cc.conf

[Definition]
#failregex = &lt;HOST&gt;-.*-.*HTTP/1.*(404|301|503).*$
failregex = ^&lt;HOST&gt; -.*&quot;(GET|POST).* HTTP\/.*$
ignoreregex =
</code></pre>
<h1 id="正则规则检查"><a href="#正则规则检查" class="headerlink" title="正则规则检查"></a>正则规则检查</h1><pre><code>fail2ban-regex /var/log/nginx/access.log &quot;&lt;HOST&gt; -.*- .*HTTP/1.* .* .*$&quot;  
</code></pre>
<h1 id="根据配置文件检查"><a href="#根据配置文件检查" class="headerlink" title="根据配置文件检查"></a>根据配置文件检查</h1><pre><code>fail2ban-regex /var/log/nginx/access.log /etc/fail2ban/filter.d/nginx-cc.conf  
</code></pre>
<h1 id="控制规则配置文件"><a href="#控制规则配置文件" class="headerlink" title="控制规则配置文件"></a>控制规则配置文件</h1><pre><code>[DEFAULT]
ignoreip = 127.0.0.1/8  117.89.130.84 117.89.134.183/16  218.2.244.241/16 49.82.132.215/16 122.195.252.237/16 114.238.64.157/16 180.110.114.152/16
#放行的ip 可以带网段
ignorecommand =
bantime  = 60
#屏蔽时间，-1是永久屏蔽
findtime  = 60
#设置限定时间内超过 最大尝试次数 限制次数即被封锁
maxretry = 5
#最大尝试次数
backend = auto
#日志修改后检测机制
usedns = warn
#ssh链接加速
logencoding = auto
enabled = false
[sshd]
## 分类设置（基于 SSHD 服务的防护） 
enabled = true
## 是否开启防护，false 为关闭 
filter = sshd
## 过滤规则 filter 名称，对应 filter.d 目录下的 sshd.conf  action   = iptables[name=SSH, port=22, protocol=tcp] 
#《###action = iptables[name=SSH, port=ssh, protocol=tcp] ## 动作参数
#sendmail-whois[name=SSH, dest=you@example.com, sender=fail2ban@example.com,   sendername=&quot;Fail2Ban&quot;]
## 邮件通知参数
## 收件人地址           ## 发件人地址####》   这是个例子 
logpath = /var/log/secure
## 检测系统登陆日志文件 
maxretry = 3
## 最大尝试次数
banaction=iptables-allports
bantime = 3600
[nginx-cc] 
#过滤规则名称 下方就是 规律规则 相关 限制条件
enabled = true
port=http,https
filter = nginx-cc
findtime = 1
#1秒钟检查一次
maxretry = 100
#最多100个
bantime = 3600
#封锁ip的时间
banaction=iptables-multiport
#匹配的哪些日志文件
logpath = /var/log/nginx/*access.log
          /var/log/nginx/access.log
</code></pre>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><pre><code>#启动
systemctl start fail2ban
#停止
systemctl stop fail2ban

#查看具体规则限制了哪些ip
fail2ban-client status 规则名称
示例：   fail2ban-client status nginx-cc

#解封某条过滤规则封锁的ip
fail2ban-client set nginx-cc unbanip  112.84.237.102
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>docker学习3</title>
    <url>/posts/a707732.html</url>
    <content><![CDATA[<h1 id="docker-compose使用"><a href="#docker-compose使用" class="headerlink" title="docker-compose使用"></a>docker-compose使用</h1><h2 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h2>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/posts/3820734e.html</url>
    <content><![CDATA[<hr>
<p>title: 搭建git服务（适用小团队开发）<br>date: 2022-04-13 22:14:23<br>categories: # 分类</p>
<ul>
<li><p>server<br>tags:</p>
</li>
<li><p>– #标签</p>
</li>
<li><p>git<br>#添加账号<br>  useradd git </p>
<p>  useradd -g git test<br>  passwd test</p>
<p>  cd /home/git/<br>#创建项目<br>  git init –bare 项目名称.git</p>
</li>
</ul>
<p>#配置权限<br>    cd /home/git/项目名称.git</p>
<pre><code>git config core.sharedRepository 0770
</code></pre>
<p>第二种方法 公钥 方法</p>
]]></content>
  </entry>
  <entry>
    <title>fastadmin使用总结</title>
    <url>/posts/ae0c2972.html</url>
    <content><![CDATA[<h1 id="一、常用设置"><a href="#一、常用设置" class="headerlink" title="一、常用设置"></a>一、常用设置</h1><h2 id="1-1-通用搜索栏设置"><a href="#1-1-通用搜索栏设置" class="headerlink" title="1.1 通用搜索栏设置"></a>1.1 通用搜索栏设置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化表格</span><br><span class="line"> table.bootstrapTable(&#123;</span><br><span class="line">     url: $.fn.bootstrapTable.defaults.extend.index_url,</span><br><span class="line">     pk: &#x27;id&#x27;,</span><br><span class="line">     sortName: &#x27;id&#x27;,</span><br><span class="line">     fixedColumns: true,</span><br><span class="line">     fixedRightNumber: 1,</span><br><span class="line">     //切换列表显示样式开关</span><br><span class="line">     showToggle: false,</span><br><span class="line">     //是否显示右上角的搜索框</span><br><span class="line">     search: false,</span><br><span class="line">     //控制显示列开关</span><br><span class="line">     showColumns:false,</span><br><span class="line">     showExport: false,</span><br><span class="line">     //显示搜索字段框</span><br><span class="line">     searchFormVisible: true,</span><br><span class="line">     //导出开关            </span><br><span class="line">     showExport: true,</span><br><span class="line">     //设置导出  格式</span><br><span class="line">     exportTypes: [&#x27;json&#x27;, &#x27;xml&#x27;, &#x27;csv&#x27;, &#x27;txt&#x27;, &#x27;doc&#x27;, &#x27;excel&#x27;],</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="1-2-input-常用设置"><a href="#1-2-input-常用设置" class="headerlink" title="1.2 input 常用设置"></a>1.2 input 常用设置</h2><p>data-rule 设置 检查规则 可以自定义验证方法 checksite JS并相关设置<br>data-source select 可以设置数据源<br>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//input设置</span><br><span class="line"></span><br><span class="line">&lt;input id=&quot;c-site_id&quot; data-rule=&quot;checksite&quot; data-source=&quot;hj212/pollutionsite/index&quot; data-field=&quot;site_name&quot; class=&quot;form-control selectpage&quot; name=&quot;row[site_id]&quot; type=&quot;text&quot; value=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//js中设置</span><br><span class="line"></span><br><span class="line">var Controller = &#123;</span><br><span class="line">        index: function () &#123;</span><br><span class="line">            // 初始化表格参数配置</span><br><span class="line">            Table.api.init(&#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            var table = $(&quot;#table&quot;);</span><br><span class="line"></span><br><span class="line">            // 初始化表格</span><br><span class="line">            table.bootstrapTable(&#123;</span><br><span class="line">                url: $.fn.bootstrapTable.defaults.extend.index_url,</span><br><span class="line">                pk: &#x27;id&#x27;,</span><br><span class="line">                sortName: &#x27;id&#x27;,</span><br><span class="line"></span><br><span class="line">                columns: [</span><br><span class="line">                    [</span><br><span class="line">                        &#123;checkbox: true&#125;,</span><br><span class="line">                        &#123;field: &#x27;id&#x27;, title: __(&#x27;Id&#x27;),operate:false&#125;,</span><br><span class="line">                  </span><br><span class="line">                        &#123;field: &#x27;operate&#x27;, title: __(&#x27;Operate&#x27;), table: table, events: Table.api.events.operate, formatter: Table.api.formatter.operate,</span><br><span class="line">                                 buttons:[</span><br><span class="line">                                     &#123;</span><br><span class="line">                                      &#x27;name&#x27;:&#x27;bindsite&#x27;,</span><br><span class="line">                                      &#x27;title&#x27;:function(row)&#123;</span><br><span class="line">                                          return &#x27;更换站点[ &#x27;+row.device_code+&#x27;]&#x27;;</span><br><span class="line">                                      &#125;,</span><br><span class="line">                                      &#x27;icon&#x27;:&#x27;fa fa-pencil&#x27;,</span><br><span class="line">                                      &#x27;text&#x27;:&#x27;更换站点&#x27;,</span><br><span class="line">                                      &#x27;classname&#x27;: &#x27;btn btn-xs btn-info btn-dialog&#x27;,</span><br><span class="line">                                      &#x27;url&#x27;:&#x27;hj212/device/bindsite/deviceId/&#123;ids&#125;&#x27;,</span><br><span class="line">                                      &#x27;extend&#x27;: &#x27;data-area=\&#x27;[&quot;95%&quot;,&quot;95%&quot;]\&#x27;&#x27;</span><br><span class="line">                                     &#125;,</span><br><span class="line">                                     &#123;</span><br><span class="line">                                      &#x27;name&#x27;:&#x27;siteInfo&#x27;,</span><br><span class="line">                                      &#x27;title&#x27;:function(row)&#123;</span><br><span class="line">                                          return &#x27;站点信息[ &#x27;+row.site+&#x27;]&#x27;;</span><br><span class="line">                                      &#125;,</span><br><span class="line">                                      &#x27;text&#x27;:&#x27;站点信息&#x27;,</span><br><span class="line">                                      &#x27;classname&#x27;: &#x27;btn btn-xs btn-primary btn-dialog&#x27;,</span><br><span class="line">                                      &#x27;url&#x27;:function(row)&#123;</span><br><span class="line">                                          return &#x27;hj212/pollutionsite/siteinfo/site_id/&#x27;+row.site_id;</span><br><span class="line">                                       &#125;,</span><br><span class="line">                                      &#x27;extend&#x27;: &#x27;data-area=\&#x27;[&quot;95%&quot;,&quot;95%&quot;]\&#x27;&#x27;</span><br><span class="line">                                     &#125;,</span><br><span class="line">                                 ]&#125;</span><br><span class="line">                    ]</span><br><span class="line">                ],</span><br><span class="line">                exportTypes: [ &#x27;excel&#x27;],</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            // 为表格绑定事件</span><br><span class="line">            Table.api.bindevent(table);</span><br><span class="line">        &#125;,</span><br><span class="line">        add: function () &#123;</span><br><span class="line">            Controller.api.bindevent();</span><br><span class="line">        &#125;,</span><br><span class="line">        edit: function () &#123;</span><br><span class="line">            Controller.api.bindevent();</span><br><span class="line">        &#125;,</span><br><span class="line">        bindsite:function()&#123;</span><br><span class="line">            Controller.api.bindevent();</span><br><span class="line">        &#125;,</span><br><span class="line">        api: &#123;</span><br><span class="line">            bindevent: function () &#123;</span><br><span class="line">	                $.validator.config(&#123;</span><br><span class="line">                    rules: &#123;</span><br><span class="line">                        checksite: function (element) &#123;</span><br><span class="line">                            return $.ajax(&#123;</span><br><span class="line">                                url: &#x27;hj212/device/checksite&#x27;,</span><br><span class="line">                                type: &#x27;POST&#x27;,</span><br><span class="line">                                data: &#123;</span><br><span class="line">                                    site_id: $(&quot;#c-site_id&quot;).val(),</span><br><span class="line">                                    id:$(&quot;#c-id&quot;).val()</span><br><span class="line">                                &#125;,</span><br><span class="line">                                dataType: &#x27;json&#x27;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                Form.api.bindevent($(&quot;form[role=form]&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="二、数据库操作"><a href="#二、数据库操作" class="headerlink" title="二、数据库操作"></a>二、数据库操作</h1><h1 id="三、redis相关操作"><a href="#三、redis相关操作" class="headerlink" title="三、redis相关操作"></a>三、redis相关操作</h1><h1 id="四、消息队列设置"><a href="#四、消息队列设置" class="headerlink" title="四、消息队列设置"></a>四、消息队列设置</h1><h1 id="五、命令行开发"><a href="#五、命令行开发" class="headerlink" title="五、命令行开发"></a>五、命令行开发</h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/posts/709a4555.html</url>
    <content><![CDATA[<hr>
<p>title: git总结<br>date: 2022-01-08 22:19:16<br>tags:</p>
<hr>
<h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><pre><code>工作区(workspace)      就是你平时存放项目代码的地方
暂存区(stage)          git add
仓库区/版本库(Repository)     git commit
远程仓库
</code></pre>
<h1 id="二、回退问题"><a href="#二、回退问题" class="headerlink" title="二、回退问题"></a>二、回退问题</h1><h2 id="1-git-add-后回退"><a href="#1-git-add-后回退" class="headerlink" title="1.git add 后回退"></a>1.git add 后回退</h2><p>git status 先看一下add 中的文件<br>git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了<br>git reset HEAD XXX/XXX/XXX.java 就是对某个文件进行撤销了</p>
<h2 id="2-git-commit后回退"><a href="#2-git-commit后回退" class="headerlink" title="2.git commit后回退"></a>2.git commit后回退</h2><pre><code>git log    命令显示从最近到最远的提交日志

    [root@localhost test-jenkins]# git log
    commit e2c7f2d567cbdc36e4503479e15ea51d19816d33
    Author: root &lt;root@localhost.localdomain&gt;
    Date:   Fri Jan 7 11:17:27 2022 +0800

    dev branch change

    commit 8943166480734ac5a760e482a887ee8da0140ec8
    Author: root &lt;root@localhost.localdomain&gt;
    Date:   Fri Jan 7 10:56:22 2022 +0800

    dev branch add index.php
    。。。。

git reest --hard  commit_id
                  上一个版本就是HEAD^，
                  上上一个版本就是HEAD^^，
                  当然往上100个版本写100个^比较容易数不过来，
                  所以写成HEAD~100。
例：
    git reset --hard 139dcfaa558e3276b30b6b2e5cbbb9c00bbdca96
    git reset --hard HEAD^

将会删除此版本之前添加

强制push到对应的远程分支（如提交到develop分支）
git push -f -u origin develop
</code></pre>
<h2 id="3-回退后悔药"><a href="#3-回退后悔药" class="headerlink" title="3.回退后悔药"></a>3.回退后悔药</h2><p>git reflog用来记录你的每一次命令</p>
<pre><code>[root@localhost test-jenkins]# git reflog
8943166 HEAD@&#123;0&#125;: reset: moving to 8943166480734ac5a760e482a887ee8da0140ec8
e2c7f2d HEAD@&#123;1&#125;: commit: dev branch change
8943166 HEAD@&#123;2&#125;: commit: dev branch add index.php
1ca6f06 HEAD@&#123;3&#125;: checkout: moving from release to dev
1ca6f06 HEAD@&#123;4&#125;: pull origin release: Fast-forward
14fbb47 HEAD@&#123;5&#125;: checkout: moving from master to release
14fbb47 HEAD@&#123;6&#125;: clone: from ssh://git@117.89.131.220:44222/zhaoyoushui/test-jenkins.git

git reset --hard e2c7f2d
</code></pre>
<h2 id="4-已经提交远程分支"><a href="#4-已经提交远程分支" class="headerlink" title="4.已经提交远程分支"></a>4.已经提交远程分支</h2><p>git reset 方法回退<br>拉过的错误版本的本地分支  多需要回退<br>回退  强制推送  远程</p>
<p>git revert 版本号<br>git revert HEAD 上个版本<br>git revert HEAD~n 上n个版本<br>git push 远程<br>其他客户端正常拉取就可以</p>
<h1 id="三、Git-Reset-三种模式"><a href="#三、Git-Reset-三种模式" class="headerlink" title="三、Git Reset 三种模式"></a>三、Git Reset 三种模式</h1><p>–hard: 会清空工作目录和暂存区的改动</p>
<pre><code>    git reset --hard  c3b320427ad2560140e20af23225d803b2fed6e0
    
</code></pre>
<p><font color="red">–soft：保留工作目录，并把重置 HEAD 所带来的新的差异放进暂存区  <strong>变得只是仓库区</strong></font></p>
<pre><code>    git reset --soft  c3b320427ad2560140e20af23225d803b2fed6e0
    
</code></pre>
<p>–mixed reset 不加参数(mixed)：保留工作目录，并清空暂存区</p>
<pre><code>    git reset c3b320427ad2560140e20af23225d803b2fed6e0
</code></pre>
<h1 id="四、修改远程url"><a href="#四、修改远程url" class="headerlink" title="四、修改远程url"></a>四、修改远程url</h1><pre><code>1.方法一
    git remote set-url origin [url]
    git remote -v 查看

2.方法二
    git remote rm origin
    git remote add origin [url]
    git remote -v 查看

3.方法三
    直接修改config 文件
</code></pre>
<h1 id="五、常用命令"><a href="#五、常用命令" class="headerlink" title="五、常用命令"></a>五、常用命令</h1><p>git branch  :查看本地所有分钟</p>
<pre><code>示例 ：git branch
</code></pre>
<p>git branch -a ：查看所有分支 包括远程</p>
<pre><code>示例：git branch -a 
</code></pre>
<p>git branch 【分支名]：新建分支</p>
<pre><code>示例：git branch  dev
</code></pre>
<p>git branch  -d 【分支名】    删除分支</p>
<pre><code>示例 : git branch  -d  test
</code></pre>
<p>git branch -D 【分支名】     强制删除 分支</p>
<pre><code>示例 : git branch  -D  test
</code></pre>
<p>git merge 【分支名】 ：合并分支，到当前分支</p>
<pre><code>示例：git merge dev
</code></pre>
<p>git checkout 【分支名】：切换到那个分支</p>
<pre><code>示例：git checkout dev
</code></pre>
<p><font color="red">git checkout -b 【分支名】 【远程分支名】：新建一个分支，来自远程分支</font></p>
<pre><code>示例：git checkout -b  dev origin/dev
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>hj212环保协议-2007</title>
    <url>/posts/8e3b07ac.html</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><pre><code>1、基于TCP/IP


2、数据包示例

    ##0069QN=20230812235921004;ST=91;CN=9021;PW=123456;MN=000202;Flag=4;CP=&amp;&amp;&amp;&amp;1540
    
    ##0106QN=20230812233003569;ST=32;CN=3020;PW=123456;MN=000102;Flag=5;CP=&amp;&amp;DataTime=20230812233003;i12001-Info=4&amp;&amp;7D00
    
    ##0580QN=20230914000010688;ST=32;CN=2061;PW=123456;MN=3207xuweixinqu0000000233;Flag=4;CP=&amp;&amp;DataTime=20230913230000;w21001-Min=23.592,w21001-Max=23.592,w21001-Avg=23.592,w21001-Cou=0.000,w21001-Flag=N;w21011-Min=0.476,w21011-Max=0.476,w21011-Avg=0.476,w21011-Cou=0.000,w21011-Flag=N;w01018-Min=181.574,w01018-Max=181.574,w01018-Avg=181.574,w01018-Cou=0.000,w01018-Flag=N;w21003-Min=5.036,w21003-Max=5.036,w21003-Avg=5.036,w21003-Cou=0.000,w21003-Flag=N;w01001-Min=6.856,w01001-Max=6.874,w01001-Avg=6.864,w01001-Flag=N;w01010-Min=23.284,w01010-Max=23.411,w01010-Avg=23.349,w01010-Flag=N&amp;&amp;F6C1

    ##0620QN=20230813000015114;ST=32;CN=2051;PW=123456;MN=000101;Flag=5;CP=&amp;&amp;DataTime=20230812235000;w01018-Cou=0.0,w01018-Min=3547.8,w01018-Avg=3547.8,w01018-Max=3547.8,w01018-Flag=N;w21003-Cou=0.00,w21003-Min=129.63,w21003-Avg=129.63,w21003-Max=129.63,w21003-Flag=N;w21011-Cou=0.00,w21011-Min=0.43,w21011-Avg=0.43,w21011-Max=0.43,w21011-Flag=N;w21001-Cou=0.00,w21001-Min=67.35,w21001-Avg=67.35,w21001-Max=67.35,w21001-Flag=N;w01001-Min=6.65,w01001-Avg=6.65,w01001-Max=6.65,w01001-Flag=N;w01010-Min=26.2,w01010-Avg=26.5,w01010-Max=26.7,w01010-Flag=N;w00000-Cou=0.00,w00000-Min=0.00,w00000-Avg=0.00,w00000-Max=0.00,w00000-Flag=N&amp;&amp;2BC0
</code></pre>
<h1 id="hj212解析"><a href="#hj212解析" class="headerlink" title="hj212解析"></a>hj212解析</h1><pre><code>&lt;?php
namespace app\hj212;

use app\hj212\feature\ParserFeature;
use app\hj212\model\verify\PacketElement;

/**
 * T212通信包解析器
 * Class T212Parser
 * @package App\core
 */
class T212Parser &#123;

    public static $HEADER = &#39;##&#39;;
    //需要双引号(&quot;&quot;)
    public static $FOOTER = &quot;\r\n&quot;;

    protected $reader;
    //位置
    protected $readerIndex = 0;

    private $parserFeature;

    //TEMP
    private $count;
//    private PacketElement token;

    function __construct($reader = &#39;&#39;)&#123;
        $this-&gt;reader = $reader;

    &#125;

    public function setReader($reader) &#123;
        $this-&gt;reader = $reader;
        $this-&gt;readerIndex = 0;
    &#125;

    /**
     * 设置解析特性
     * @param parserFeature 解析特性
     */
    function setParserFeature(int $parserFeature) &#123;
        $this-&gt;parserFeature = $parserFeature;
    &#125;

    /**
     * 读取 包头
     * @return mixed
     * @throws IOException
     */
    public function readHeader() &#123;

//        $header = new char[2];
//        $count = $reader.read($header);

        $header = substr($this-&gt;reader,$this-&gt;readerIndex,PacketElement::HEADER);
        $this-&gt;readerIndex = $this-&gt;readerIndex + PacketElement::HEADER;
        $count = strlen($header);
        VerifyUtil::verifyEqualLen($count, PacketElement::HEADER, PacketElement::getElementVar());
        VerifyUtil::verifyChar($header, self::$HEADER, PacketElement::getElementVar());

        return $header;
    &#125;

    /**
     * 读取 数据段长度
     * @see PacketElement#DATA_LEN
     * @return chars
     * @throws T212FormatException
     * @throws IOException
     */
    function readDataLen()&#123;
        $len = substr($this-&gt;reader,$this-&gt;readerIndex,PacketElement::DATA_LEN);
        $this-&gt;readerIndex = $this-&gt;readerIndex + PacketElement::DATA_LEN;
        $count = strlen($len);
        VerifyUtil::verifyEqualLen($count,PacketElement::DATA_LEN, PacketElement::getElementVar());
        return $len;
    &#125;

    /**
     * 读取 数据段
     * @see PacketElement#DATA
     * @return chars
     * @throws IOException
     */
    public function readData(int $segmentLen) &#123;
        $segment = substr($this-&gt;reader,$this-&gt;readerIndex, $segmentLen);
        $this-&gt;readerIndex = $this-&gt;readerIndex + $segmentLen;
        $count = strlen($segment);
        VerifyUtil::verifyEqualLen($count,$segmentLen, PacketElement::getElementVar());
        return $segment;
    &#125;

    /**
     * 读取 DATA_CRC 校验
     * @see PacketElement#DATA_CRC
     * @return header chars
     * @throws IOException
     */
    function readCrc() &#123;
        $crc = substr($this-&gt;reader,$this-&gt;readerIndex, PacketElement::DATA_CRC);
        $this-&gt;readerIndex = $this-&gt;readerIndex + PacketElement::DATA_CRC;
        $count = strlen($crc);
        VerifyUtil::verifyEqualLen($count,PacketElement::DATA_CRC, PacketElement::getElementVar());
        return $crc;
    &#125;

    /**
     * 读取 包尾
     * @see PacketElement
     * @return chars
     * @throws IOException
     */
    function readFooter() &#123;
        $footer = substr($this-&gt;reader,$this-&gt;readerIndex,PacketElement::FOOTER);
        $this-&gt;readerIndex = $this-&gt;readerIndex + PacketElement::FOOTER;
        $count = strlen($footer);

        VerifyUtil::verifyEqualLen($count, PacketElement::FOOTER, PacketElement::getElementVar());
        VerifyUtil::verifyChar($footer, self::$FOOTER, PacketElement::getElementVar());

        return $footer;
    &#125;

    /**
     * 读取 4字节Integer
     * @param radix 进制
     * @return Integer
     * @throws IOException
     */
    public function readCrcInt16() &#123;
        $crc = substr($this-&gt;reader,$this-&gt;readerIndex, PacketElement::DATA_CRC);
//        $this-&gt;readerIndex = $this-&gt;readerIndex + PacketElement::DATA_CRC;
        $count = strlen($crc);

        if($count != 4)&#123;
            return -1;
        &#125;
        //本身为十六进制字符串
        return $crc;
    &#125;

    /**
     * 读取 data + 校验
     * @see PacketElement
     * @return chars
\     * @throws IOException
     */
    function readDataAndCrc(int $dataLen) &#123;
        $data = substr($this-&gt;reader,$this-&gt;readerIndex, $dataLen);
        $this-&gt;readerIndex = $this-&gt;readerIndex + $dataLen;
        $count = strlen($data);
        VerifyUtil::verifyEqualLen($count,$dataLen, PacketElement::getElementVar());

        $crc = $this-&gt;readCrcInt16();
        $check_crc = self::crc16Checkout($data,$dataLen);

        if($crc != -1 &amp;&amp; $check_crc == $crc)&#123;
            return $data;
        &#125;
        return null;
    &#125;

    /**
     * CRC校验
     * @param msg 消息
     * @param length 长度
     * @return DATA_CRC 校验码
     */
    public static function crc16Checkout($msg, int $length) &#123;
        $crc_reg = 0xFFFF;
        for($i=0; $i&lt;$length; $i++) &#123;
            $crc_reg = ($crc_reg&gt;&gt;8) ^ ord($msg[$i]);
//            echo $crc_reg . &quot;\r\n&quot;;
            for($j=0;$j&lt;8;$j++) &#123;
                $check = $crc_reg &amp; 0x0001;
                $crc_reg &gt;&gt;= 1;
                if ($check == 0x0001) &#123;
                    $crc_reg ^= 0xA001;
                &#125;
            &#125;
        &#125;
        $res = strtoupper(dechex($crc_reg));
        $res = str_pad($res, 4, &quot;0&quot;, STR_PAD_LEFT);
        return $res;
    &#125;



&#125;
</code></pre>
<h1 id="Swoole接收处理"><a href="#Swoole接收处理" class="headerlink" title="Swoole接收处理"></a>Swoole接收处理</h1><pre><code>&lt;?php
/**
 * Created by PhpStorm
 * USER: Zhaoys
 * Date: 2022/2/8 19:09
 */

namespace app\hj212\command;

use app\hj212\model\Data;
use app\hj212\model\Pollution;
use app\hj212\segment\converter\DataConverter;
use app\hj212\VerifyUtil;
use Swoole\Server as SwooleServer;
use app\hj212\T212Parser;
use think\console\Command;
use think\console\Input;
use think\console\Output;
use think\Exception;
use think\Db;

class Hj212Server extends Command
&#123;
    // Server 实例
    protected $server;

    protected $t212Parser;

    protected $buffer;

    protected function configure()
    &#123;
        $this-&gt;setName(&#39;hj212:start&#39;)-&gt;setDescription(&#39;Start hj212 Server!&#39;);
    &#125;

    protected function execute(Input $input, Output $output)
    &#123;
//        // 监听所有地址，监听端口f
        $this-&gt;server = new SwooleServer(&#39;0.0.0.0&#39;, 65212);

        $this-&gt;server-&gt;set(array(
            &#39;worker_num&#39; =&gt; 10,
//            &#39;task_worker_num&#39; =&gt; 2,   //必须设置 on task
            &#39;max_request&#39; =&gt; 10000,
//            &#39;open_length_check&#39; =&gt; true,
//            &#39;package_length_func&#39; =&gt; &#39;&#39;,
            &#39;daemonize&#39; =&gt; true,
            &#39;log_file&#39; =&gt; &quot;runtime/log/swoole.log&quot;,
            &#39;dispatch_mode&#39; =&gt; 2,
        ));
        $this-&gt;t212Parser = new T212Parser();
        $this-&gt;server-&gt;on(&#39;start&#39;, array($this, &#39;onStart&#39;));

        $this-&gt;server-&gt;on(&#39;connect&#39;, array($this, &#39;onConnect&#39;));
        $this-&gt;server-&gt;on(&#39;receive&#39;, array($this, &#39;onReceive&#39;));

        $this-&gt;server-&gt;on(&#39;close&#39;, array($this, &#39;onClose&#39;));
        $this-&gt;server-&gt;start();

    &#125;


    public function onStart($serv)
    &#123;
        echo &quot;TCP Server is started at tcp://\n&quot;;
    &#125;


    public function onConnect($serv, $fd)
    &#123;
        echo &quot;connection open: &#123;$fd&#125;\n&quot;;
        file_put_contents(&#39;runtime/log/hj212connect_&#39; . date(&quot;Ymd&quot;) . &#39;.log&#39;, date(&#39;Y-m-d H:i:s&#39;) .&quot;ip&quot;.$this-&gt;getIP().&quot;open: &#123;$fd&#125;&quot;);
    &#125;

    public function onReceive($serv, $fd, $reactor_id, $data)
    &#123;
        file_put_contents(&#39;runtime/log/hj212receive_&#39; . date(&quot;Ymd&quot;) . &#39;.log&#39;, date(&#39;Y-m-d H:i:s&#39;) . &quot;receive:  &quot; . $data . PHP_EOL, FILE_APPEND);

        $tempdata = rtrim($data, &quot;\r\n&quot;);
        $strlen = strlen($tempdata);
        $endstr = substr($tempdata, $strlen - 6, 2);
        $strartstr = substr($data, 0, 2);
        if ($strartstr == &quot;##&quot; &amp;&amp; $endstr != &quot;&amp;&amp;&quot;) &#123;
            $this-&gt;buffer = $data;
            return;
        &#125; else if ($strartstr != &quot;##&quot; &amp;&amp; $endstr == &quot;&amp;&amp;&quot; &amp;&amp; $this-&gt;buffer &amp;&amp; VerifyUtil::verifyCrc($this-&gt;buffer . $tempdata)) &#123;
            $data = rtrim($this-&gt;buffer, &quot;\r\n&quot;) . $data;
        &#125; else if ($strartstr != &quot;##&quot; &amp;&amp; $endstr == &quot;&amp;&amp;&quot; &amp;&amp; $this-&gt;buffer &amp;&amp; !VerifyUtil::verifyCrc($this-&gt;buffer . $tempdata)) &#123;
            $this-&gt;buffer = rtrim($this-&gt;buffer, &quot;\r\n&quot;) . $tempdata;
            return;
        //##1715QN=20230727145559023;ST=32;CN=3020;PW=123456;MN=000102;Flag=5;CP=&amp;&amp;Data
        &#125;else if($strartstr == &quot;##&quot; &amp;&amp; $endstr == &quot;&amp;&amp;&quot; &amp;&amp; !VerifyUtil::verifyCrc($this-&gt;buffer . $tempdata))&#123;
            $this-&gt;buffer = $data;
            return;
        &#125;
        $sourceData = $data;
        $this-&gt;t212Parser-&gt;setReader($data);
        $this-&gt;t212Parser-&gt;readHeader();
        $dataLen = $this-&gt;t212Parser-&gt;readDataLen();
        $data = $this-&gt;t212Parser-&gt;readDataAndCrc($dataLen);
        $dataConverter = new DataConverter($data);
        $insetdata = $dataConverter-&gt;convertData();
        $insetdata[&#39;data_len&#39;] = $dataLen;
        $insetdata[&#39;crc&#39;] = $this-&gt;t212Parser-&gt;readCrcInt16();
        $insetdata[&#39;source_data&#39;] = $sourceData;
        $cpData = $dataConverter-&gt;convertCpData();
        //存在数据空的情况 ##0069QN=20230723080035006;ST=91;CN=9021;PW=123456;MN=000201;Flag=4;CP=&amp;&amp;&amp;&amp;BDC1
        $insetdata[&#39;cp_datatime&#39;] = isset($cpData[&#39;cpData&#39;][&#39;datatime&#39;]) ? $cpData[&#39;cpData&#39;][&#39;datatime&#39;] : 0;
        Db::startTrans();
        try &#123;
            $dataModel = new Data($insetdata);
            $dataModel-&gt;save();
            //            $pollutionModel = new Pollution();
            //            foreach ($cpData[&#39;pollution&#39;] as $k =&gt; $val) &#123;
            //                $pModel = clone $pollutionModel;
            //                $val[&#39;data_id&#39;] = $dataModel-&gt;id;
            //                $val[&#39;code&#39;] = $k;
            //                $pModel-&gt;data($val);
            //                $pModel-&gt;save();
            //            &#125;
            Db::commit();
        &#125; catch (Exception $e) &#123;
            Db::rollback();
        &#125;
        $str = &quot;QN=&#123;$insetdata[&#39;qn&#39;]&#125;;ST=91;CN=9014;PW=&#123;$insetdata[&#39;pw&#39;]&#125;;MN=&#123;$insetdata[&#39;mn&#39;]&#125;;Flag=4;CP=&amp;&amp;&amp;&amp;\r\n&quot;;
        $num = strlen($str);
        $newNum = str_pad($num, 4, &quot;0&quot;, STR_PAD_LEFT);
        $resStr = &quot;##&quot; . $newNum . $str;
        $this-&gt;buffer = &quot;&quot;;
        $this-&gt;server-&gt;send($fd, $resStr);

    &#125;

    public function onClose($serv, $fd)
    &#123;
        echo &quot;connection close: &#123;$fd&#125;\n&quot;;
    &#125;

    /**
     * 同步任务
     * $this-&gt;serv-&gt;taskwait($data); 触发
     * @param $server
     * @param $task_id
     * @param $data
     */
    function onSyncTask($serv, $task_id, $from_id, $data)
    &#123;
        echo &quot;Sync task Callback: &quot; . $data;

        $this-&gt;t212Parser-&gt;setReader($data);
        $header = $this-&gt;t212Parser-&gt;readHeader();
        $dataLen = $this-&gt;t212Parser-&gt;readDataLen();
        $data = $this-&gt;t212Parser-&gt;readDataAndCrc($dataLen);
        echo $data;

        $result = $data;
        // 通知完成
        $this-&gt;server-&gt;finish($result);
    &#125;

    /**
     * 异步任务
     * $this-&gt;serv-&gt;task($data); 触发
     * @param $server
     * @param $task_id
     * @param $data
     */
    function onAsynTask($serv, $task_id, $from_id, $data)
    &#123;
        echo &quot;Asyn task Callback: &quot;;
        // 通知完成
        $this-&gt;server-&gt;finish($data . &quot;cccccsssss&quot;);

    &#125;

    public function onFinish($serv, $task_id, $data)
    &#123;
        echo &quot;任务完成&quot;;//taskwait  不触发这个函数。。
    &#125;

    public function getIP()
    &#123;
        if (isset($_SERVER))&#123;
            if (isset($_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;]))&#123;
                $realip = $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;];
            &#125; else if (isset($_SERVER[&quot;HTTP_CLIENT_IP&quot;])) &#123;
                $realip = $_SERVER[&quot;HTTP_CLIENT_IP&quot;];
            &#125; else &#123;
                $realip = isset($_SERVER[&quot;REMOTE_ADDR&quot;]) ? $_SERVER[&quot;REMOTE_ADDR&quot;] : &#39;127.0.0.1&#39;;
            &#125;
        &#125; else &#123;
            if (getenv(&quot;HTTP_X_FORWARDED_FOR&quot;))&#123;
                $realip = getenv(&quot;HTTP_X_FORWARDED_FOR&quot;);
            &#125; else if (getenv(&quot;HTTP_CLIENT_IP&quot;)) &#123;
                $realip = getenv(&quot;HTTP_CLIENT_IP&quot;);
            &#125; else &#123;
                $realip = getenv(&quot;REMOTE_ADDR&quot;);
            &#125;
        &#125;
        return $realip;
    &#125;

&#125;
</code></pre>
]]></content>
      <tags>
        <tag>php开发</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习1</title>
    <url>/posts/1f1744f1.html</url>
    <content><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><p>1.JavaEE 全称 Java Platform, Enterprise Edition，</p>
<pre><code>它是对 JavaSE(Java Platform, Standard Edition) 的扩展
加入了面向企业开发（实际上就是网络和 Web 有关开发）的支持，包括 Servlet，WebSocket，EL，EJB 等
</code></pre>
<p>2.Servlet 和 Servlet Container</p>
<pre><code>Servlet

Servlet 是一套用于处理 HTTP 请求的 API 标准
JavaEE 当中只提供了 Servlet 的标准，
要真正运行 Servlet，需要使用 Servlet Container

Servlet Container

如果 Servlet 是电器，Servlet Container 就是电源插座
这层抽象让 Servlet 可以跑在任何一个 Container 当中，隔绝了对 Runtime 环境的依赖
比较常用支持 Servlet Container 的 Server 软件有 Apache Tomcat，Glassfish，JBoss，Jetty 等等。


Servlet 是 Java Web 开发的事实标准，不过也不代表所有 Java Web 框架都一定要使用或者兼容 Servlet。
不使用 Servlet 也可以进行 Java Web 开发，例如 Play Framework，就是完全自立门户的一个框架。
</code></pre>
<p>3.EJB 和 EJB Container</p>
<pre><code>EJB 全称 Enterprise JavaBean，和 Servlet 一样，也是 JavaEE 当中的一个组件，面向更加复杂的企业业务开发
有一个概念需要明确，和 Servlet 类似，运行 EJB 也需要专门的 EJB Container
Apache Tomcat 不支持 EJB，而 JBoss 提供了对 EJB 的支持。
</code></pre>
<p>4.JVM：java虚拟机，加载.class文件字节码文件并运行.class字节码文件    </p>
<h1 id="二、在系统跑Java程序必要软件"><a href="#二、在系统跑Java程序必要软件" class="headerlink" title="二、在系统跑Java程序必要软件"></a>二、在系统跑Java程序必要软件</h1><p>Java Development Kit (JDK) 是Java开发工具包,用于开发和编译和调试Java程序</p>
<pre><code>编译器（javac）：将Java源代码编译成字节码文件（.class文件），以便能够在Java虚拟机（JVM）上执行
JDK提供了一些调试工具，用于帮助开发人员在开发和测试Java程序时进行调试。
JDK用于开发和编译和调试Java程序
</code></pre>
<p>Java Runtime Environment (JRE)：JRE包含了运行Java程序所需的运行时环境。 用于运行Java程序</p>
<pre><code>JRE：java 程序运行时环境，包括JVM虚拟机（java.exe等）和基本的类库（rt.jar等）。
只包含Java虚拟机（JVM）和Java标准类库，用于执行Java程序
JRE则用于运行Java程序。
</code></pre>
<h1 id="三、JavaEE-Servlet-应用"><a href="#三、JavaEE-Servlet-应用" class="headerlink" title="三、JavaEE Servlet 应用"></a>三、JavaEE Servlet 应用</h1><pre><code> package，然后在 package 上右键，创建一个 Java Class
 
 Servlet API 是包含在 JavaEE 当中的。为了方便，我们直接使用 Tomcat 附带的 servlet-api.jar 包。
 
 
</code></pre>
<h2 id="3-1-Servlet接口"><a href="#3-1-Servlet接口" class="headerlink" title="3.1 Servlet接口"></a>3.1 Servlet接口</h2><pre><code>import javax.servlet.*;
public class MyFirstServlet implements Servlet&#123;

    public void init(ServletConfig config) throws ServletException &#123;
        System.out.println(&quot;Init&quot;);
    &#125;
    
    public void service(ServletRequest request, ServletResponse response)
            throws ServletException, IOException &#123;
        System.out.println(&quot;From service&quot;);
        PrintWriter out = response.getWriter();
        out.println(&quot;Hello, Java Web.&quot;);
    &#125;
    
    public void destroy() &#123;
        System.out.println(&quot;Destroy&quot;);
    &#125;
    public String getServletInfo() &#123;
        return null;
    &#125;
    
    public ServletConfig getServletConfig() &#123;
        return null;
    &#125;


&#125;
</code></pre>
<h2 id="3-2-GenericServlet抽象类"><a href="#3-2-GenericServlet抽象类" class="headerlink" title="3.2 GenericServlet抽象类"></a>3.2 GenericServlet抽象类</h2><p>GenericServlet使编写Servlet变得更容易。<br>它提生命周期方法init和destroy的简单实现，要编写一般的Servlet，只需要重写service方法即可。</p>
<pre><code>import javax.servlet.GenericServlet;
public class classname extends GenericServlet&#123;
&#125;     
</code></pre>
<h2 id="3-2-HttpServlet类"><a href="#3-2-HttpServlet类" class="headerlink" title="3.2 HttpServlet类"></a>3.2 HttpServlet类</h2><p>HttpServlet是在继承GenericServlet的基础上进一步的扩展。<br>提供将要被子类化以创建适用于Web站点的HTTP servlet的抽象类<br>要重写doGet和doPost方法</p>
<p>HTTPServlet的子类至少必须重写一个方法，该方法通常是：</p>
<p>doGet()：用于HTTP GET请求</p>
<p>doPost()：用于HTTP POST请求</p>
<p>doPut()：用于HTTP PUT请求</p>
<p>doDelete()：用于HTTP DELETE请求</p>
<pre><code>import javax.servlet.http.HttpServlet; 
public class classname extends HttpServlet&#123;

&#125;   
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>JS模块化</title>
    <url>/posts/b2e052be.html</url>
    <content><![CDATA[<h2 id="CommonJs规范简"><a href="#CommonJs规范简" class="headerlink" title="CommonJs规范简"></a>CommonJs规范简</h2><pre><code>前端模块化

最初是服务于服务端的 但它的载体是前端语言 JavaScript
commonjs 随着 nodejs 的诞生而面世，主要是用来解决服务端模块化的问题
Node.js 应用由模块组成，每个文件就是一个模块，有自己的作用域。
在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见

 CommonJS 规范的模块时，无外乎就是使用了 require 、 exports 、 module 三个东西，
 然后一个 js 文件就是一个模块
 
 弊端require 多个文件  网络加载问题
</code></pre>
<h3 id="require"><a href="#require" class="headerlink" title="require"></a>require</h3><pre><code>用来加载某个模块
</code></pre>
<h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><pre><code>module 代表当前模块，是一个对象，保存了当前模块的信息
exports 是 module 上的一个属性，保存了当前模块要导出的接口或者变量，
使用 require 加载的某个模块获取到的值就是那个模块使用 exports 导出的值
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// a.js</span><br><span class="line">var name = &#x27;morrain&#x27;</span><br><span class="line">var age = 18</span><br><span class="line">module.exports.name = name</span><br><span class="line">module.exports.getAge = function()&#123;</span><br><span class="line">    return age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//b.js</span><br><span class="line">var a = require(&#x27;a.js&#x27;)</span><br><span class="line">console.log(a.name) // &#x27;morrain&#x27;</span><br><span class="line">console.log(a.getAge())// 18</span><br></pre></td></tr></table></figure>

<h3 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h3><pre><code>为了方便，Node.js 在实现 CommonJS 规范时，为每个模块提供一个 exports的私有变量
为每个模块提供一个 exports的私有变量，指向 module.exports
你可以理解为 Node.js 在每个模块开始的地方，添加了如下这行代码。

exports 是模块内的私有局部变量，它只是指向了 module.exports
所以直接对 exports 赋值是无效的
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//a.js</span><br><span class="line">var name = &#x27;test&#x27;</span><br><span class="line">var age = 18</span><br><span class="line">exports.name = name</span><br><span class="line">exports.getAge = function()&#123;</span><br><span class="line">    return age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//b.js</span><br><span class="line"></span><br><span class="line">a = require(&#x27;a.js&#x27;)</span><br><span class="line">console.log(a.name)</span><br><span class="line">a.name</span><br></pre></td></tr></table></figure>
<h2 id="AMD-Asynchronous-Module-Definition-异步模块定义-require-js"><a href="#AMD-Asynchronous-Module-Definition-异步模块定义-require-js" class="headerlink" title="AMD(Asynchronous Module Definition 异步模块定义)   require.js"></a>AMD(Asynchronous Module Definition 异步模块定义)   require.js</h2><pre><code>　　（1）实现js文件的异步加载，避免网页失去响应；

　　（2）管理模块之间的依赖性，便于代码的编写和维护。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define(id?, dependencies?, factory)</span><br><span class="line"></span><br><span class="line">id：可选参数，用来定义模块的标识，如果没有提供该参数，就使用 js 文件名（去掉拓展名）对于一个 js 文件只定义了一个模块时，这个参数是可以省略的</span><br><span class="line"></span><br><span class="line">dependencies：可选参数，是一个数组，表示当前模块的依赖，如果没有依赖可以不传</span><br><span class="line"></span><br><span class="line">factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次，返回值便是模块要导出的值。</span><br><span class="line">如果是对象，此对象应该为模块的输出值</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// a.js</span><br><span class="line">define(function()&#123;</span><br><span class="line">    var name = &#x27;morrain&#x27;</span><br><span class="line">    var age = 18</span><br><span class="line">    return &#123;</span><br><span class="line">        name,</span><br><span class="line">        getAge: () =&gt; age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// b.js</span><br><span class="line">define([&#x27;a.js&#x27;], function(a)&#123;</span><br><span class="line">    var name = &#x27;lilei&#x27;</span><br><span class="line">    var age = 15</span><br><span class="line">    console.log(a.name) // &#x27;morrain&#x27;</span><br><span class="line">    console.log(a.getAge()) // 18</span><br><span class="line">    return &#123;</span><br><span class="line">        name,</span><br><span class="line">        getAge: () =&gt; age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="CMD-Common-Module-Definition-Sea-js"><a href="#CMD-Common-Module-Definition-Sea-js" class="headerlink" title="CMD (Common Module Definition)  Sea.js"></a>CMD (Common Module Definition)  Sea.js</h2><pre><code> Sea.js
 
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;sea.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">// a.js</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">    var name = &#x27;morrain&#x27;</span><br><span class="line">    var age = 18</span><br><span class="line"></span><br><span class="line">    exports.name = name</span><br><span class="line">    exports.getAge = () =&gt; age</span><br><span class="line">&#125;)</span><br><span class="line">// b.js</span><br><span class="line">define(function(require, exports, module)&#123;</span><br><span class="line">    var name = &#x27;lilei&#x27;</span><br><span class="line">    var age = 15</span><br><span class="line">    var a = require(&#x27;a.js&#x27;)</span><br><span class="line"></span><br><span class="line">    console.log(a.name) // &#x27;morrain&#x27;</span><br><span class="line">    console.log(a.getAge()) //18</span><br><span class="line"></span><br><span class="line">    exports.name = name</span><br><span class="line">    exports.getAge = () =&gt; age</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="ES6-Moudule"><a href="#ES6-Moudule" class="headerlink" title="ES6 Moudule"></a>ES6 Moudule</h2>]]></content>
  </entry>
  <entry>
    <title>laravel学习1</title>
    <url>/posts/f00cf8de.html</url>
    <content><![CDATA[<h1 id="public-index-php文件解析"><a href="#public-index-php文件解析" class="headerlink" title="public/index.php文件解析"></a>public/index.php文件解析</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 引入自动加载文件</span><br><span class="line">require __DIR__.&#x27;/../bootstrap/autoload.php&#x27;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Turn On The Lights</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| We need to illuminate PHP development, so let us turn on the lights.</span><br><span class="line">| This bootstraps the framework and gets it ready for use, then it</span><br><span class="line">| will load up this application so that we can run it and send</span><br><span class="line">| the responses back to the browser and delight our users.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$app = require_once __DIR__.&#x27;/../bootstrap/app.php&#x27;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Run The Application</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| Once we have the application, we can handle the incoming request</span><br><span class="line">| through the kernel, and send the associated response back to</span><br><span class="line">| the client&#x27;s browser allowing them to enjoy the creative</span><br><span class="line">| and wonderful application we have prepared for them.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);</span><br><span class="line"></span><br><span class="line">$response = $kernel-&gt;handle(</span><br><span class="line">    $request = Illuminate\Http\Request::capture()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">$response-&gt;send();</span><br><span class="line"></span><br><span class="line">$kernel-&gt;terminate($request, $response);</span><br></pre></td></tr></table></figure>


<h1 id="bootstrap-autoload-php文件解析"><a href="#bootstrap-autoload-php文件解析" class="headerlink" title="/bootstrap/autoload.php文件解析"></a>/bootstrap/autoload.php文件解析</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">#定义记录时间的常量</span><br><span class="line">define(&#x27;LARAVEL_START&#x27;, microtime(true));</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Register The Composer Auto Loader</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| Composer provides a convenient, automatically generated class loader</span><br><span class="line">| for our application. We just need to utilize it! We&#x27;ll require it</span><br><span class="line">| into the script here so that we do not have to worry about the</span><br><span class="line">| loading of any our classes &quot;manually&quot;. Feels great to relax.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line">#引入外部库   自动加载文件</span><br><span class="line">require __DIR__.&#x27;/../vendor/autoload.php&#x27;;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">| Include The Compiled Class File</span><br><span class="line">|--------------------------------------------------------------------------</span><br><span class="line">|</span><br><span class="line">| To dramatically increase your application&#x27;s performance, you may use a</span><br><span class="line">| compiled class file which contains all of the classes commonly used</span><br><span class="line">| by a request. The Artisan &quot;optimize&quot; is used to create this file.</span><br><span class="line">|</span><br><span class="line">*/</span><br><span class="line">#引入laravel缓存文件</span><br><span class="line">$compiledPath = __DIR__.&#x27;/cache/compiled.php&#x27;;</span><br><span class="line"></span><br><span class="line">if (file_exists($compiledPath)) &#123;</span><br><span class="line">    require $compiledPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>PHP开发</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins-发布php项目</title>
    <url>/posts/49b184d4.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>linux-iptables使用总结</title>
    <url>/posts/24ccf49a.html</url>
    <content><![CDATA[<p>一、iptables<br>    iptables防火墙没有启用,iptables命令仍然会显示默认的规则.</p>
<p>二、常用命令</p>
<p>常用参数</p>
<pre><code>-n 参数表示将 IP 地址和端口号显示为数字形式，而不是解析为主机名和服务名。

-L 选项用于列出防火墙规则。

-t nat 参数指定了要操作的表为 NAT 表，NAT 表用于处理网络地址转换相关的规则。
</code></pre>
<p>iptables -n -L           显示当前防火墙规则列表。</p>
<p>iptables -t nat -n -L    看 iptables 中 NAT（Network Address Translation）表的规则。</p>
<p>结果怎么看</p>
<pre><code>Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0            state NEW udp dpt:2333
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:2333

Chain FORWARD (policy DROP)
target     prot opt source               destination         
DOCKER-USER  all  --  0.0.0.0/0            0.0.0.0/0           
DOCKER-ISOLATION-STAGE-1  all  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHED
DOCKER     all  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         

Chain DOCKER (1 references)
target     prot opt source               destination         
ACCEPT     udp  --  0.0.0.0/0            172.17.0.2           udp dpt:60050
ACCEPT     udp  --  0.0.0.0/0            172.17.0.2           udp dpt:60049
ACCEPT     udp  --  0.0.0.0/0            172.17.0.2           udp dpt:60048
ACCEPT     udp  --  0.0.0.0/0            172.17.0.2           udp dpt:60047

Chain DOCKER-ISOLATION-STAGE-1 (1 references)
target     prot opt source               destination         
DOCKER-ISOLATION-STAGE-2  all  --  0.0.0.0/0            0.0.0.0/0           
RETURN     all  --  0.0.0.0/0            0.0.0.0/0           

Chain DOCKER-ISOLATION-STAGE-2 (1 references)
target     prot opt source               destination         
DROP       all  --  0.0.0.0/0            0.0.0.0/0           
RETURN     all  --  0.0.0.0/0            0.0.0.0/0           

Chain DOCKER-USER (1 references)
target     prot opt source               destination         
RETURN     all  --  0.0.0.0/0            0.0.0.0/0 
 
&quot;LIBVIRT_FWI&quot;是一个iptables防火墙的链，并且该链已经被引用了一次

允许所有协议（all）的流量从任意源IP地址（0.0.0.0/0）进入到目标IP地址为172.17.0.2  60047端口


REJECT 拒绝

ACCEPT 允许

DROP   丢弃
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>laravel源码学习2</title>
    <url>/posts/35967ec2.html</url>
    <content><![CDATA[<p>#laravel 核心文件applications</p>
]]></content>
      <tags>
        <tag>PHP开发</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的常用应用</title>
    <url>/posts/c8d81a10.html</url>
    <content><![CDATA[<p>#mysql忘记密码,重置密码</p>
<p>1.修改my.cnf</p>
<p>添加</p>
<pre><code>--skip-grant-tables
</code></pre>
<p>2.进入数据</p>
<pre><code>执行
use mysql;
mysql&gt; update user set password=password(&#39;123&#39;) where user=&#39;root&#39; and host=&#39;localhost&#39;;
mysql&gt; flush privileges;
</code></pre>
<p>#mysql导出、导入数据命令</p>
<p>导出<br>mysqldump -u &lt;用户名&gt; -p&lt;密码&gt; &lt;数据库名&gt; &gt; &lt;输出文件路径&gt;</p>
<p>示例</p>
<pre><code> mysqldump  -u root -p wastewater.iguanwei.com &gt;bak.sql
</code></pre>
<p>导入</p>
<pre><code>方法一：
mysql -u用户名 -p 数据库名 &lt; 123.sql
方法二：
source 123.sql;
</code></pre>
<h1 id="mysql修改root权限-修改密码-远程访问"><a href="#mysql修改root权限-修改密码-远程访问" class="headerlink" title="mysql修改root权限/修改密码/远程访问"></a>mysql修改root权限/修改密码/远程访问</h1><pre><code>GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;IDENTIFIED BY &#39;Storage@202312&#39; WITH GRANT OPTION;
</code></pre>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
  </entry>
  <entry>
    <title>linux硬盘以及分区</title>
    <url>/posts/2acbc304.html</url>
    <content><![CDATA[<h1 id="一、-硬盘分区基础知识"><a href="#一、-硬盘分区基础知识" class="headerlink" title="一、 硬盘分区基础知识"></a>一、 硬盘分区基础知识</h1><pre><code>磁盘分区类型：硬盘分区最常见的类型为msdos和gpt，
前者表示MBR分区，而后者表示GPT分区。传统的BIOS只支持MBR分区硬盘启动，
一个硬盘只能分成四个分区，并且单个分区最大不超过2TB。
GPT(即GUID分区表)是源自EFI标准的一种较新的磁盘分区表结构的标准，是未来磁盘分区的主要形式。
与MBR分区方式相比，突破MBR4个主分区限制，每个磁盘最多支持128个分区，持大于2T的分区，最大卷可达18EB。
1、MBR分区：
MBR的意思是“主引导记录”，它有自己的启动器，也就是启动代码，
一旦启动代码被破坏，系统就没法启动，只有通过修复才能启动系统。最大支持2TB容量（T; terabytes,1TB=1024GB），
对分区的设限：最多4个主分区或3个主分区加一个扩展分区。创建工具典型有fdisk。

2、GPT分区：GPT意为GUID分区表，这是一个正逐渐取代MBR的新标准，它由UEFI辅住而形成的，
这样就有了UEFI用于取代老旧的BIOS，而GPT则取代老旧的MBR。这个标准没有MBR的那些限制比如：容量2T限制、分区个数限制等。磁盘驱动器容量可以大得多，
大到操作系统和文件系统都没法支持。它同时还支持几乎无限个分区数量，限制只在于操作系统，Windows支持最多128个GPT分区。GPT和MBR是不同的分区表类型。
使用MBR分区表的硬盘最多只能划分4个主分区磁盘，并且MBR最大仅支持2TB的硬盘。如果需要分区的硬盘容量超过2TB了，则需要使用GPT分区表类型，
此分区表类型不受分区个数、硬盘大小的限制。创建GPT分区典型工具有parted,gdisk,sgdisk等,fdisk不支持创建GPT分区。
我们管理的服务器可能会随着业务量的不断增长而造成磁盘数据空间不足的情况（不考虑inode），这个时候我们就可能需要增加磁盘或挂载一些其他的块设备，
这里我主要介绍如何使用fdisk分区工具创建磁盘分区和挂载分区。最重要的三步就是：
1、创建主分区。（主分区创建之后可以马上被使用但不能再分区）
2、创建扩展分区 (扩展分区必须再进行二次分区后才能被使用)
3、在扩展分区上创建逻辑分区（扩充分区再分下去的是什么呢？它就是逻辑分区（Logical Partion））
Linux下单个磁盘最多可以有15个分区。3个主分区 + 1个扩展分区 + 11个逻辑分区。
建议的分区方法是：先分3个主分区，第四个分区为扩展分区，然后在扩展分区中再分成11个逻辑分区。
在unix/linux系统中，一切都是文件。
所有硬盘、软盘、键盘等设备都用文件来代表，对应 着/dev下面的文件。
对于应用程序来说，可以像对待普通文件一样打开，关闭、读写这些设备文件。
但是这种文件名，比如/dev/sda、/dev /raw/raw1都是用户空间名称，
OS Kernel根本不知道这个名称指的是什么。在内核空间是通过major、minor device number 来区分设备的

块设备也是通过/dev目录下的文件系统节点来访问。块设备上能够容纳文件系统。
常见的块设备如磁盘、emmc flash、nand flash、 SD卡等。

在linux系统中/dev目录下使用ls -l命令查看详细信息，第一个字母“b”为块设备文件的标识。/dev下每个块设备文件对应一个磁盘的分区。
</code></pre>
<h1 id="二、创建分区"><a href="#二、创建分区" class="headerlink" title="二、创建分区"></a>二、创建分区</h1><pre><code>虽然支持mbr的硬盘（容量小于等于2T）分区表中最多能存储四个分区，但我们实际使用时一般只分为两个分区，
一个是主分区（Primary Partion）一个是扩展分区(extended partition)两种，主分区可以马上被使用但不能再分区，
扩展分区必须再进行分区后才能使用，也就是说它必须还要进行二次分区。那么由扩充分区再分下去的是什么呢？它就是逻辑分区（Logical Partion）。 
对习惯于使用Dos或Windows的朋友来说，有几个分区就有几个驱动器，并且每个分区都会获得一个字母标识符，然后就可以选用这个字母来指定在这个分区上的文件和目录，
它们的文件结构都是独立的，非常好理解。 
因为对Linux用户来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构。
 Linux中每个分区都是用来组成整个文件系统的一部分，因为它采用了一种叫“挂载点”的处理方法，它的整个文件系统中包含了一整套的文件和目录，
 且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。
 
 
 1、 fdisk -l 查看块设备情况（块设备包括硬盘，U盘，SD卡） 
</code></pre>
<h1 id="格式化分区"><a href="#格式化分区" class="headerlink" title="格式化分区"></a>格式化分区</h1><pre><code>虚拟文件系统(VFS) 操作模型，通过mkfs.xxx等这种系列性的命令创建格式化很多不同的文件系统，
比如：mkfs.ext4 /dev/sda 、 mkfs.btrfs /dev/sdb等,但这些不同的文件系统都有各自的API接口，而用户想要的是，不管你是什么API，
他们只关心mount/umount，或open/close等操作，等于屏蔽了底层的文件系统类型，运维层面只关心mount等操作即可。不同的文件系统类型有不同的特点，
因而根据存储设备的硬件特性、系统需求等有不同的应用场合,什么意思呢，也就是说假如你用了不同设备都是硬盘，那么建立这个硬盘可以用不同的文件系统来做映射，
可能就会获得不同的性能提升。还是要看相关的设备种类和厂商设计的目的。


文件系统    描 述
Ext    Linux 中最早的文件系统，由于在性能和兼容性上具有很多缺陷，现在已经很少使用,是为 Linux 核心所做的第一个文件系统，最大可支持 2GB 的文件系统。

Ext2    是 Ext 文件系统的升级版本，Red Hat Linux 7.2 版本以前的系统默认都是 Ext2 文件系统。于 1993 年发布，
        支持最大 16TB 的分区和最大 2TB 的文件（1TB=1024GB=1024x1024KB)
        Linux正统的文件系统(如ext2、ext3)一个文件由目录项、inode和数据块组成。
        目录项:包括文件名和inode节点号。
        Inode：又称文件索引节点，是文件基本信息的存放地和数据块指针存放地。
        数据块：文件的具体内容存放地。
        将硬盘分区时会划分出目录块、inode Table区块和data block数据区域。一个文件由一个目录项、inode和数据区域块组成。
        Inode包含文件的属性(如读写属性、owner等，以及指向数据块的指针)，数据区域块则是文件内容。
        当查看某个文件时，会先从inode table中查出文件属性及数据存放点，再从数据块中读取数据

Ext3    是 Ext2 文件系统的升级版本，最大的区别就是带日志功能，以便在系统突然停止时提高文件系统的可靠性。支持最大 16TB 的分区和最大 2TB 的文件

Ext4    是 Ext3 文件系统的升级版。Ext4 在性能、伸缩性和可靠性方面进行了大量改进。Ext4 的变化可以说是翻天覆地的，
        比如向下兼容 Ext3、最大 1EB 文件系统和 16TB 文件、无限数量子目录、Extents 连续数据块 概念、多块分配、延迟分配、
        持久预分配、快速 FSCK、日志校验、无日志模式、在线碎片整理、inode 增强、
        默认启用 barrier 等。它是 CentOS 6.3 的默认文件系统
        
        
xfs        被业界称为最先进、最具有可升级性的文件系统技术，由 SGI 公司设计，目前最新的 CentOS 7 版本默认使用的就是此文件系统。

swap    swap 是 Linux 中用于交换分区的文件系统（类似于 Windows 中的虚拟内存)，
当内存不够用时，使用交换分区暂时替代内存。一般大小为内存的 2 倍，但是不要超过 2GB。它是 Linux 的必需分区

NFS    NFS 是网络文件系统（Network File System）的缩写，是用来实现不同主机之间文件共享的一种网络服务，本地主机可以通过挂载的方式使用远程共享的资源
iso9660    光盘的标准文件系统。Linux 要想使用光盘，必须支持 iso9660 文件系统

fat    就是 Windows 下的 fatl6 文件系统，在 Linux 中识别为 fat

vfat    就是 Windows 下的 fat32 文件系统，在 Linux 中识别为 vfat。支持最大 32GB 的分区和最大 4GB 的文件
</code></pre>
<p><font color='red'>VFAT 是一种早期的文件系统，通常用于与 Windows 系统兼容的可移动设备。由于 VFAT 文件系统不支持类似 UNIX 文件系统的权限和所有权概念，<br>因此在挂载后无法执行 chown 命令来更改文件和目录的所有者。</font></p>
<pre><code>NTFS    就是 Windows 下的 NTFS 文件系统，不过 Linux 默认是不能识别 NTFS 文件系统的，如果需要识别，则需要重新编译内核才能支持。
        它比 fat32 文件系统更加安全，速度更快，支持最大 2TB 的分区和最大 64GB 的文件
ufs    Sun 公司的操作系统 Solaris 和 SunOS 所采用的文件系统

proc    Linux 中基于内存的虚拟文件系统，用来管理内存存储目录 /proc

sysfs    和 proc —样，也是基于内存的虚拟文件系统，用来管理内存存储目录 /sysfs

tmpfs    也是一种基于内存的虚拟文件系统，不过也可以使用 swap 交换分区

现在一般是Ext4 xfs格式
</code></pre>
<h1 id="分区工具"><a href="#分区工具" class="headerlink" title="分区工具"></a>分区工具</h1><pre><code>fdisk命令可以用于对2TB以内的磁盘进行添加、删除、转换分区的功能,用户可以根据实际情况进行合理划分。


parted -l命令

parted一款功能强大的磁盘分区和分区大小调整工具。

parted -l同fdisk -l命令类似，但是它可以识别2TB以上的硬盘，也能查看 GPT 磁盘的分区
</code></pre>
<p>#具体操作  </p>
<h2 id="基本命令介绍"><a href="#基本命令介绍" class="headerlink" title="基本命令介绍"></a>基本命令介绍</h2><pre><code>df -h
      查看分区情况 相对比较直观
      
fdisk -l
      查看系统有几块硬盘  分标有多大  分了那几个区
      
      
lsblk
lsblk -f  
查看分区信息  -f更详细
令可以列出所有可用块设备的信息,而且还能显示他们之间的依赖关系，但是它不会列出RAM盘的信息。块设备有硬盘,闪存盘,CD-ROM等等

用 blkid  获取磁盘的uuid和属性
</code></pre>
<h2 id="详细操作"><a href="#详细操作" class="headerlink" title="详细操作"></a>详细操作</h2><pre><code>分区
1.fdisk   盘符    示例：fidisk /dev/sdb

2.输入n 是创建分区（一般下面多是默认）

3.然后选择分区类型
                p   primary(主分区)
                e   extende（扩展）
                
4.设置分区号（一般默认）  
              

5.然后设置     起始扇区
              结束扇区  
                
6.设置完 输入w    保存     

7.特殊操作需要删除分区 输入d 然后选择分区号                   


格式化  
        mkfs -t ext3 /dev/sdb2
        mkfs -t ext4 /dev/sdb2 
        mkfs.xfs -f /dev/sdb2
        
        
查看分区信息       
lsblk
lsblk -f  更详细


用 blkid  获取磁盘的uuid和属性

vim /etc/fstab


配置模板：UUID=*************  挂载路径  格式  defaults  1  1 
示例   UUID=b2cc970b-7cf4-453e-b3f5-916497b9530e  /apps  xfs  defaults  1  1 
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>linux系统后台运行任务</title>
    <url>/posts/66259c3b.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>搭建lnmp环境</title>
    <url>/posts/8dbab449.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>搭建 nginx_server</title>
    <url>/posts/fa953e4f.html</url>
    <content><![CDATA[<h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><h2 id="1-yum-安装（默认情况下使用yum安装的nginx包含ssl模块）"><a href="#1-yum-安装（默认情况下使用yum安装的nginx包含ssl模块）" class="headerlink" title="1.yum 安装（默认情况下使用yum安装的nginx包含ssl模块）"></a>1.yum 安装（默认情况下使用yum安装的nginx包含ssl模块）</h2><pre><code>    官方 yum 源链接 http://nginx.org/en/linux_packages.html#RHEL-CentOS
    
    vim /etc/yum.repos.d/nginx.repo
    <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[nginx-stable]</span><br><span class="line">name=nginx stable repo</span><br><span class="line">baseurl=http://nginx.org/packages/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br><span class="line"></span><br><span class="line">[nginx-mainline]</span><br><span class="line">name=nginx mainline repo</span><br><span class="line">baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=0</span><br><span class="line">gpgkey=https://nginx.org/keys/nginx_signing.key</span><br><span class="line">module_hotfixes=true</span><br></pre></td></tr></table></figure>
    
    yum-config-manager --enable nginx-stable
    
    yum install nginx
</code></pre>
<h2 id="2-源码编译安装"><a href="#2-源码编译安装" class="headerlink" title="2.源码编译安装"></a>2.源码编译安装</h2><pre><code>下载源码包  http://nginx.org/en/download.html  下载稳定版本

Mainline version：Mainline 是 Nginx 目前主力在做的版本，可以说是开发版
Stable version：最新稳定版，生产环境上建议使用的版本
Legacy versions：遗留的老版本的稳定版

下载命令
wget http://nginx.org/download/nginx-1.22.0.tar.gz

解压缩
tar -zxvf nginx-1.22.0.tar.gz
    
 ./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-pcre
 
 make &amp;&amp; make install
 
 ln -s /usr/local/nginx/conf  /etc/nginx
 
 
 
</code></pre>
<h1 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h1><pre><code>vim /lib/systemd/system/nginx.service     
     
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=nginx</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/nginx/sbin/nginx</span><br><span class="line">ExecReload=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line">ExecStop=/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

软连接etc目录
ln -s /usr/local/nginx/conf /etc/nginx   

systemctl status nginx
systemctl reload nginx
systemctl start nginx

开机启动
systemctl enable nginx

添加用户
groupadd www
useradd -g www -s /sbin/nologin www  
</code></pre>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h6 id="etc-nginx-nginx-conf"><a href="#etc-nginx-nginx-conf" class="headerlink" title="/etc/nginx/nginx.conf"></a>/etc/nginx/nginx.conf</h6><pre><code>   user  www;
   #cpu 几核 这进程就多少
   worker_processes  2;
   worker_cpu_affinity 01 10;
   
   worker_rlimit_nofile 65535;  # 一般等于ulimit -n系统值
   
   #error_log  logs/error.log;
   #error_log  logs/error.log  notice;
   #error_log  logs/error.log  info;
   
   #pid        logs/nginx.pid;
   
   
   events &#123;
       worker_connections  10240;
       use epoll;
   &#125;
   
   
   http &#123;
       include       mime.types;
       default_type  application/octet-stream;
       server_tokens off;
   
       #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
       #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
       #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
   
       #access_log  logs/access.log  main;
   
       sendfile        on;
       #tcp_nopush     on;
   
       #keepalive_timeout  0;
       keepalive_timeout  65;
   
       gzip on;       #表示开启压缩功能
       gzip_min_length  1k; #表示允许压缩的页面最小字节数，页面字节数从header头的Content-Length中获取。默认值是0，表示不管页面多大都进行压缩，建议设置成大于1K。如果小于1K可能会&gt;越压越大
       gzip_buffers     4 32k; #压缩缓存区大小
       gzip_http_version 1.1; #压缩版本
       gzip_comp_level 6; #压缩比率， 一般选择4-6，为了性能
       gzip_types text/css text/xml application/javascript;
       #指定压缩的类型 gzip_vary on;　#vary header支持
   
   
       #配置空主机头 404
       server &#123;
           listen 80 default;
           server_name _;
           root html;
           location / &#123; return 404;&#125;
           location ~ /.ht &#123; deny all; &#125;
   
       &#125;
       include vhost/*.conf;
   &#125;
</code></pre>
<h6 id="vhost-conf"><a href="#vhost-conf" class="headerlink" title="vhost/*.conf"></a>vhost/*.conf</h6><pre><code>server&#123;
    listen 80;
    server_name tp.webstudy.cc;
    set $wwwroot /home/www/htdocs/tp.webstudy.cc;
    root $wwwroot;
    access_log  logs/ai.access.log;
    error_log logs/ai.error.log debug;

    #ssl_certificate     /usr/local/nginx/conf/ssl/jinju.utooo.com/Nginx/1_jinju.utooo.com_bundle.crt;
    #ssl_certificate_key /usr/local/nginx/conf/ssl/jinju.utooo.com/Nginx/2_jinju.utooo.com.key;
    #ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;

    location / &#123;
        index  index.php index.html index.htm;
        # 这里使用try_files进行url重写，不用rewrite了
        # try_files $uri $uri/ /index.php?$query_string;
    &#125;

   #error_page   500 502 503 504  /50x.html;
   location = /50x.html &#123;
        root   html;
    &#125;
    location ~ .*\.php&#123;
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME   $document_root$fastcgi_script_name;
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
    &#125;

&#125;


  
</code></pre>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>nginx之logrotate</title>
    <url>/posts/a61dc71f.html</url>
    <content><![CDATA[<h1 id="一、logrotate介绍"><a href="#一、logrotate介绍" class="headerlink" title="一、logrotate介绍"></a>一、logrotate介绍</h1><p>logrotate是centos自带命令，其他linux操作系统可能需要自行安装，用来进行日志切割和定期删除，</p>
<p>简单来说就是将某个日志文件按照时间或大小分割成多份，删除时间久远的日志。</p>
<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><pre><code>yum install -y logrotate     #centos 系统

apt install -y logrotate    #ubuntu 系统
</code></pre>
<h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><p>/etc/logrotate.conf是全局配置</p>
<pre><code>#指定日志文件保留几个副本
rotate 4

# 指定当发生滚动后，创建一个新的空日志文件（权限不变）
create

# 指定滚动文件的后缀是当前的日期
dateext  

# 指定是否对滚动日志进行压缩
#compress

# 加载子配置
include /etc/logrotate.d

# 指定对特定文件的滚动规则
/var/log/wtmp &#123;
    monthly
    create 0664 root utmp
    minsize 1M  #指定文件小于1m就不滚动
    rotate 1
&#125;

/var/log/btmp &#123;
    missingok
    monthly
    create 0600 root utmp
    rotate 1
&#125;
</code></pre>
<p>/etc/logrotate.d/*（子配置）</p>
<h1 id="三、执行"><a href="#三、执行" class="headerlink" title="三、执行"></a>三、执行</h1><p>方案一<br>    通过 /etc/cron.daily/logrotate 配置<br>方案二<br>    crontab -e写入，内容为“  59 23 * * * /usr/sbin/logrotate -f /home/zmq/daily_logrotate  </p>
<h1 id="四、具体的配置文件"><a href="#四、具体的配置文件" class="headerlink" title="四、具体的配置文件"></a>四、具体的配置文件</h1><pre><code>/var/log/nginx/*.log &#123;
          daily
          missingok
          rotate 52
          compress
          delaycompress
          notifempty
          create 640 nginx adm
          sharedscripts
          postrotate
                 if [ -f /var/run/nginx.pid ]; then
                         kill -USR1 `cat /var/run/nginx.pid`
                 fi
          endscript
 &#125;
 
 
 
 /var/opt/remi/php71/log/php-fpm/*log &#123;
        missingok
        notifempty
        sharedscripts
        delaycompress
        postrotate
            /bin/kill -SIGUSR1 `cat /var/opt/remi/php71/run/php-fpm/php-fpm.pid 2&gt;/dev/null` 2&gt;/dev/null ||     true
        endscript
  &#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>搭建 mysql_server</title>
    <url>/posts/ca8fa022.html</url>
    <content><![CDATA[<h1 id="centos-mysql安装"><a href="#centos-mysql安装" class="headerlink" title="centos mysql安装"></a>centos mysql安装</h1><p>1.网站：<a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p>
<p>2.mysql官网找到相应版本安装包</p>
<p>3.然后下载本地 tar -xvf mysql-5.7.21-1.el7.x86_64.rpm-bundle.tar</p>
<p>4.rpm -qa|grep mariadb 查看是否安装mariadb数据库，有就卸载  yum remove 包名 <font color='red'>不卸载干净，会报错哦</font></p>
<p>5.按下列包顺序安装</p>
<pre><code>rpm -ivh mysql-community-common-5.7.19-1.el7.x86_64.rpm

rpm -ivh mysql-community-libs-5.7.19-1.el7.x86_64.rpm

rpm -ivh mysql-community-devel-5.7.19-1.el7.x86_64.rpm

rpm -ivh mysql-community-libs-compat-5.7.19-1.el7.x86_64.rpm

rpm -ivh mysql-community-client-5.7.19-1.el7.x86_64.rpm

rpm -ivh mysql-community-server-5.7.19-1.el7.x86_64.rpm
</code></pre>
<p>6.优化配置   </p>
<p>  6.1 /data/mysql/logs/相关目录需要创建</p>
<pre><code>mkdir -p  /data/mysql/logs/
</code></pre>
<p>  6.2  my.cnf 配置文件</p>
<pre><code>port=3306
设置端口号

datadir=/data/mysqldata
#数据存在目录
    
############## Slow Log   ######################
slow_query_log=ON
# 开启慢查询日志

slow_query_log_file=/data/mysql/logs/slow.log
# # 慢查询日志存放路径

long_query_time=10
# # 超过10秒的查询，记录到慢查询日志，默认值10

log_queries_not_using_indexes=ON
# # 没有使用索引的查询，记录到慢查询日志，可能引起慢查询日志快速增长

log_slow_admin_statements=ON
# # 执行缓慢的管理语句，记录到慢查询日志
# # 例如 ALTER TABLE, ANALYZE TABLE, CHECK TABLE, CREATE INDEX, DROP INDEX, OPTIMIZE TABLE, and REPAIR TABLE.


###################     Error Log   ####################
log_error=/data/mysql/logs/mysqld.log
## 错误日志存放路径
log_error_verbosity = 2
## 全局动态变量，默认3，范围：1～3


###################     Bin Log    ######################
server_id = 6
###################     Error Log   ####################
log_error=/data/mysql/logs/mysqld.log    
</code></pre>
<ol start="7">
<li>启动 systemctl start mysqld<br> 安装完毕 初始密码一般在/var/log/mysqld.log文件中<br> cat   /var/log/mysqld.log |grep password</li>
</ol>
<p>8.登录数据库 修改密码 mysql -u root -p</p>
<p>9.登录后修改密码 </p>
<pre><code>SET PASSWORD = PASSWORD(&#39;xxx@520Flzx3qc&#39;);

允许远程root用户连接
GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;your_password&#39; WITH GRANT OPTION;
FLUSH PRIVILEGES;
</code></pre>
<p>10.相关命令</p>
<pre><code>开机启动
systemctl enable mysqld

systemctl stop mysqld
systemctl start mysqld
systemctl restart mysqld
</code></pre>
<p>#安装报错解决</p>
<pre><code>Error: 
 Problem: cannot install the best candidate for the job
  - nothing provides libcrypto.so.10()(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libssl.so.10()(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libcrypto.so.10(libcrypto.so.10)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libssl.so.10(libssl.so.10)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libcrypto.so.10(OPENSSL_1.0.1_EC)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libcrypto.so.10(OPENSSL_1.0.2)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64




解决方案

wget https://rpmfind.net/linux/centos/8-stream/AppStream/x86_64/os/Packages/compat-openssl10-1.0.2o-4.el8.x86_64.rpm
yum install compat-openssl10
或者
yum install http://mirror.centos.org/centos/8-stream/AppStream/x86_64/os/Packages/compat-openssl10-1.0.2o-3.el8.x86_64.rpm
或者
yum install -y ./compat-openssl10-1.0.2o-4.el8.x86_64.rpm



[root@ecs-41618143 ~]# rpm -ivh mysql-community-client-5.7.34-1.el7.x86_64.rpm 
warning: mysql-community-client-5.7.34-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY
error: Failed dependencies:
    libncurses.so.5()(64bit) is needed by mysql-community-client-5.7.34-1.el7.x86_64
    libtinfo.so.5()(64bit) is needed by mysql-community-client-5.7.34-1.el7.x86_64
    
    
 解决方案    
 
 yum install libncurses*
</code></pre>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>nginx-vhost-安全配置模版</title>
    <url>/posts/8a9d1567.html</url>
    <content><![CDATA[<p>#nginx-vhost-安全配置模版</p>
<pre><code>server&#123;
        listen 443 ssl ;
        server_name  [域名或者ip];
        index        index.php index.html index.htm;
        root [项目路径];
        access_log  /var/log/nginx/[项目名称].access.log;
        error_log   /var/log/nginx/[项目名称].error.log;

        #证书文件名称
        ssl_certificate [证书路径 公钥];
        #私钥文件名称
        ssl_certificate_key [证书路径 私钥];
        ssl_session_timeout 5m;
        #请按照以下协议配置
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;
        ssl_prefer_server_ciphers on


        #允许cookie
        add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;
        #安全头
        add_header X-Xss-header &quot;1;mode=block&quot;;
        add_header Set-Cookie &quot;HttpOnly&quot;;
        add_header Set-Cookie &quot;Secure&quot;;
        add_header X-Frame-Options &quot;SAMEORIGIN&quot;;

        location ~ \.(json|lock|git)$ &#123;
                 deny all;
        &#125;
        location ~ ^/(uploads|assets)/.*\.(php|php5|jsp|shtml)$ &#123;
            deny all;
        &#125;
        location ~ .*\.(txt|doc|pdf|rar|gz|zip|docx|exe|xlsx|ppt|pptx)$ &#123;
            add_header Content-Disposition attachment;
        &#125;
        location =/assets/libs/bootstrap/Gemfile &#123;
                       return 404;
        &#125;
        location ~ /\. &#123;
            deny  all;
        &#125;

        location / &#123;
                proxy_cookie_path / &quot;/; httponly; secure; SameSite=None&quot;;
                if (!-e $request_filename) &#123;
                        rewrite  ^(.*)$  /index.php?s=/$1  last;
                        break;
                &#125;

        &#125;

        location ~ \.php(.*)$ &#123;
                fastcgi_pass   [访问php方式];
                fastcgi_index  index.php;
                fastcgi_split_path_info  ^((?U).+\.php)(/?.+)$;
                fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
                fastcgi_param  PATH_INFO  $fastcgi_path_info;
                fastcgi_param  PATH_TRANSLATED  $document_root$fastcgi_path_info;
                include        fastcgi_params;
        &#125;

        #timeout
        large_client_header_buffers 4 16k;
        client_max_body_size 180m;
        client_body_buffer_size 128k;
        fastcgi_connect_timeout 600;
        fastcgi_read_timeout 600;
        fastcgi_send_timeout 600;
        fastcgi_buffer_size 128k;
        fastcgi_buffers   2 256k;
        fastcgi_busy_buffers_size 256k;
        fastcgi_temp_file_write_size 256k;
        proxy_read_timeout  240s;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>nginx之location</title>
    <url>/posts/e22c93eb.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>nginx配置</title>
    <url>/posts/2bee8b90.html</url>
    <content><![CDATA[<h1 id="一-、配置详解"><a href="#一-、配置详解" class="headerlink" title="一 、配置详解"></a>一 、配置详解</h1><h2 id="1-1nginx配置文件"><a href="#1-1nginx配置文件" class="headerlink" title="1.1nginx配置文件"></a>1.1nginx配置文件</h2><pre><code>#nginx 已那个用户身份访问文件
user  www;  

#指定nginx使用的worker进程数
worker_processes 8;   

#worker_cpu_affinity是一个用于配置工作进程CPU亲和性的选项。
#CPU亲和性是指将进程或线程绑定到特定的CPU核心上，以提高性能和效率。
#通常cpu几核，就配置几个
worker_cpu_affinity 0000001 00000010 00000011 00000100 00000101 00000110 00000111 00001000;

#PID配置项是用于指定保存主进程ID的文件路径
pid        /var/run/nginx.pid;

#用于限制每个worker进程可以打开的最大文件描述符数量。
#ulimit -n 查看系统文件句柄数   设置为系统允许的最大文件句柄数的 80% - 90%
worker_rlimit_nofile 65535;


#用于控制Nginx服务器的事件模型和并发处理方式。
events &#123;
    #用于设置每个worker进程的最大并发连接数 即每个worker进程可以同时处理的最大客户端连接数
    worker_connections 1024;
    
    #常见的事件模型包括epoll、kqueue和select等。
    use epoll;
    
    #用于指定是否允许一个worker进程同时接受多个新连接
    multi_accept on;
&#125;

#用于代理TCP和UDP流量，允许将Nginx作为代理服务器来处理网络流量
#使用stream模块可以使Nginx具备代理TCP和UDP流量的能力
stream &#123;
       include /etc/nginx/stream/*.conf;
&#125;

#此模块用于配置HTTP服务器，允许主机作为Web服务器来处理HTTP请求
http &#123;
    #引入mime头文件  定义了Nginx的mime类型    
    include       mime.types;
    
    #指令用于设置在请求无法匹配到任何MIME类型时的默认类型
    default_type  application/octet-stream;
    
    #定义日志格式  main 为日志格式 名称
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;
                      
    #定义访问日志路径 main 指用那个日志格式名称                  
    access_log  /var/log/nginx/access.log  main;
    
    # 当将sendfile设置为on时，Nginx使用sendfile()系统调用来直接将文件从磁盘传输到网络，
    # 而无需将文件数据复制到用户空间。这样可以显着提高文件传输速度和效率。
    sendfile on;
    
    #将tcp_nopush设置为on时，Nginx会禁用TCP_CORK
    #允许在nginx worker进程发送数据时立即将响应发送到客户端，而无需等待TCP缓冲区填满。
    #将tcp_nopush设置为on可以提高响应的实时性，允许立即发送数据到客户端
    tcp_nopush on;
    
    #将tcp_nodelay设置为on时，Nginx会打开TCP_NODELAY，这将禁用TCP的Nagle算法，
    #以便在发送小数据包或有延迟要求的数据时能够及时发送数据。
    #将tcp_nodelay设置为on可以减少TCP延迟，适用于实时性要求高的应用场景。
    tcp_nodelay on;
    
    #隐藏Nginx版本号
    server_tokens  off;    

    proxy_hide_header X-Powered-By;
    
    proxy_hide_header Server;
     
    #配置空主机头 404 就是禁用http通过ip访问
    
    server &#123;
        listen 80 default_server;
        server_name _;
        return 444;
    &#125;
    server &#123;
        listen 443 ssl default_server;
        server_name _;
        ssl on;
        return 444;
    &#125;
    
    include /etc/nginx/conf.d/*.conf;
&#125;
</code></pre>
<h2 id="1-2log-format可用变量"><a href="#1-2log-format可用变量" class="headerlink" title="1.2log_format可用变量"></a>1.2log_format可用变量</h2><pre><code>$remote_addr：客户端的IP地址。
$remote_user：客户端的用户名称（如果有授权）。
$time_local：访问时间和日期（格式：[day/month/year:hour:minute:second zone]）。
$request_method：HTTP请求的方法（例如GET或POST）。
$request_uri：完整的请求URI。
$request_length：请求的长度（包括请求行，请求头和请求体）。
$status：HTTP响应的状态码。
$body_bytes_sent：发送给客户端的响应体的字节数。
$http_referer：请求中的“Referer”头部字段，包含了前一个页面的URL。
$http_user_agent：请求的用户代理头部字段，表示发起请求的客户端工具或库。
</code></pre>
<h2 id="1-3host配置文件"><a href="#1-3host配置文件" class="headerlink" title="1.3host配置文件"></a>1.3host配置文件</h2><h3 id="upstream-模块"><a href="#upstream-模块" class="headerlink" title="upstream 模块"></a>upstream 模块</h3><pre><code>#定义负载均衡
#放置在 http 或 server 块
upstream name &#123;
    
     #用于指定上游服务器的地址和端口。可以指定多个server来定义多个上游服务器。
     server backend1.example.com;
     
     #max_fails 和 fail_timeout：用于设置上游服务器的故障处理策略
     #max_fails 指定在多少次失败请求后将服务器标记为不可用
     #fail_timeout 指定在服务器被标记为不可用后，多长时间内不再尝试请求。
     server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;
    
    #设置与上游服务器的连接保持活动的时间。可以提高性能并减少连接建立的开销。
    keepalive:32;

&#125;

#weight：用于设置服务器的权重。权重越高，Nginx 转发给该服务器的请求越多。
#示例：
upstream backend &#123;
    server backend1.example.com weight=3;
    server backend2.example.com weight=2;
&#125;



#ip_hash：使用客户端的IP地址进行负载均衡，使得来自同一IP地址的请求始终被转发到同一台上游服务器。
#示例：
upstream backend &#123;
    ip_hash;
    server backend1.example.com;
    server backend2.example.com;
&#125;
</code></pre>
<h3 id="Server模块"><a href="#Server模块" class="headerlink" title="Server模块"></a>Server模块</h3><pre><code>server：定义一个虚拟主机
server&#123;
    listen：指定服务器监听的端口
    server_name：配置域名或IP地址
    root：指定网站文件的根目录
    index：定义当访问网站时默认显示的文件
    location：定义请求的URL匹配规则和对应的处理方法。
    proxy_pass：用于反向代理服务器的配置。
    ssl_certificate和ssl_certificate_key：配置SSL/TLS证书。
    try_files：定义文件检查规则
    
    gzip on;    将 Gzip 压缩功能开启。
    
    将所有类型的文件都进行 Gzip 压缩。这意味着无论是文本文件、图像文件还是视频文件，
    都将进行压缩传输。如果你希望只压缩特定类型的文件，可以指定具体的文件类型，
    例如 gzip_types text/plain text/css application/javascript;。
    gzip_types *;
   
    (gzip_proxied on or gzip_proxied off or gzip_proxied expired no-cache no-store private auth) 指定需要压缩的响应类型，
    并且设置允许或者不允许使用代理服务器进行压缩。any 表示无论何时都进行压缩。
    gzip_proxied any;
&#125;
</code></pre>
<h1 id="二、常用示例"><a href="#二、常用示例" class="headerlink" title="二、常用示例"></a>二、常用示例</h1><h2 id="2-1-mysql-代理示例"><a href="#2-1-mysql-代理示例" class="headerlink" title="2.1 mysql 代理示例"></a>2.1 mysql 代理示例</h2><pre><code>stream &#123;
        server &#123;
            listen 63306;
            proxy_connect_timeout 8s;
            proxy_timeout 24h;
            proxy_pass 192.168.0.108:3306;
        &#125;
&#125;
</code></pre>
<h2 id="2-3-带upstream的写法"><a href="#2-3-带upstream的写法" class="headerlink" title="2.3 带upstream的写法"></a>2.3 带upstream的写法</h2><pre><code>upstream rd_servers &#123;
  server 127.0.0.1:5000;
&#125;

server&#123;
  server_tokens off;
  listen 80;
  server_name redash.xxxxx.com;
  access_log /var/log/nginx/rd.access.log;

  gzip on;
  gzip_types *;
  gzip_proxied any;

  location / &#123;
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_pass       http://rd_servers;
  &#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>openEuler系统安装遇到问题</title>
    <url>/posts/a9da9b42.html</url>
    <content><![CDATA[<p>#yum 安装报依赖库找不到问题</p>
<pre><code>openEuler release 22.03版本

替换centos 7的源就可以

具体命令：wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo

然后 将文件中$releasever替换7

具体命令：vim 后  %s/$releasever/7/g
</code></pre>
<h1 id="安装-yum-install-nginx-报错"><a href="#安装-yum-install-nginx-报错" class="headerlink" title="安装 yum install nginx 报错"></a>安装 yum install nginx 报错</h1><pre><code>Error: 
 Problem: 软件包 nginx-1:1.24.0-1.el7.ngx.x86_64 需要 libcrypto.so.10()(64bit)，但没有提供者可以被安装
  - 软件包 nginx-1:1.24.0-1.el7.ngx.x86_64 需要 libcrypto.so.10(libcrypto.so.10)(64bit)，但没有提供者可以被安装
  - 软件包 nginx-1:1.24.0-1.el7.ngx.x86_64 需要 libssl.so.10()(64bit)，但没有提供者可以被安装
  - 软件包 nginx-1:1.24.0-1.el7.ngx.x86_64 需要 libssl.so.10(libssl.so.10)(64bit)，但没有提供者可以被安装
  - 软件包 nginx-1:1.24.0-1.el7.ngx.x86_64 需要 libcrypto.so.10(OPENSSL_1.0.2)(64bit)，但没有提供者可以被安装
  - 无法同时安装 openssl-libs-1:1.0.2k-19.el7.x86_64 和 openssl-libs-1:1.1.1m-22.oe2203.x86_64
  - 无法同时安装 openssl-libs-1:1.0.2k-21.el7_9.x86_64 和 openssl-libs-1:1.1.1m-22.oe2203.x86_64
  - 无法同时安装 openssl-libs-1:1.0.2k-22.el7_9.x86_64 和 openssl-libs-1:1.1.1m-22.oe2203.x86_64
  - 无法同时安装 openssl-libs-1:1.0.2k-24.el7_9.x86_64 和 openssl-libs-1:1.1.1m-22.oe2203.x86_64
  - 无法同时安装 openssl-libs-1:1.0.2k-25.el7_9.x86_64 和 openssl-libs-1:1.1.1m-22.oe2203.x86_64
  - 无法同时安装 openssl-libs-1:1.0.2k-26.el7_9.x86_64 和 openssl-libs-1:1.1.1m-22.oe2203.x86_64
  - 软件包 ima-evm-utils-libs-1.3.2-8.oe2203sp1.x86_64 需要 libcrypto.so.1.1()(64bit)，但没有提供者可以被安装
  - 软件包 ima-evm-utils-libs-1.3.2-8.oe2203sp1.x86_64 需要 libcrypto.so.1.1(OPENSSL_1_1_0)(64bit)，但没有提供者可以被安装
  - 软件包 ima-evm-utils-libs-1.3.2-8.oe2203sp1.x86_64 需要 libcrypto.so.1.1(OPENSSL_1_1_1)(64bit)，但没有提供者可以被安装
  - 无法为该任务安装最佳候选
  - 安装的软件包的问题 ima-evm-utils-libs-1.3.2-8.oe2203sp1.x86_64
(try to add &#39;--allowerasing&#39; to command line to replace conflicting packages or &#39;--skip-broken&#39; to skip uninstallable packages or &#39;--nobest&#39; to use not only best candidate packages)


解决方案
yum install compat-openssl10
yum install http://mirror.centos.org/centos/8-stream/AppStream/x86_64/os/Packages/compat-openssl10-1.0.2o-3.el8.x86_64.rpm
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>openEuler搭建lnmp</title>
    <url>/posts/b991678b.html</url>
    <content><![CDATA[<p>#openEuler搭建lnmp</p>
<p>##安装php<br>wget <a href="https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm">https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm</a></p>
<p>rpm -ivh –nodeps epel-release-latest-7.noarch.rp</p>
<p>wget <a href="https://rpms.remirepo.net/enterprise/remi-release-7.rpm">https://rpms.remirepo.net/enterprise/remi-release-7.rpm</a></p>
<p>rpm -ivh –nodeps remi-release-7.rpm </p>
<p>yum-config-manager –enable remi-php73</p>
<p>yum install php73 php73-php-fpm php73-php-opcache php73-php-gd php73-php-mbstring php73-php-xml php73-php-pdo php73-php-mysqlnd php73-php-pecl-mysql php73-php-bcmath</p>
<p>##rpm包安装mysql</p>
<pre><code>Error: 
 Problem: cannot install the best candidate for the job
  - nothing provides libcrypto.so.10()(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libssl.so.10()(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libcrypto.so.10(libcrypto.so.10)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libssl.so.10(libssl.so.10)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libcrypto.so.10(OPENSSL_1.0.1_EC)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  - nothing provides libcrypto.so.10(OPENSSL_1.0.2)(64bit) needed by php73-php-fpm-7.3.33-10.el7.remi.x86_64
  
</code></pre>
<p>此报错处理办法      </p>
<pre><code>yum install compat-openssl10
yum install http://mirror.centos.org/centos/8-stream/AppStream/x86_64/os/Packages/compat-openssl10-1.0.2o-3.el8.x86_64.rpm
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>php扩展编译安装</title>
    <url>/posts/928212f0.html</url>
    <content><![CDATA[<h1 id="一、找点phpize-和-php-config路径"><a href="#一、找点phpize-和-php-config路径" class="headerlink" title="一、找点phpize 和 php-config路径"></a>一、找点phpize 和 php-config路径</h1><pre><code>find / -name phpize

find / -name php-config
</code></pre>
<h1 id="二、找到"><a href="#二、找到" class="headerlink" title="二、找到"></a>二、找到</h1><p>项目目录下执行 查找到的phpize </p>
<pre><code>/opt/remi/php74/root/usr/bin/phpize

如报错
Can&#39;t find PHP headers in /usr/include/php The php-devel package is required for use of this command...

安装php-devel即可

yum install -y php-devel

remi安装如下安装
yum install -y php73-php-devel
</code></pre>
<h1 id="三、编译"><a href="#三、编译" class="headerlink" title="三、编译"></a>三、编译</h1><pre><code> 1.进入项目目录下
 ./configure --with-php-config=【第一步查询到的路径】
 
 示例
    ./configure --with-php-config=/www/server/php/71/bin/php-config

 2. 执行
 
 make &amp;&amp; make install
</code></pre>
<h1 id="四、添加配置"><a href="#四、添加配置" class="headerlink" title="四、添加配置"></a>四、添加配置</h1><pre><code>vi /具体路径/php.ini
 
extension=swoole.so

如是remi 安装的php 
在/etc/opt/remi/php73/php.d下新建
新建ini文件  参考其他设置下

万变方案 phpinfo 看下是如何加载扩展的 具体的目录 多有
</code></pre>
<h1 id="五、重启服务"><a href="#五、重启服务" class="headerlink" title="五、重启服务"></a>五、重启服务</h1><pre><code>systemctl restart php-fpm   
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>php常用函数总结</title>
    <url>/posts/15179f17.html</url>
    <content><![CDATA[<h1 id="一、字符串处理函数"><a href="#一、字符串处理函数" class="headerlink" title="一、字符串处理函数"></a>一、字符串处理函数</h1><h2 id="1-1-str-pad"><a href="#1-1-str-pad" class="headerlink" title="1.1 str_pad()"></a>1.1 str_pad()</h2><p>str_pad(【必填 需要处理的字符串】,【必填 填充的长度】，【 可选 填充的字符串，默认空白】，【可选 填充字符串的哪边】)</p>
<pre><code>规定填充字符串的哪边 可能的值：

STR_PAD_BOTH - 填充字符串的两侧。如果不是偶数，则右侧获得额外的填充。
STR_PAD_LEFT - 填充字符串的左侧。
STR_PAD_RIGHT - 填充字符串的右侧。这是默认的。
</code></pre>
<p>示例 $str=10 ; echo str_pad($str,4,”0”,STR_PAD_LEFT);  <font color="red">意思就4位长度 不够就往左边补0</font></p>
<h2 id="2-1-strpos、stripos-、strrpos"><a href="#2-1-strpos、stripos-、strrpos" class="headerlink" title="2.1 strpos、stripos 、strrpos"></a>2.1 strpos、stripos 、strrpos</h2><h2 id="2-3-substr"><a href="#2-3-substr" class="headerlink" title="2.3 substr"></a>2.3 substr</h2><h2 id="2-4-strtolower-strtouplower-strlen-mb-strlen-trim-ltrim-rtrim-explode-implode常用"><a href="#2-4-strtolower-strtouplower-strlen-mb-strlen-trim-ltrim-rtrim-explode-implode常用" class="headerlink" title="2.4 strtolower strtouplower strlen mb_strlen trim ltrim rtrim explode implode常用"></a>2.4 strtolower strtouplower strlen mb_strlen trim ltrim rtrim explode implode常用</h2><pre><code>比较常用，不在赘述
</code></pre>
<h1 id="二、数组处理函数"><a href="#二、数组处理函数" class="headerlink" title="二、数组处理函数"></a>二、数组处理函数</h1>]]></content>
      <tags>
        <tag>php开发</tag>
      </tags>
  </entry>
  <entry>
    <title>redis基本数据结构</title>
    <url>/posts/660a1c80.html</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><pre><code>Redis五大数据类型：String、Hash、List、Set、Sorted set
</code></pre>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>String类型的最大能存储512M 应用场景 【缓存】</p>
<pre><code>1.SET key value [EX seconds] [PX milliseconds] [NX|XX]

EX和PX参数可选，用于设置键的过期时间，单位分别为秒和毫秒

NX表示只在键不存在时创建，XX表示只在键已存在时执行操作。

将键 &quot;abc&quot; 设置为值 &quot;123&quot; 并设置过期时间为 12 秒

    set abc 123 ex 12

2. MSET key1 value1 [key2 value2 ...]  设置多条
     mset a 1 b 2 
       
3.EXPIRE key seconds    设置过期时间

4.SETEX key seconds value 可用于一次设置带有过期时间的键值对

select命令切换数据库，分库的作用主要用来业务分片：
dbsize查看当前数据库的key的数量
flushdb清除当前库所有key(当前库)：
</code></pre>
<h1 id="Hash-哈希表"><a href="#Hash-哈希表" class="headerlink" title="Hash(哈希表)"></a>Hash(哈希表)</h1><pre><code>hget：通过key值，从hash里取对应的value

hset：往hash里，添加key-value

hmset
hmget：一次性获取多个key的value

hmset user:2 name:kati age 28 sex woman

hmget user:2 name age sex
</code></pre>
<h1 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h1><pre><code>lpush：从列表List的左边插入一个元素。

lpop：从列表List的左边移出一个元素。

rpush：从列表List的右边插入一个元素。

rpop：从列表List的右边移出一个元素。

llen：打印当前列表List中的元素个数。
</code></pre>
<h1 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h1><h1 id="Sorted-set-有序集合"><a href="#Sorted-set-有序集合" class="headerlink" title="Sorted set(有序集合)"></a>Sorted set(有序集合)</h1>]]></content>
  </entry>
  <entry>
    <title>rsyslog日志上报服务</title>
    <url>/posts/aaedf8b3.html</url>
    <content><![CDATA[<h1 id="rsyslog-基础"><a href="#rsyslog-基础" class="headerlink" title="rsyslog 基础"></a>rsyslog 基础</h1><h2 id="日志类别"><a href="#日志类别" class="headerlink" title="日志类别"></a>日志类别</h2><pre><code>日志类型 日志内容
auth 用户认证时产生的日志
syslog 系统日志
local0~local7 自定义程序使用
等等
</code></pre>
<h2 id="Properties模板元素属性"><a href="#Properties模板元素属性" class="headerlink" title="Properties模板元素属性"></a>Properties模板元素属性</h2><p>常用的变量</p>
<pre><code>hostname 打印该日志的主机名。
fromhost 接收的信息来自于哪个节点。这里是DNS解析的名字。
fromhost-ip 接收的信息来自于哪个节点，这里是IP，本地的是127.0.0.1。
syslogtag 信息标签。大致形如 programed[14321] 。
programname 文件名

Properties与时间相关的属性属性 释义
$now 当前日期时间戳，格式为YYYY-MM-DD (2020-07-08)
$year 当前年份， 四位数 (2020)
$month 当前月份， 两位数 (07)
$day 当前月份的日期，两位数 (08)
$wday 当前天数周几 ：0=Sunday,...6=Saturday
$hour 当前小时（24小时机制），两位数(16)
$hhour 半小时机值，就是0-29分钟显示0，30-59分钟显示1。
$qhour 一刻钟机值，通过0-3显示，每15分钟一截。
$minute 当前分钟数，两位数(57)
</code></pre>
<p>示例<br>    定义日志目录</p>
<pre><code>$template RemoteTestlogs,&quot;/var/log/syslog/%fromhost-ip%/test.log&quot;

/var/log/syslog/%$YEAR%-%$MONTH%-%$DAY%/%FROMHOST-IP%-%programname%.log
</code></pre>
<p>##日志文件权限 </p>
<p>日志文件权限新生成的目录和文件权限可以在配置文件设置</p>
<pre><code> vim /etc/rsyslog.conf
 #尽量在开头设置
 $FileOwner root
 $FileGroup root
 $FileCreateMode 0755 #文件权限
 $DirCreateMode 0755 #目录权限
 $Umask 0022
 
</code></pre>
<h2 id="模版配置"><a href="#模版配置" class="headerlink" title="模版配置"></a>模版配置</h2><p> 1、示例1</p>
<pre><code> $template DynamicFile,&quot;/var/log/test_logs/%timegenerated%-test.log&quot;
 *.* ?DynamicFile
</code></pre>
<p> 2、示例2</p>
<pre><code> $template RemoteHost,&quot;/home/rsyslog-data/%$YEAR%-%$MONTH%-%$DAY%/%FROMHOST-IP%.log
 *.* ?RemoteHost
 #    &amp; ~ 忽略所有的日志.
 &amp; ~
</code></pre>
<p> 3、示例3</p>
<pre><code> #配置文件存储模板
 $template RemoteAuditLogs,&quot;/data/auditd/%FROMHOST-IP%/audit.log&quot; *
 $template RemoteNetworkLogs,&quot;/data/network-log/%HOSTNAME%/network.log&quot; *
 #引用模板
 local6.* ?RemoteNetworkLogs
 local2.* ?RemoteAuditLog   
</code></pre>
<h1 id="配置案例"><a href="#配置案例" class="headerlink" title="配置案例"></a>配置案例</h1><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p>1.2 相关配置</p>
<p> 增加imfile模块配置，【不然自定义的日志，无法发送到服务端】</p>
<pre><code>$ModLoad imuxsock # provides support for local system logging (e.g. via logger command)
$ModLoad imjournal # provides access to the systemd journal
# 下发添加 方法一
module(load=&quot;imfile&quot; PollingInterval=&quot;1&quot;) 
# 方法二
$ModLoad imfile

local7.* /var/log/local7.log

#只发送local7 类型日志
#local7.* @@121.4.27.111
#将所有日志 多发送  
*.* @@121.4.27.111
</code></pre>
<p> 新增/etc/rsyslog.d/local7.conf</p>
<pre><code>  #工作目录 这个可不配 默认/var/log/下
  #$WorkDirectory /var/log/rsyslog
  
  #输入文件模式
  input(type=&quot;imfile&quot;
       File=&quot;/var/log/local7.log&quot;   #可指定任意文件，但需要将文件权限置为777
       Tag=&quot;local7&quot;      #文件标识，服务器接收到消息可以使用这个tag分类
       Severity=&quot;info&quot;            #日志级别
       Facility=&quot;local7&quot;             
       PersistStateInterval=&quot;1&quot;     #回写偏移量数据到文件间隔时间(秒)
       ruleset=&quot;remote&quot;)          #规则集，rsyslog.conf中定义的rule名称
</code></pre>
<h2 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h2><p>定义开启 接收的协议 以及端口</p>
<pre><code># Provides UDP syslog reception
$ModLoad imudp
$UDPServerRun 514
 
# Provides TCP syslog reception
$ModLoad imtcp
$InputTCPServerRun 514
</code></pre>
<p>定义模版</p>
<p>   1.示例1</p>
<pre><code>#生成模板
$template SpiceTmpl,&quot;%msg:2:$%\n&quot;
$template CatalinaDynaFile,&quot;/var/log/rsyslog/%fromhost-ip%/catalina_%$YEAR%-%$MONTH%-%$DAY%.log&quot;
  
#匹配规则，文章后面将分享其他配置类型
:fromhost-ip,contains,&quot;192.168.88.132&quot; ?CatalinaDynaFile;SpiceTmpl
</code></pre>
<p>   2.示例2</p>
<pre><code>$template RemoteLogs,&quot;/var/log/syslog/%$YEAR%-%$MONTH%-%$DAY%/%FROMHOST-IP%-%programname%.log&quot;
*.* ?RemoteLogs
&amp; ~
</code></pre>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>-it error：这是两个选项的组合。-i选项指定附加进程ID（PID）到日志消息中，-t error选项指定将&quot;error&quot;作为消息的标记（TAG）。
-p local5.crit：这是指定日志消息的优先级的选项。在这个例子中，local5.crit表示使用syslog的local5设施和crit（严重）优先级。
&quot;hello world&quot;：这是要记录的实际消息内容。

该命令用于向系统日志中添加一条日志消息
logger -it local1 -p local1.info &quot;hello&quot;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>搭建php环境</title>
    <url>/posts/35d2b340.html</url>
    <content><![CDATA[<h1 id="一、安装Remi源："><a href="#一、安装Remi源：" class="headerlink" title="一、安装Remi源："></a>一、安装Remi源：</h1><pre><code># CentOS 6 / RHEL 6
yum install http://rpms.famillecollet.com/enterprise/remi-release-6.rpm
# CentOS 7 / RHEL 7
yum install http://rpms.remirepo.net/enterprise/remi-release-7.rpm
</code></pre>
<h1 id="二、配置Remi源-可以不操作-："><a href="#二、配置Remi源-可以不操作-：" class="headerlink" title="二、配置Remi源(可以不操作)："></a>二、配置Remi源(可以不操作)：</h1><pre><code> 编辑remi源repo文件 /etc/yum.repos.d/remi.repo
 启用 Remi Repository修改 enabled=0 为 enabled=1。
 为 Remi Repository 设置合适的优先级在 [remi] 那一节的结尾另起一行添加下面的代码：
 priority=3    
</code></pre>
<h1 id="三、安装-php"><a href="#三、安装-php" class="headerlink" title="三、安装 php"></a>三、安装 php</h1><pre><code> yum install php73 php73-php-fpm php73-php-opcache php73-php-gd php73-php-mbstring php73-php-xml php73-php-pdo php73-php-mysqlnd php73-php-pecl-mysql php73-php-bcmath
php73-php-mcrypt   
</code></pre>
<h1 id="四-开机启动"><a href="#四-开机启动" class="headerlink" title="四.开机启动"></a>四.开机启动</h1><pre><code>systemctl enable  php73-php-fpm
</code></pre>
<h1 id="五-服务相关命令"><a href="#五-服务相关命令" class="headerlink" title="五.服务相关命令"></a>五.服务相关命令</h1><pre><code>systemctl start  php73-php-fpm
systemctl stop  php73-php-fpm
systemctl status  php73-php-fpm
</code></pre>
<h1 id="六-加入系统命令"><a href="#六-加入系统命令" class="headerlink" title="六.加入系统命令"></a>六.加入系统命令</h1><pre><code>ln -s  /opt/remi/php73/root/usr/bin/php /usr/bin/php
</code></pre>
<h1 id="七-添加用户"><a href="#七-添加用户" class="headerlink" title="七.添加用户"></a>七.添加用户</h1><pre><code>groupadd www
useradd -g www -s /sbin/nologin www
    
</code></pre>
<h1 id="八-PHP-FPM配置文件www-conf"><a href="#八-PHP-FPM配置文件www-conf" class="headerlink" title="八.PHP-FPM配置文件www.conf"></a>八.PHP-FPM配置文件<a href="http://www.conf/">www.conf</a></h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[www]</span><br><span class="line"></span><br><span class="line">user = www</span><br><span class="line">group = www</span><br><span class="line"></span><br><span class="line">;listen = 127.0.0.1:9000</span><br><span class="line">listen = /dev/shm/php71-fpm.socket</span><br><span class="line"></span><br><span class="line">listen.owner = www</span><br><span class="line">listen.group = www</span><br><span class="line">listen.mode = 0660</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">listen.allowed_clients = 127.0.0.1</span><br><span class="line"></span><br><span class="line">#如果选择static，则进程数就数固定的，由pm.max_children指定固定的子进程数。</span><br><span class="line">pm = static</span><br><span class="line">pm.max_children = 256</span><br><span class="line">pm.start_servers = 5</span><br><span class="line">#随着php-fpm一起启动时创建的子进程数目。默认值：min_spare_servers + (max_spare_servers - min_spare_servers) / 2。</span><br><span class="line">#这里表示，一起启动会有20个子进程</span><br><span class="line">pm.min_spare_servers = 5</span><br><span class="line">#设置服务器空闲时最小php-fpm进程数量。必须设置。如果空闲的时候，会检查如果少于10个，就会启动几个来补上。</span><br><span class="line">pm.max_spare_servers = 35</span><br><span class="line">#设置服务器空闲时最大php-fpm进程数量。必须设置。如果空闲时，会检查进程数，多于30个了，就会关闭几个，达到30个的状态。</span><br><span class="line">pm.max_requests = 5000</span><br><span class="line">#设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. </span><br><span class="line">#如果设置为 &#x27;0&#x27; 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0.</span><br><span class="line">pm.status_path = /php7-php-fpm-status</span><br><span class="line"></span><br><span class="line">#当request_slowlog_timeout 设为一个具体秒时request_slowlog_timeout =5，表</span><br><span class="line">#示如果哪个脚本执行时间大于5秒，会记录这个脚本到慢日志文件中</span><br><span class="line">request_slowlog_timeout =10</span><br><span class="line">slowlog = /var/opt/remi/php71/log/php-fpm/www-slow.log</span><br><span class="line"></span><br><span class="line">php_admin_value[error_log] = /var/opt/remi/php71/log/php-fpm/www-error.log</span><br><span class="line">php_admin_flag[log_errors] = on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">php_value[session.save_handler] = files</span><br><span class="line">php_value[session.save_path]    = /var/opt/remi/php71/lib/php/session</span><br><span class="line">php_value[soap.wsdl_cache_dir]  = /var/opt/remi/php71/lib/php/wsdlcache</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="九、php-ini配置文件"><a href="#九、php-ini配置文件" class="headerlink" title="九、php.ini配置文件"></a>九、php.ini配置文件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#关闭PHP版本信息</span><br><span class="line">expose_php = On</span><br><span class="line"></span><br><span class="line">#.单个脚本等待输入的最长时间</span><br><span class="line">max_input_time = 60</span><br><span class="line"></span><br><span class="line">memory_limit = 128M</span><br><span class="line">error_reporting = E_ALL &amp; ~E_DEPRECATED &amp; ~E_STRICT</span><br><span class="line"></span><br><span class="line">#每个脚本最大允许执行时间(秒)，0表示没有限制</span><br><span class="line">max_execution_time = 300</span><br><span class="line"></span><br><span class="line">#上传文件的最大许可大小</span><br><span class="line">upload_max_filesize = 20M</span><br><span class="line"></span><br><span class="line">#post上传的大小，要&gt;=upload_max_filesize</span><br><span class="line">post_max_size = 20M</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#修改成如下设置：</span><br><span class="line">session.save_handler = memcache</span><br><span class="line">session.save_path = &quot;tcp://10.0.0.18:11211&quot;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>redis基础</title>
    <url>/posts/78b568c7.html</url>
    <content><![CDATA[<h1 id="redis-简介"><a href="#redis-简介" class="headerlink" title="redis 简介"></a>redis 简介</h1><p>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储<br>Redis支持数据的备份，即master-slave模式的数据备份</p>
<p>Redis是单进程的</p>
<h1 id="redis-持久化方案"><a href="#redis-持久化方案" class="headerlink" title="redis 持久化方案"></a>redis 持久化方案</h1><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>三种写回策略<br>always，同步写回，每个子命令执行完，都立即将日志写回磁盘。</p>
<p>everysec，每个命令执行完，只是先把日志写到AOF内存缓冲区，每隔一秒同步到磁盘。</p>
<p>no：只是先把日志写到AOF内存缓冲区，有操作系统去决定何时写入磁盘</p>
<p>数据保证：我们可以设置fsync策略，一般默认是everysec，也可以设置每次写入追加，<br>所以即使服务死掉了，也最多丢失一秒数据</p>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>体积更小：相同的数据量rdb数据比aof的小，因为rdb是紧凑型文件。<br>恢复更快：因为rdb是数据的快照，基本上就是数据的复制，不用重新读取再写入内存。<br>性能更高:父进程在保存rdb时候只需要fork一个子进程，无需父进程的进行其他io操作，也保证了服务器的性能。</p>
<h2 id="如何选择RDB和AOF"><a href="#如何选择RDB和AOF" class="headerlink" title="如何选择RDB和AOF"></a>如何选择RDB和AOF</h2><p>如果数据不能丢失，RDB和AOF混用<br>如果只作为缓存使用，可以承受几分钟的数据丢失的话，可以只使用RDB。<br>如果只使用AOF，优先使用everysec的写回策略。</p>
<h1 id="RDB-快照-持久化-配置"><a href="#RDB-快照-持久化-配置" class="headerlink" title="RDB(快照)持久化 配置"></a>RDB(快照)持久化 配置</h1><pre><code>#   900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）  
#   300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）  
#   60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化） 
save 900 1  
save 300 10  
save 60 10000 


#在默认情况下，如果RDB快照持久化操作被激活（至少一个条件被激活）并且持久化操作失败，Redis则会停止接受更新操作。  
#这样会让用户了解到数据没有被正确的存储到磁盘上。否则没人会注意到这个问题，可能会造成灾难。  
#  
#如果后台存储（持久化）操作进程再次工作，Redis会自动允许更新操作。  
#  
#然而，如果你已经恰当的配置了对Redis服务器的监视和备份，你也许想关掉这项功能。  
#如此一来即使后台保存操作出错,redis也仍然可以继续像平常一样工作。  
stop-writes-on-bgsave-error yes

#是否压缩数据
rdbcompression yes
#没有校验的RDB文件会有一个0校验位，来告诉加载代码跳过校验检查。  
rdbchecksum yes 
# 导出数据库的文件名称  
dbfilename dump.rdb

dir ./
</code></pre>
<h1 id="AOF-Append-Only-File-日志-配置"><a href="#AOF-Append-Only-File-日志-配置" class="headerlink" title="AOF(Append Only File 日志)  配置"></a>AOF(Append Only File 日志)  配置</h1><pre><code>appendonly yes
appendfilename &quot;appendonly_6379.aof&quot;
appendfsync everysec
1、不适用fsync模式，仅仅使用操作系统的写数据策略；（no）
2、总是启动用fsync；（always） 
3、每秒同步一次。（everyse）

#在rewrite的时候不进行fsync，避免响应过慢。为了避免丢数据建议设置成no
#rewrite操作时，appendfsync会被阻塞。如果当前AOF文件很大，
#那么相应的rewrite时间会变长，appendfsync被阻塞的时间也会更长
no-appendfsync-on-rewrite no

#AOF文件如果不执行rewrite，文件会不断的增长。
#可以设置达到一定量就开始执行rewrite，避免磁盘耗尽
auto-aof-rewrite-percentage 100

#过最后一次rewrite文件大小的百分比，如果设置为0表示不自动aof。
#如果数据量比较小，设置百分比就会一直执行rewrite，消耗信息，这时候就可以设置最小rewrite的大小。
auto-aof-rewrite-min-size 64mb

#如果redis异常推出，会导致aof不完整，
#如果设置为yes，启动时就会加载aof异常文件，如果设置为no，就不会加载，启动失败。
aof-load-truncated yes

#启动的时候使用rdb文件会加载数据比较快，再执行aof操作，可以减少数据加载时间
aof-use-rdb-preamble yes
</code></pre>
<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><pre><code>redis默认是没有使用守护进程进行运行。可以通过daemonize参数进行设置  
daemonize yes
loglevel notice
requirepass  密码

#有限时间内,移除那些TTL值最小的key,ttl最小代表最近要过期
maxmemory-policy  allkeys-lru

设置在执行淘汰策略时，要考虑的样本数量。
较大的样本数可以提高淘汰算法的准确性，但也会增加CPU负载。
默认值为5，您可以根据实际情况进行调整
maxmemory-samples 10

noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）
allkeys-lru：从所有key中使用LRU算法进行淘汰
volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰
allkeys-random：从所有key中随机淘汰数据
volatile-random：从设置了过期时间的key中随机淘汰
volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰

#用于设置慢查询的评定时间，也就是说超过此配置项的命令，
将会被当成慢操作记录在慢查询日志中，
它执行单位是微秒 (1 秒等于 1000000 微秒)
slowlog-log-slower-than:100

#用来配置慢查询日志的最大记录数
slowlog-max-len:100

#表示当 Redis 运行内存超过最大内存时，是否开启 lazy free 机制删除
lazyfree-lazy-eviction no 

#表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除
lazyfree-lazy-expire no 

#有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，
比如rename(修改key的名称) 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，
就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除
lazyfree-lazy-server-del no 

#针对 slave(从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，
会运行 flushall 来清理自己的数据，
它表示此时是否开启 lazy free 机制删除
slave-lazy-flush no
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>shell脚本学习2</title>
    <url>/posts/8a98ccfe.html</url>
    <content><![CDATA[<p>搜索出当前目录下包含某个字符串的文件  并替换文件中的xx字符串为bb字符串<br>    sed -i “s/xx/bb/g” <code>grep -rl &quot;xx ./</code><br>    sed -i “s/http://121.229.56.251:8082/https://zkzp.jyrcfzjt.com:8082/g” <code>grep -rl &quot;http://121.229.56.251:8082&quot; ./</code></p>
]]></content>
  </entry>
  <entry>
    <title>session和cookie</title>
    <url>/posts/2af5ddcd.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>通过vsftpd搭建ftp服务器</title>
    <url>/posts/40a34212.html</url>
    <content><![CDATA[<p>1.yum 安装</p>
<pre><code>yum install vsftpd
</code></pre>
<p>2.编译安装</p>
<pre><code>yum -y install epel-release &amp;&amp; yum -y install pam pam-devel db4-utils
wget https://security.appspot.com/downloads/vsftpd-3.0.5.tar.gz

tar xf vsftpd-3.0.3.tar.gz

make clean &amp;&amp; make -j 4 &amp;&amp; make install


如果编译的时候报错
/usr/bin/ld: cannot find -lcap
查找该 .so 文件
find / -name &quot;*libcap.so*&quot;
/usr/lib64/libcap.so.2.22
/usr/lib64/libcap.so.2
ln -sv /usr/lib64/libcap.so.2 /usr/lib64/libcap.so
</code></pre>
<p>3./etc/vsftpd/vsftp.conf  配置文件    </p>
<pre><code>配置文件  vsftp.conf 
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#关闭匿名访问</span><br><span class="line">anonymous_enable=NO</span><br><span class="line">local_enable=YES</span><br><span class="line">#启用虚拟账户</span><br><span class="line">guest_enable=YES</span><br><span class="line">##把虚拟账户映射到系统账户virftp</span><br><span class="line">guest_username=virftp</span><br><span class="line">##使用虚拟用户验证（PAM验证）</span><br><span class="line">pam_service_name=vsftpd</span><br><span class="line">#设置存放各虚拟用户配置文件的目录（此目录下与虚拟用户名相同的文件为他的配置文件）</span><br><span class="line">user_config_dir=/etc/vsftpd/vsftpd_viruser</span><br><span class="line">##启用chroot时，虚拟用户根目录允许写入</span><br><span class="line">allow_writeable_chroot=YES</span><br><span class="line"></span><br><span class="line"># Uncomment this to enable any form of FTP write command.</span><br><span class="line">write_enable=YES</span><br><span class="line">#</span><br><span class="line"># Default umask for local users is 077. You may wish to change this to 022,</span><br><span class="line"># if your users expect that (022 is used by most other ftpd&#x27;s)</span><br><span class="line">local_umask=022</span><br><span class="line">#监听端口 默认21</span><br><span class="line">listen_port=10021</span><br><span class="line">#数据传输端口 默认20</span><br><span class="line">ftp_data_port=10020</span><br><span class="line"></span><br><span class="line">#被动模式 配置</span><br><span class="line">pasv_enable=YES</span><br><span class="line">pasv_min_port=20000</span><br><span class="line">pasv_max_port=20010</span><br><span class="line"># 可以发送消息当访问某个目录时</span><br><span class="line">dirmessage_enable=YES</span><br><span class="line"># 开启上传下载记录</span><br><span class="line">xferlog_enable=YES</span><br><span class="line"># 日志标准输出</span><br><span class="line">xferlog_std_format=YES</span><br><span class="line"></span><br><span class="line">connect_from_port_20=YES</span><br><span class="line">#监听ipv4</span><br><span class="line">listen=NO</span><br><span class="line"># 监听IPv6和监听IPv4</span><br><span class="line">listen_ipv6=YES</span><br><span class="line"></span><br><span class="line">userlist_enable=YES</span><br><span class="line"># 访问控制</span><br><span class="line">tcp_wrappers=YES</span><br></pre></td></tr></table></figure>
<p><strong>注意 根据需求自行修改<b><i>vsftp.conf</i></b>端口号以及模式：</strong><br><font color="#FF0000">#监听端口 默认21<br/>listen_port=10021<br/>#数据传输端口 默认20<br/>ftp_data_port=10020<br/>#被动模式 配置<br/>pasv_enable=YES<br/>pasv_min_port=20000<br/> pasv_max_port=20010<br/></font> </p>
<p>4、生成虚拟用户数据库：</p>
<pre><code>touch /etc/vsftpd/vir_user
vir_user文件内容：
    user1
    password1
    user2
    password2

yum -y install libdb-utils
db_load -T -t hash -f /etc/vsftpd/vir_user /etc/vsftpd/vir_user.db
chmod 700 /etc/vsftpd/vir_user.db
</code></pre>
<p>5、将auth及account的所有配置行均注释掉，添加如下两行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/pam.d/vsftpd</span><br><span class="line"></span><br><span class="line">auth                 required     pam_userdb.so   db=/etc/vsftpd/vir_user </span><br><span class="line">account              required     pam_userdb.so   db=/etc/vsftpd/vir_user</span><br></pre></td></tr></table></figure>

<p>6、增加一个系统用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /home/ftproot</span><br><span class="line">useradd -d /home/ftproot -s /sbin/nologin virftp</span><br><span class="line">chown -R virftp:virftp /home/ftproot</span><br></pre></td></tr></table></figure>

<p>7、创建和配置虚拟用户各自的配置文件，文件名称是‘虚拟用户名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/vsftpd/vsftpd_viruser/根据创建虚拟用户密码文件来(user1,user2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#允许写入</span><br><span class="line">write_enable=YES</span><br><span class="line">#允许浏览FTP目录和下载</span><br><span class="line">anon_world_readable_only=NO</span><br><span class="line">#允许虚拟用户上传文件</span><br><span class="line">anon_upload_enable=YES</span><br><span class="line">#允许虚拟用户创建目录</span><br><span class="line">anon_mkdir_write_enable=YES</span><br><span class="line">#允许虚拟用户执行其他操作（如改名、删除）</span><br><span class="line">anon_other_write_enable=YES</span><br><span class="line">#上传文件的掩码,如022时，上传目录权限为755,文件权限为644</span><br><span class="line">anon_umask=022</span><br><span class="line">#指定虚拟用户的虚拟目录（虚拟用户登录后的主目录） 可以指定其他目录  注意权限（给虚拟账号权限chown -R virftp:virftp 目录）</span><br><span class="line">local_root=/ftproot/admin/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>8、各配置文件说明：</p>
<pre><code>/etc/vsftpd/vsftpd.conf                             ：vsftpd的主配置文件
/etc/vsftpd/vir_user                                   ：虚拟用户的账号密码文件  
/etc/vsftpd/vsftpd_viruser/user1            ：虚拟用户‘user1’的配置文件
/etc/pam.d/vsftpd                                     ：启用虚拟用户验证功能的配置文件
</code></pre>
<p>9、命令</p>
<pre><code>rename [filename]  [newfilename]，重命名远程Linux FTP服务器上指定的文件｡
rename 1111.xlsx   processed/1111.xlsx
</code></pre>
]]></content>
      <categories>
        <category>server</category>
      </categories>
  </entry>
  <entry>
    <title>shell脚本学习1</title>
    <url>/posts/13919d44.html</url>
    <content><![CDATA[<p>开头声明</p>
<pre><code>#!/bin/bash   表示使用bash作为解释器来执行shell脚本

#!/bin/sh     表示使用默认的Unix shell解释器

#!/usr/bin/perl表示使用Perl解释器
</code></pre>
<p>赋值</p>
<pre><code>语法：变量名=值
webpath=/apps/web  等号必须紧挨变量 不然会报错！
</code></pre>
<p>取变量值</p>
<pre><code>语法：$变量名  
例：$webpath
</code></pre>
<p>取命令执行的值</p>
<pre><code>   语法：$(命令) 
   例：
        test=$(ls /apps/web)
        projectnames=$(ls $webpath)
        
</code></pre>
<p>遍历</p>
<pre><code>语法：   for  值 in 数组
         do
            执行代码
         done    
         
 例：
    for projectname in $projectnames
    do
        echo $projectname
    done          
    
    
</code></pre>
<p>逻辑判断</p>
<pre><code>语法
    if [ 判断条件]
    then
       执行代码
    fi   

    if [ 判断条件];then
        执行代码
    fi
    
    
    
if [ command ];then
     符合该条件执行的语句
elif [ command ];then
     符合该条件执行的语句
else
     符合该条件执行的语句
fi
</code></pre>
<p>if文件判断</p>
<pre><code> -e：判断文件或目录是否存在；
 
 -d：判断是否为目录以及是否存在；
 
 -f：判断是否为普通文件以及是否存在；
 
 -r：判断是否有读权限；
 
 -w：判断是否有写权限；
 
 -x：判断是否有执行权限     
 
</code></pre>
<p>if字符串判断</p>
<pre><code>[ INT1 -eq INT2 ] INT1和INT2两数相等返回为真 ,=
[ INT1 -ne INT2 ] INT1和INT2两数不等返回为真 ,&lt;&gt;
[ INT1 -gt INT2 ] INT1大于INT2返回为真 ,&gt;
[ INT1 -ge INT2 ] INT1大于等于INT2返回为真,&gt;=
[ INT1 -lt INT2 ] INT1小于INT2返回为真 ,&lt;
[ INT1 -le INT2 ] INT1小于等于INT2返回为真,&lt;=
</code></pre>
<p>if数值判断</p>
<pre><code>[ ! EXPR ] 逻辑非，如果 EXPR 是false则返回为真。
[ EXPR1 -a EXPR2 ] 逻辑与，如果 EXPR1 and EXPR2 全真则返回为真。
[ EXPR1 -o EXPR2 ] 逻辑或，如果 EXPR1 或者 EXPR2 为真则返回为真。
[ ] || [ ] 用OR来合并两个条件
[ ] &amp;&amp; [ ] 用AND来合并两个条件
</code></pre>
<p>if判断示例</p>
<pre><code>if [ -f $replacefile1 ] &amp;&amp; [ ! -f $replacefile1&quot;.bak&quot; ]
then
    执行代码
fi
             
             
if [ &quot;$(whoami)&quot; != &#39;root&#39; ]; then
   echo  &quot;You  have no permission to run $0 as non-root user.&quot;
   exit  1;
fi             
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>springboot学习</title>
    <url>/posts/8a82885c.html</url>
    <content><![CDATA[<h2 id="创建基于springboot-项目"><a href="#创建基于springboot-项目" class="headerlink" title="创建基于springboot 项目"></a>创建基于springboot 项目</h2><h2 id="1-maven方式"><a href="#1-maven方式" class="headerlink" title="1.maven方式"></a>1.maven方式</h2><pre><code>pom.xml文件加入

  &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.6&lt;/version&gt;
   &lt;/parent&gt;
   
   
   &lt;dependencies&gt;
       &lt;!-- Web 依赖 --&gt;
       &lt;dependency&gt;
           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
       &lt;/dependency&gt;
       &lt;!-- Web 依赖 --&gt;
   &lt;/dependencies&gt;

更新库就可以
</code></pre>
<h2 id="2-通过官网的spring-initializr安装"><a href="#2-通过官网的spring-initializr安装" class="headerlink" title="2. 通过官网的spring initializr安装"></a>2. 通过官网的spring initializr安装</h2><pre><code>https://start.spring.io/  
</code></pre>
<h2 id="3-idea旗舰版-新建时-可以选"><a href="#3-idea旗舰版-新建时-可以选" class="headerlink" title="3.idea旗舰版 新建时 可以选"></a>3.idea旗舰版 新建时 可以选</h2><h2 id="Spring-Boot-应用启动类，"><a href="#Spring-Boot-应用启动类，" class="headerlink" title="Spring Boot 应用启动类，"></a>Spring Boot 应用启动类，</h2><p> 在package创建类加上@SpringBootApplication</p>
<pre><code>package com.zysstudy;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class StartApplication &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(StartApplication.class,args);
    &#125;

&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>ubuntu搭建lnmp环境</title>
    <url>/posts/a7094d11.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>web安全</title>
    <url>/posts/def64e49.html</url>
    <content><![CDATA[<h1 id="php安全配置"><a href="#php安全配置" class="headerlink" title="php安全配置"></a>php安全配置</h1><pre><code>主要控制php执行危险函数，默认是关闭：Off
sql.safe_mode=On
禁止显示PHP版本号
expose_php = Off
关闭重定向执行php文件（你的网站url/as=你的网站url/sdf/muma.php）
cgi.force_redirect = 0
禁止解析非法php文件
cgi.fix_pathinfo = 0
关闭错误信息输出
display_error = Off
error_reporting = E_WARNING &amp; E_ERROR
记录错误日志至后台, 方便追溯
log_errors = On
error_log = /var/log/php_error.log
禁止远程执行phpshell
allow_url_include = Off
静止file_get_content函数获取资源
allow_url_fopen = Off
格式化时间
date.timezone=Asia/Shanghai
</code></pre>
<h1 id="nginx安全配置"><a href="#nginx安全配置" class="headerlink" title="nginx安全配置"></a>nginx安全配置</h1><pre><code>add_header X-Content-Type-Options nosniff;
add_header &#39;Referrer-Policy&#39; &#39;origin&#39;;
add_header X-Download-Options &quot;noopen&quot; always;
add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains; preload&quot;;
add_header X-Permitted-Cross-Domain-Policies  &quot;master-only&quot;;
add_header X-Frame-Options SAMEORIGIN;
#add_header Content-Security-Policy &quot;default-src &#39;self&#39; data: *.xxx.com  &#39;unsaf
add_header X-XSS-Protection &quot;1; mode=block&quot;;
# add_header Content-Security-Policy &quot;default-src *;style-src &#39;self&#39; &#39;unsafe-inline&#39;;script-src &#39;self&#39; &#39;unsafe-inline&#39; &#39;unsafe-eval&#39;;img-src * data:;worker-src * blob:;font-src &#39;self&#39; data:;&quot;


location / &#123;
    if ($http_origin ~* (https?://[^/]*\.kuaidasoft\.com))&#123;
              add_header &#39;Access-Control-Allow-Origin&#39; &quot;$http_origin&quot;;
    &#125;
    try_files $uri $uri/ /index.html;
&#125;  



#指定允许跨域的方法，*代表所有
add_header Access-Control-Allow-Methods &#39;GET,PUT,POST,DELETE,OPTIONS&#39;;

# 预检命令的缓存，如果不缓存每次会发送两次请求
add_header Access-Control-Max-Age 3600;

#带cookie请求需要加上这个字段，并设置为true
add_header Access-Control-Allow-Credentials true;

#   表示允许这个域跨域调用（客户端发送请求的域名和端口） 
#   $http_origin动态获取请求客户端请求的域   不用*的原因是带cookie的请求不支持*号
#add_header Access-Control-Allow-Origin $http_origin;
#   表示请求头的字段 动态获取
add_header Access-Control-Allow-Headers $http_access_control_request_headers;
</code></pre>
<h1 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h1>]]></content>
  </entry>
  <entry>
    <title>vue学习1</title>
    <url>/posts/5dd4fb79.html</url>
    <content><![CDATA[<h1 id="vuecli-vue脚手架"><a href="#vuecli-vue脚手架" class="headerlink" title="vuecli  vue脚手架"></a>vuecli  vue脚手架</h1><pre><code>vue 它是一个插件  最基础的项目架构 帮集成webpack 构建 打包 编译 包含基本的架子

安装命令：    npm install -g @vue/cli
            npm i -g @vue/cli
            -g      表示全局安装


查看脚手架版本         vue --version
</code></pre>
<h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><pre><code>vue create [项目名称]
默认安装项   [babel]  编译es6的语法    [eslint]     项目语法检查  可开关


vue ui 启动vue ui操作界面
</code></pre>
<h1 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h1><pre><code>/src/assets  目录存放 icon 图片
/src/api     存放  api  文件夹
/src/util    存放  一些工具方法
/src/storage 存放 数据存储的工具箱
/src/pages
/src/router.js
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>webpack学习笔记1</title>
    <url>/posts/30bc514d.html</url>
    <content><![CDATA[<p>#1. webpack 安装</p>
<pre><code>全局安装 nodejs
    验证  node -v
          npm -v
npm install webpack -g
npm install webpack-cli -g
正常情况下 安装webpack-cli 会自动安装webpack
npm uninstall webpack -g 全局卸载

单独项目内安装
npm install webpack webpack-cli --save-dev
或者
npm install webpack webpack-cli -D

运行npx webpack -v   //注 npx 会在node_module文件夹中找

安装特定版本
npm info webpack   //查看webpack有那些版本
npm install webpack@4.16.5 webpack-cli -D
</code></pre>
<p>#2.webpack 基本使用</p>
<pre><code>npm init    增加package.json文件
npm init -y
</code></pre>
<p>#3.一些语法</p>
<pre><code>ES Module 模块引入方式
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>wordpress相关</title>
    <url>/posts/4aea2b73.html</url>
    <content><![CDATA[<h1 id="wordpress-迁移后还是访问之前的域名"><a href="#wordpress-迁移后还是访问之前的域名" class="headerlink" title="wordpress 迁移后还是访问之前的域名"></a>wordpress 迁移后还是访问之前的域名</h1><pre><code>1.找到 前缀_options 表修改 siteurl  home字段 
2.或者登录后台修改
</code></pre>
<h1 id="wordpress-迁移后栏目打开是404"><a href="#wordpress-迁移后栏目打开是404" class="headerlink" title="wordpress 迁移后栏目打开是404"></a>wordpress 迁移后栏目打开是404</h1><pre><code>nginx加上如下配置

location / &#123;
 try_files $uri $uri/ /index.php?$args;
&#125;
# Add trailing slash to */wp-admin requests.
rewrite /wp-admin$ $scheme://$host$uri/ permanent;
</code></pre>
<h1 id="修改忘记密码-修改"><a href="#修改忘记密码-修改" class="headerlink" title="修改忘记密码 修改"></a>修改忘记密码 修改</h1><pre><code>修改 前缀_users 表    user_pass 字段 
MD5 加密
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>web备份方案</title>
    <url>/posts/13c1c2ab.html</url>
    <content><![CDATA[<h2 id="一、服务器环境"><a href="#一、服务器环境" class="headerlink" title="一、服务器环境"></a>一、服务器环境</h2><pre><code>    192.168.100.230 web服务器
    192.168.100.20  备份服务器 （rsync服务端）
</code></pre>
<h2 id="二、备份服务器安装-rsync-服务端"><a href="#二、备份服务器安装-rsync-服务端" class="headerlink" title="二、备份服务器安装 rsync 服务端"></a>二、备份服务器安装 rsync 服务端</h2><pre><code>rpm -qa|grep rsync    //检查是否安装 rsync

yum install -y rsync

vim /etc/rsyncd.conf   //编辑rsyncd服务

rsyncd.conf配置文件如下
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#rsyncd.conf start</span><br><span class="line">uid = rsync                                </span><br><span class="line">gid = rsync</span><br><span class="line">use chroot=no</span><br><span class="line">max connections=200</span><br><span class="line">timeout = 300</span><br><span class="line">pid file = /var/run/rsyncd.pid</span><br><span class="line">lock file = /var/run/rsyncd.lock</span><br><span class="line">log file = /var/log/rsyncd.log</span><br><span class="line">ignore errors</span><br><span class="line">read only = false</span><br><span class="line">list = false </span><br><span class="line">hosts allow = 172.16.1.0/24</span><br><span class="line">#hosts deny = 0.0.0.0/32</span><br><span class="line">auth users = rsync_backup</span><br><span class="line">secrets file = /etc/rsync.password</span><br><span class="line">fake super = yes</span><br><span class="line">[backup]</span><br><span class="line">comment = &quot;backup dir by oldboy&quot;</span><br><span class="line">path = /home/backup  </span><br><span class="line">#备份的目录</span><br></pre></td></tr></table></figure>
<pre><code>创建rsync 服务管理用户
useradd -s /sbin/nologin -M rsync

创建数据备份存储目录
chown -R rsyn.rsync /home/backup

创建认证用户密码文件
echo &quot;rsync_backup:admin.123!@#$&quot;  &gt;/etc/rsync.password
chmod 600 /etc/rsync.password

启动rsync服务
systemctl start rsyncd       
</code></pre>
<h2 id="三、配置web-服务器端（192-168-100-230）"><a href="#三、配置web-服务器端（192-168-100-230）" class="headerlink" title="三、配置web 服务器端（192.168.100.230）"></a>三、配置web 服务器端（192.168.100.230）</h2><pre><code>    确认 rsync是否安装
        rpm -qa|grep rsync
    
    建立认证文件
    
        echo &quot;密码字符串（与rsync一致）&quot;  &gt;/etc/rsync.password
        chmod 600 /etc/rsync.password
    
    web01主机数据传输到backup主机测试测试传输
    
        Push: rsync [OPTION...] SRC... [USER@]HOST::DEST
        交互式：rsync -avz /etc/hosts  rsync_backup@172.16.1.41::backup
        非交互式：rsync -avz /etc/hosts  rsync_backup@172.16.1.41::backup --password-file=/etc/rsync.password
        
        
    shell 脚本
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objectFilename=(&#x27;文件夹名称&#x27;);</span><br><span class="line">sourcePath=&#x27;/apps/web/&#x27;;</span><br><span class="line">for(( i=0;i&lt;$&#123;#objectFilename[@]&#125;;i++)) </span><br><span class="line">do </span><br><span class="line">    tar zcf /home/backup/web/source/$&#123;objectFilename[i]&#125;-$(date +%Y-%m-%d).tar.gz -C $&#123;sourcePath&#125; $&#123;objectFilename[i]&#125;; </span><br><span class="line">    rsync -avz /home/backup/web/source/  rsync_backup@192.168.100.20::backup --password-file=/etc/rsync.password</span><br><span class="line">    rm -rf /home/backup/web/source/$&#123;objectFilename[i]&#125;-$(date +%Y-%m-%d).tar.gz</span><br><span class="line">done;</span><br></pre></td></tr></table></figure>

<h2 id="四、注意事项"><a href="#四、注意事项" class="headerlink" title="四、注意事项"></a>四、注意事项</h2><pre><code>特殊情况 总是提示权限问题修改 服务端

    uid = root                                
    gid = root
    fake super = no


脚本备份大文件有问题
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>升级openssh</title>
    <url>/posts/59b7aac2.html</url>
    <content><![CDATA[<h1 id="centos系统"><a href="#centos系统" class="headerlink" title="centos系统"></a>centos系统</h1><h2 id="查看是否安装openssh"><a href="#查看是否安装openssh" class="headerlink" title="查看是否安装openssh"></a>查看是否安装openssh</h2><pre><code>rpm -qa|grep openssh
有则卸载

卸载用rpm -e 如果出现依赖包导致无法卸载，在最后面加上--nodeps即可
rpm -e openssl --nodeps
yum remove openssh-server

卸载还可以手动删除
  /etc/init.d/sshd 
  /etc/ssh
  /usr/bin/ssh
  /usr/sbin/sshd
      
</code></pre>
<h2 id="查当前openssh版本是否需要升级"><a href="#查当前openssh版本是否需要升级" class="headerlink" title="查当前openssh版本是否需要升级"></a>查当前openssh版本是否需要升级</h2><pre><code>ssh -V
</code></pre>
<h2 id="备份配置文件"><a href="#备份配置文件" class="headerlink" title="备份配置文件"></a>备份配置文件</h2><pre><code>mv /etc/ssh /etc/ssh.bak
</code></pre>
<h2 id="下载最新版本"><a href="#下载最新版本" class="headerlink" title="下载最新版本"></a>下载最新版本</h2><pre><code>https://www.openssh.com/openbsd.html    
</code></pre>
<h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><pre><code>./configure \
  --prefix=/usr \
  --sysconfdir=/etc/ssh \
  --with-md5-passwords \
  --with-pam \
  --with-tcp-wrappers \
  --with-ssl-dir=/usr/local/ssl
  
  
  make &amp;&amp; make install
    
</code></pre>
<h2 id="修改相关配置"><a href="#修改相关配置" class="headerlink" title="修改相关配置"></a>修改相关配置</h2><pre><code>cp -p contrib/redhat/sshd.init /etc/init.d/sshd 

chmod u+x /etc/init.d/sshd 

/etc/init.d/sshd start 此命令后就加入systemctl

systemctl enable sshd 加入开机启动

# vim /etc/ssh/sshd_config
PermitRootLogin yes                #允许root账户登录，单root账户必须加上，其他的参数请自行修改
</code></pre>
<h2 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h2><pre><code>1.编译时报错

    configure: error: PAM headers not found
    
解决方法
    
    yum -y install pam-devel
    
    
2.编译别的目录，然后通过相应文件覆盖或者软连接方式更新
  如果密码正确 就是登录不上
  
  删除重装     
</code></pre>
<h1 id="ubutun系统"><a href="#ubutun系统" class="headerlink" title="ubutun系统"></a>ubutun系统</h1><h2 id="查看是否安装"><a href="#查看是否安装" class="headerlink" title="查看是否安装"></a>查看是否安装</h2><pre><code>dpkg --list|grep ssh
卸载
sudo apt-get remove openssh-server 
</code></pre>
<h2 id="编译过程参考centos即可"><a href="#编译过程参考centos即可" class="headerlink" title="编译过程参考centos即可"></a>编译过程参考centos即可</h2>]]></content>
  </entry>
  <entry>
    <title>奇怪问题总结</title>
    <url>/posts/c6f6fc00.html</url>
    <content><![CDATA[<p>#奇怪的问题</p>
<h2 id="无法访问php文件，总是报错-file-not-found"><a href="#无法访问php文件，总是报错-file-not-found" class="headerlink" title="无法访问php文件，总是报错 file not found"></a>无法访问php文件，总是报错 file not found</h2><pre><code>解决思路
    
    1.首先查询 文件是否存在
    2.查询nginx php访问的配置
    3.关闭selinux 
    
</code></pre>
<h2 id="配置ssh-免密码-登录总是提示需要输入密码"><a href="#配置ssh-免密码-登录总是提示需要输入密码" class="headerlink" title="配置ssh 免密码 登录总是提示需要输入密码"></a>配置ssh 免密码 登录总是提示需要输入密码</h2><pre><code>解决思路

    1.排查下authorized_keys 是否存在key
    2.排查/etc/sshd/sshd_config下是否关闭了 证书登录【PubkeyAuthentication no】
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>windows搭建apache+php+mysql5.6</title>
    <url>/posts/27e26578.html</url>
    <content><![CDATA[<h1 id="安装mysql服务"><a href="#安装mysql服务" class="headerlink" title="安装mysql服务"></a>安装mysql服务</h1><pre><code>1.下载地址：https://downloads.mysql.com/archives/community/

2.下载相应windows版本

3.解压后cmd cd到文件目录mysqld.exe  执行   mysqld.exe install【mysqld remove 移除服务 mysqld start 启动服务】

4.设置开机启动  然后再win+r 输入services.msc  打开后找到mysql 右键点击属性   将启动类型设置为自动即可

【注：期间不同版本可能会报奇奇怪怪的错，百度安装相关的版本vc库】

 1.缺少msvcr100.dll文件如何解决

 百度Visual C++ 2010 Redistributable Package 搜索相关 下载安装
</code></pre>
<h2 id="mysql-相关操作"><a href="#mysql-相关操作" class="headerlink" title="mysql 相关操作"></a>mysql 相关操作</h2><pre><code> 修改密码
 GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39;IDENTIFIED BY &#39;Storage@202312&#39; WITH GRANT OPTION;
</code></pre>
<h1 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a>安装php</h1><pre><code>1.下载地址：https://windows.php.net/downloads/releases/archives/

2.下载版本必须有  php7apache2_4.dll  vc版本最好跟apache的版本一样

3.配置php.ini 开启相应 扩展

4.测试是否能用  到相应目录 执行 php.exe -v


【注：期间不同版本可能会报奇奇怪怪的错，百度安装相关的版本vc库】

【注：建议放在c:\php目录，不然可能出现无法加载到ddl扩展】
</code></pre>
<h1 id="安装apache-服务器"><a href="#安装apache-服务器" class="headerlink" title="安装apache 服务器"></a>安装apache 服务器</h1><p>##apache 安装对接php<br>    下载：<a href="https://www.apachelounge.com/download/VC14/">https://www.apachelounge.com/download/VC14/</a></p>
<pre><code>到apache/config/httpd.conf文件
找到&lt;IfModule unixd_module&gt;配置行 在其上面添加

LoadModule php7_module C:/php/php7apache2_4.dll  【php7apache2_4.dll 不同版本不同  具体目录根据自己的配置】
AddType application/x-httpd-php .php .html .htm
PHPIniDir c:/php                                 【配置PHP所在目录  具体目录根据自己的配置】  


然后通过bin目录下   **httpd.exe  -t** 测试配置是否通过

bin目录下 ApacheMonitor.exe 可以用来启动关闭 httpd服务
</code></pre>
<h2 id="配置apache项目访问"><a href="#配置apache项目访问" class="headerlink" title="配置apache项目访问"></a>配置apache项目访问</h2><h3 id="1-配置项"><a href="#1-配置项" class="headerlink" title="1.配置项"></a>1.配置项</h3><pre><code>    httpd.exe -k install -n &quot;apache2.4&quot;



    1.ServerName     配置域名访问地址
    例：ServerName 192.168.100.34:8080    ServerName www.baidu.com
    
    2.ServerRoot  配置apache安装目录
    
             例     Define SRVROOT &quot;c:/httpd&quot;
                    ServerRoot &quot;$&#123;SRVROOT&#125;&quot;   
                             
    3.Listen      监听端口
    
             例     Listen 8080
             
    4.DocumentRoot    配置项目目录
    
             例：  DocumentRoot &quot;$&#123;SRVROOT&#125;/htdocs/jnyy.iguanwei.com/public&quot;
    
    5.&lt;Directory 目录&gt;
        权限
    &lt;/&gt;Directory&gt;
    配置目录权限相关
    
        例：
        &lt;Directory &quot;$&#123;SRVROOT&#125;/htdocs/jnyy.iguanwei.com/public&quot;&gt;
                    Options Indexes FollowSymLinks
                    AllowOverride All
                    Require all granted
         &lt;/Directory&gt;
         
    6.配置默认访问文件
    
        &lt;IfModule dir_module&gt;
              DirectoryIndex  index.php index.html
        &lt;/IfModule&gt;     
     
</code></pre>
<h3 id="vhost配置示例"><a href="#vhost配置示例" class="headerlink" title="vhost配置示例"></a>vhost配置示例</h3><pre><code>主配置文件httpd.conf
LoadModule rewrite_module modules/mod_rewrite.so

LoadModule vhost_alias_module modules/mod_vhost_alias.so

Include conf/extra/httpd-vhosts.conf
    
</code></pre>
<h4 id="vhost配置文件"><a href="#vhost配置文件" class="headerlink" title="vhost配置文件"></a>vhost配置文件</h4><pre><code>    &lt;VirtualHost *:8081&gt;
            ServerAdmin webmaster@localhost
            DocumentRoot &quot;E:/wwwroot/storage/public&quot;
            DirectoryIndex index.php
            ErrorLog &quot;logs/storage-error.log&quot;
            CustomLog &quot;logs/storage-access.log&quot; common
            &lt;Directory &quot;E:/wwwroot/storage/public&quot;&gt;
              Options Indexes FollowSymLinks
              AllowOverride all
              Require all granted
              DirectoryIndex index.php index.html
              ;图片等 资源可下载
              AddType application/octet-stream .jpg .jpeg .png .gif .mp4 .avi .mov .flv
            &lt;/Directory&gt;
    &lt;/VirtualHost&gt;
    
    
    
    
    &lt;VirtualHost *:8082&gt;
            ServerAdmin webmaster@localhost
            DocumentRoot &quot;E:/wwwroot/storage-web&quot;
            DirectoryIndex index.html
            ErrorLog &quot;logs/storage-web-error.log&quot;
            CustomLog &quot;logs/storage-web-access.log&quot; common
            &lt;Directory &quot;E:/wwwroot/storage-web&quot;&gt;
              Options Indexes FollowSymLinks
              AllowOverride all
              Require all granted
              DirectoryIndex  index.html
            &lt;/Directory&gt;
    &lt;/VirtualHost&gt;
    
    
    
</code></pre>
<h3 id="2-php伪静态"><a href="#2-php伪静态" class="headerlink" title="2.php伪静态"></a>2.php伪静态</h3><pre><code>1. httpd.conf配置文件 启动rewrite模块 如下：

    LoadModule rewrite_module modules/mod_rewrite.so


2.项目根目录.htaccess文件配置入下  没有则新建

    &lt;IfModule mod_rewrite.c&gt;
     RewriteEngine on
     RewriteBase /
     RewriteCond %&#123;REQUEST_FILENAME&#125; !-d
     RewriteCond %&#123;REQUEST_FILENAME&#125; !-f
     RewriteRule ^(.*)$ index.php?s=/$1 [QSA,PT,L]
    &lt;/IfModule&gt;


3.对应apache  httpd.conf配置文件

     AllowOverride All

    &lt;Directory 项目目录&gt;
                            Options Indexes FollowSymLinks
                            AllowOverride All
                            Require all granted
    &lt;/Directory&gt;
    
</code></pre>
<h3 id="3-vue项目伪静态"><a href="#3-vue项目伪静态" class="headerlink" title="3.vue项目伪静态"></a>3.vue项目伪静态</h3><pre><code>&lt;IfModule mod_rewrite.c&gt;
    RewriteEngine On
    RewriteBase /
    RewriteRule ^index\.html$ - [L]
    RewriteCond %&#123;REQUEST_FILENAME&#125; !-f
    RewriteCond %&#123;REQUEST_FILENAME&#125; !-d
    RewriteRule . /index.html [L]
&lt;/ifModule&gt;          
</code></pre>
<h3 id="配置开机启动"><a href="#配置开机启动" class="headerlink" title="配置开机启动"></a>配置开机启动</h3><pre><code>   1.将apache加入windows服务   
   
        apache的bin目录下 执行 httpd.exe -thttpd.exe -k install -n &quot;apache2.4&quot;
   
   
   2.设置开机启动  然后再win+r 输入services.msc  打开后找到mysql 右键点击属性   将启动类型设置为自动即可
   
</code></pre>
<h1 id="apache相关知识"><a href="#apache相关知识" class="headerlink" title="apache相关知识"></a>apache相关知识</h1><h2 id="windows下apache常用命令"><a href="#windows下apache常用命令" class="headerlink" title="windows下apache常用命令"></a>windows下apache常用命令</h2><pre><code>httpd -k install                           安装apache服务
httpd -k uninstall                         移除apache服务

httpd -k start                             启动apache服务
httpd -k restart                           重启apache服务
httpd -k stop                              关闭已安装的apache服务

httpd -v                                   查看apache版本
httpd -t                                   查看apache配置文件状态    
</code></pre>
<h2 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h2><pre><code>网站根目录下创建  .htaccess  文件

1) R[=code](force redirect)  #强制外部重定向
强制在替代字符串加上http://thishost[:thisport]/前缀重定向到外部的URL.如果code不指定，将用缺省的302 HTTP状态码。
2) F(force URL to be forbidden)  #禁用URL,返回403HTTP状态码。
3) G(force URL to be gone)  # 强制URL为GONE，返回410HTTP状态码。
4) P(force proxy) # 强制使用代理转发。
5) L(last rule) # 表明当前规则是最后一条规则，停止分析以后规则的重写。
6) N(next round) # 重新从第一条规则开始运行重写过程。
7) C(chained with next rule) # 与下一条规则关联
如果规则匹配则正常处理，该标志无效，如果不匹配，那么下面所有关联的规则都跳过。
8) T=MIME-type(force MIME type) # 强制MIME类型
9) NS (used only if no internal sub-request) # 只用于不是内部子请求
10) NC(no case) # 不区分大小写
11) QSA(query string append) # 追加请求字符串
12) NE(no URI escaping of output) # 不在输出转义特殊字符
例如：RewriteRule /foo/(.*) /bar?arg=P1%3d$1 [R,NE] # 将能正确的将/foo/zoo转换成/bar?arg=P1=zoo
13) PT(pass through to next handler) # 传递给下一个处理
例如：
RewriteRule ^/abc(.*) /def$1 [PT] # 将会交给/def规则处理
Alias /def /ghi
14) S=num(skip next rule(s)) # 跳过num条规则
15) E=VAR:VAL(set environment variable) # 设置环境变量
</code></pre>
<h2 id="HTTP-跳转至-HTTPS-示例"><a href="#HTTP-跳转至-HTTPS-示例" class="headerlink" title="HTTP 跳转至 HTTPS 示例"></a>HTTP 跳转至 HTTPS 示例</h2><pre><code>RewriteEngine on  # 开启重写
RewriteCond %&#123;SERVER_PORT&#125; !^443$  # 如果访问的不是 443 端口
RewriteCond %&#123;REQUEST_URI&#125; !^/tz.php  #如果访问的url 不是 /tz.php
RewriteRule (.*) https://%&#123;SERVER_NAME&#125;/$1 [R]     # 跳转到  https：//域名+$1
</code></pre>
<h2 id="HTTP-80-强制转-HTTPS"><a href="#HTTP-80-强制转-HTTPS" class="headerlink" title="HTTP 80 强制转 HTTPS"></a>HTTP 80 强制转 HTTPS</h2><pre><code>RewriteEngine On
RewriteCond %&#123;SERVER_PORT&#125; 80  # 如果访问的是80 端口
RewriteRule ^(.*)$ https://%&#123;HTTP_HOST&#125;/$1 [R,L]  # 跳转 https 
</code></pre>
<h2 id="强制301重定向-HTTPS"><a href="#强制301重定向-HTTPS" class="headerlink" title="强制301重定向 HTTPS"></a>强制301重定向 HTTPS</h2><pre><code>&lt;IfModule mod_rewrite.c&gt;
RewriteEngine on
RewriteBase /  # 表示项目根目录
RewriteCond %&#123;SERVER_PORT&#125; !^443$  # 如果访问的不是443 端口
RewriteRule (.*) https://%&#123;SERVER_NAME&#125;/$1 [R=301,L]  # 重定向到 301
&lt;/IfModule&gt;
</code></pre>
<h2 id="重命名目录"><a href="#重命名目录" class="headerlink" title="重命名目录"></a>重命名目录</h2><pre><code>RewriteRule   ^/?old_directory/([a-z\.]+)$   new_directory/$1   [R=301,L]
</code></pre>
<h2 id="图片防盗链"><a href="#图片防盗链" class="headerlink" title="图片防盗链"></a>图片防盗链</h2><p>   RewriteCond   %{HTTP_REFERER}   !^$ # 如果上个页面地址为空<br>   RewriteCond    %{HTTP_REFERER}   !^http://(www.)?example.com/   [NC]    #或者不是来自你自己的域名<br>   RewriteRule   .(gif|jpg|png)$   - [F]  #禁止访问</p>
<h2 id="如果文件不存在重定向到404页面"><a href="#如果文件不存在重定向到404页面" class="headerlink" title="如果文件不存在重定向到404页面"></a>如果文件不存在重定向到404页面</h2><pre><code>RewriteCond   %&#123;REQUEST_FILENAME&#125;   !-f  # 如果访问的不是一个文件
RewriteCond   %&#123;REQUEST_FILENAME&#125;   !-d  #如果访问的不是一个目录
RewriteRule   .?   /404.php   [L]   #跳转到网站根目录
# 也可携带参数
#RewriteRule ^/?(.*)$ /404.php?url=$1 [L]
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>云主机硬盘扩容</title>
    <url>/posts/18f37986.html</url>
    <content><![CDATA[<h1 id="1-查看分区容量是否增加"><a href="#1-查看分区容量是否增加" class="headerlink" title="1.查看分区容量是否增加"></a>1.查看分区容量是否增加</h1><pre><code>lsblk
</code></pre>
<h1 id="2-扩容MBR分区和ext4文件系统"><a href="#2-扩容MBR分区和ext4文件系统" class="headerlink" title="2. 扩容MBR分区和ext4文件系统"></a>2. 扩容MBR分区和ext4文件系统</h1><pre><code>#redhat类系统
type growpart || sudo yum install -y cloud-utils-growpart

#debian类系统
type growpart || sudo apt-get install -y cloud-guest-utils

sudo LC_ALL=en_US.UTF-8 growpart /dev/vdb 1

sudo resize2fs /dev/vdb1
</code></pre>
<h1 id="3-扩容GPT分区和xfs文件系统"><a href="#3-扩容GPT分区和xfs文件系统" class="headerlink" title="3. 扩容GPT分区和xfs文件系统"></a>3. 扩容GPT分区和xfs文件系统</h1><pre><code>sudo apt-get update
type growpart || sudo apt-get install -y cloud-guest-utils

type sgdisk || sudo yum install -y gdisk
# 扩容分区
sudo LC_ALL=en_US.UTF-8 growpart /dev/vdb 2

#扩容文件系统
type xfs_growfs || sudo yum install -y xfsprogs
sudo xfs_growfs /mnt
</code></pre>
<h1 id="4-扩容裸数据盘"><a href="#4-扩容裸数据盘" class="headerlink" title="4.扩容裸数据盘"></a>4.扩容裸数据盘</h1><pre><code>sudo resize2fs /dev/vdb
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>搭建nps内网穿透</title>
    <url>/posts/a04b492d.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>内网穿透的方式有很多种，什么Frp、Ngrok、NPS、蒲公英等等，</p>
<h1 id="NPS简介"><a href="#NPS简介" class="headerlink" title="NPS简介"></a>NPS简介</h1><p>nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，<br>可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），<br>此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端</p>
<h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><pre><code>配置docker阿里云 镜像
yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
    
yum install docker-ce docker-ce-cli containerd.io
</code></pre>
<h1 id="安装nps"><a href="#安装nps" class="headerlink" title="安装nps"></a>安装nps</h1><pre><code>拉取镜像
docker pull ffdfgdfg/nps

添加配置文件
创建nps挂载文件目录(自己随意设置)
mkdir -p /docker/nps/conf

配置下载地址 https://github.com/ehang-io/nps/blob/master/conf
修改刚下载的conf文件夹里的/docker/nps/conf/nps.conf文件：

web_host=a.o.com   #修改为你的域名admin.nps.youdomain.com
web_username=admin 
web_password=123   #修改为一个强密码，毕竟是放在公网上的服务
web_port = 8090    访问的端口号
web_ip=0.0.0.0


运行nps
docker run -d   --restart=always --name nps --net=host -v /docker/nps/conf:/conf ffdfgdfg/nps
</code></pre>
<h1 id="客户端安装npc"><a href="#客户端安装npc" class="headerlink" title="客户端安装npc"></a>客户端安装npc</h1><pre><code>拉取npc镜像
docker pull ffdfgdfg/npc


docker run -d --restart=always --name npc-227 --net=host ffdfgdfg/npc -server=111.231.69.227:8024 -vkey=dle31e3ry1yl616p
【参数 -server 服务端获取  -vkey 服务端获取】 
</code></pre>
<h1 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h1><pre><code>http://ip/8090  账号密码 配置文件中   
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>守护进程-supervisor</title>
    <url>/posts/28b7458e.html</url>
    <content><![CDATA[<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><pre><code>yum install supervisor    #centos 系统

apt install supervisor    #ubuntu 系统
</code></pre>
<h1 id="二、配置守护进程"><a href="#二、配置守护进程" class="headerlink" title="二、配置守护进程"></a>二、配置守护进程</h1><p><font color='red'>在/etc/supervisord.d/下新建后缀名为ini的文件</font></p>
<pre><code>; 设置进程的名称，使用 supervisorctl 来管理进程时需要使用该进程名
[program:myblog] 
directory = /home/web/myblog          ; 程序的启动目录
command=./start.sh start              ; 启动命令 最好绝对路径
autostart = true                      ; 在 supervisord 启动的时候也自动启动
numprocs=1                            ; 默认为1
RestartSec=30
process_name=%(program_name)s         ; 默认为 %(program_name)s，即 [program:x] 中的 x
user=root                             ; 使用 root 用户来启动该进程
autorestart=true                      ; 程序崩溃时自动重启，重启次数是有限制的，默认为3次
redirect_stderr=true                  ; 重定向输出的日志
stderr_logfile= /home/web/myblog/myblog_stderr.log
stdout_logfile = /home/web/myblog/myblog_stdout.log
loglevel=info
</code></pre>
<h1 id="三、supervisord管理"><a href="#三、supervisord管理" class="headerlink" title="三、supervisord管理"></a>三、supervisord管理</h1><pre><code>systemctl status  supervisord
systemctl start  supervisord  
systemctl stop  supervisord  
systemctl restart  supervisord  
</code></pre>
<h1 id="四、supervisorctl管理"><a href="#四、supervisorctl管理" class="headerlink" title="四、supervisorctl管理"></a>四、supervisorctl管理</h1><pre><code>supervisorctl start server:myblog
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>搭建openvpn</title>
    <url>/posts/224c29d4.html</url>
    <content><![CDATA[<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><h2 id="1-1、安装epel库和openvpn软件"><a href="#1-1、安装epel库和openvpn软件" class="headerlink" title="1.1、安装epel库和openvpn软件"></a>1.1、安装epel库和openvpn软件</h2><pre><code>yum -y install openvpn easy-rsa firewalld

yum install epel-release -y
</code></pre>
<h2 id="1-2、开启路由转发"><a href="#1-2、开启路由转发" class="headerlink" title="1.2、开启路由转发"></a>1.2、开启路由转发</h2><pre><code> echo  &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt;/etc/sysctl.conf
 sysctl -p
</code></pre>
<h2 id="1-3、创建OpenVPN相关的密钥"><a href="#1-3、创建OpenVPN相关的密钥" class="headerlink" title="1.3、创建OpenVPN相关的密钥"></a>1.3、创建OpenVPN相关的密钥</h2><pre><code> cp -rf /usr/share/easy-rsa/3.0/* /etc/openvpn/easy-rsa/
 cp -p /usr/share/doc/easy-rsa-3.0.6/vars.example /etc/openvpn/easy-rsa/vars
 cd /etc/openvpn/easy-rsa/
</code></pre>
<h3 id="1-3-1、创建ca证书"><a href="#1-3-1、创建ca证书" class="headerlink" title="1.3.1、创建ca证书"></a>1.3.1、创建ca证书</h3><pre><code>/usr/share/easy-rsa/3/easyrsa init-pki
/usr/share/easy-rsa/3/easyrsa build-ca nopass
</code></pre>
<h3 id="1-3-2、创建client证书和签名"><a href="#1-3-2、创建client证书和签名" class="headerlink" title="1.3..2、创建client证书和签名"></a>1.3..2、创建client证书和签名</h3><pre><code>/usr/share/easy-rsa/3/easyrsa gen-req client1 nopass           #Enter
/usr/share/easy-rsa/3/easyrsa sign-req client client1          #需要输入yes
创建dh、tls、crl（证书撤销秘钥）
/usr/share/easy-rsa/3/easyrsa gen-dh
openvpn --genkey --secret /etc/openvpn/easy-rsa/ta.key
/usr/share/easy-rsa/3/easyrsa  gen-crl
</code></pre>
<h3 id="1-3-3、将秘钥拷贝至相应目录"><a href="#1-3-3、将秘钥拷贝至相应目录" class="headerlink" title="1.3.3、将秘钥拷贝至相应目录"></a>1.3.3、将秘钥拷贝至相应目录</h3><pre><code>cp -p pki/ca.crt /etc/openvpn/server/
cp -p pki/issued/server1.crt /etc/openvpn/server/
cp -p pki/private/server1.key /etc/openvpn/server/
cp -p ta.key /etc/openvpn/server/
cp -p pki/ca.crt /etc/openvpn/client/
cp -p pki/issued/client1.crt /etc/openvpn/client/
cp -p pki/private/client1.key /etc/openvpn/client/
cp -p ta.key /etc/openvpn/client/
cp pki/dh.pem /etc/openvpn/server/
cp pki/crl.pem /etc/openvpn/server/
cp /usr/share/doc/openvpn-2.4.11/sample/sample-config-files/server.conf /etc/openvpn/
</code></pre>
<h1 id="二、配置-openvpn"><a href="#二、配置-openvpn" class="headerlink" title="二、配置 openvpn"></a>二、配置 openvpn</h1><h2 id="2-1、编辑配置文件-etc-openvpn-server-conf"><a href="#2-1、编辑配置文件-etc-openvpn-server-conf" class="headerlink" title="2.1、编辑配置文件 /etc/openvpn/server.conf"></a>2.1、编辑配置文件 /etc/openvpn/server.conf</h2><pre><code>cp /usr/share/doc/openvpn-2.4.11/sample/sample-config-files/server.conf /etc/openvpn/      
#拷贝实例修改或直接拷贝以下内容
vim /etc/openvpn/server.conf

local 0.0.0.0    #监听地址
port 1194        #监听端口
proto tcp        #监听协议
dev tun          #采用路由隧道模式
ca /etc/openvpn/server/ca.crt              #ca证书路径
cert /etc/openvpn/server/server1.crt       #服务器证书
key /etc/openvpn/server/server1.key        #服务器秘钥
dh /etc/openvpn/server/dh.pem              #密钥交换协议文件
#####注意在设备中加一条到10.100.100.0虚拟网段的路由！！！！
server 10.100.100.0 255.255.255.0          
####给客户端分配地址池，注意：不能和VPN服务器内网网段有相同
#####注意在设备中加一条到10.100.100.0虚拟网段的路由！！！！
ifconfig-pool-persist ipp.txt
#push &quot;redirect-gateway def1 bypass-dhcp&quot;      #推送默认路由（所有流量走vpn）
push &quot;route 192.168.0.0 255.255.255.0&quot;           
#推送客户端常用路由（根据自己内网网段来写或修改客户端配置添加路由）
push &quot;dhcp-option DNS 192.168.5.251&quot;           #dhcp分配dns
client-to-client       #客户端之间互相通信
keepalive 10 120       #存活时间，10秒ping一次,120 如未收到响应则视为断线
comp-lzo               #传输数据压缩
max-clients 100        #最多允许 100 客户端连接
user openvpn           #用户
group openvpn          #用户组
cipher AES-256-CBC     #加密方式--客户端必须一致
persist-key
persist-tun
status /var/log/openvpn-status.log
log         /var/log/openvpn.log
verb 3
#以下参数为用户认证使用
script-security 3
auth-user-pass-verify /etc/openvpn/checkpsw.sh via-env    #指定用户认证脚本
username-as-common-name
verify-client-cert none
</code></pre>
<h2 id="2-2虚拟网段的路由"><a href="#2-2虚拟网段的路由" class="headerlink" title="2.2虚拟网段的路由"></a>2.2虚拟网段的路由</h2><pre><code>iptables -t nat -A POSTROUTING -s 10.100.100.0/24 -j MASQUERADE


firewall-cmd --add-masquerade --permanent
firewall-cmd --query-masquerade --permanent

firewall-cmd --zone=public --add-rich-rule=&#39;rule family=&quot;ipv4&quot; source address=&quot;10.100.100.0/24&quot; port protocol=&quot;tcp&quot; accept&#39;
firewall-cmd --zone=public --add-rich-rule=&#39;rule family=&quot;ipv4&quot; source address=&quot;10.100.100.0/24&quot; port protocol=&quot;udp&quot; accept&#39;
firewall-cmd --zone=public --add-masquerade
</code></pre>
<h1 id="三、用户认证"><a href="#三、用户认证" class="headerlink" title="三、用户认证"></a>三、用户认证</h1><h2 id="3-1编写用户认证脚本文件-脚本是由openvpn官网提供"><a href="#3-1编写用户认证脚本文件-脚本是由openvpn官网提供" class="headerlink" title="3.1编写用户认证脚本文件 (脚本是由openvpn官网提供)"></a>3.1编写用户认证脚本文件 (脚本是由openvpn官网提供)</h2><pre><code>vim /etc/openvpn/checkpsw.sh
#!/bin/sh
###########################################################
# checkpsw.sh (C) 2004 Mathias Sundman 
# This script will authenticate OpenVPN users against
# a plain text file. The passfile should simply contain
# one row per user with the username first followed by
# one or more space(s) or tab(s) and then the password.

PASSFILE=&quot;/etc/openvpn/psw-file&quot;
LOG_FILE=&quot;/etc/openvpn/openvpn-password.log&quot;
TIME_STAMP=`date &quot;+%Y-%m-%d %T&quot;`
###########################################################

if [ ! -r &quot;$&#123;PASSFILE&#125;&quot; ]; then
  echo &quot;$&#123;TIME_STAMP&#125;: Could not open password file \&quot;$&#123;PASSFILE&#125;\&quot; for reading.&quot; &gt;&gt;$&#123;LOG_FILE&#125;
  exit 1
fi

CORRECT_PASSWORD=`awk &#39;!/^;/&amp;&amp;!/^#/&amp;&amp;$1==&quot;&#39;$&#123;username&#125;&#39;&quot;&#123;print $2;exit&#125;&#39; $&#123;PASSFILE&#125;`

if [ &quot;$&#123;CORRECT_PASSWORD&#125;&quot; = &quot;&quot; ]; then 
  echo &quot;$&#123;TIME_STAMP&#125;: User does not exist: username=\&quot;$&#123;username&#125;\&quot;, password=\&quot;$&#123;password&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;
  exit 1
fi

if [ &quot;$&#123;password&#125;&quot; = &quot;$&#123;CORRECT_PASSWORD&#125;&quot; ]; then 
  echo &quot;$&#123;TIME_STAMP&#125;: Successful authentication: username=\&quot;$&#123;username&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;
  exit 0
fi

echo &quot;$&#123;TIME_STAMP&#125;: Incorrect password: username=\&quot;$&#123;username&#125;\&quot;,     password=\&quot;$&#123;password&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;
exit 1
</code></pre>
<h2 id="3-2-加权限及添加用户账号"><a href="#3-2-加权限及添加用户账号" class="headerlink" title="3.2 加权限及添加用户账号"></a>3.2 加权限及添加用户账号</h2><pre><code>给脚本添加执行权限
chmod 755 /etc/openvpn/checkpsw.sh


编辑密码文件
vim /etc/openvpn/psw-file
tom  123456
Jerry 654321
#前面为用户名，后面为密码。 中间使用空格分开
</code></pre>
<h1 id="四、客户端配置"><a href="#四、客户端配置" class="headerlink" title="四、客户端配置"></a>四、客户端配置</h1><pre><code>client.ovpn

##---------以下为将ca.crt证书写入到客户端文件的方式（直接给一个client.ovpn文件即可）------------##
client
dev tun
proto tcp   #根据服务端的来
remote utnanjing.tpddns.cn 11194
resolv-retry infinite
nobind
persist-key
persist-tun
&lt;ca&gt;
-----BEGIN CERTIFICATE-----
MIIDNTCCAh2gAwIBAgIJAJgy1QReG9VmMA0GCSqGSIb3DQEBCwUAMBYxFDASBgNV
BAMMC0Vhc3ktUlNBIENBMB4XDTIzMDgyNDA5NTgzN1oXDTMzMDgyMTA5NTgzN1ow
FjEUMBIGA1UEAwwLRWFzeS1SU0EgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAw
ggEKAoIBAQDLutXX/OaN1muPGKQV2uiEaZbQy9F0PptJxM3ZTHdyn+HuQ/3xqYHz
z6hgIr2IjWtD5pqZXGMwIxbpNFKfPfJtwU5xpuUA6hxWV3yYtaXGsaLvFA0StL/N
P5/3VgL1KpdcivjMejgVCwX5CkN97hsS6uk9Z/PUB9OEAWygeRHS8CYQ37PhXmDC
h/1VeXWZDHJzxCD1fqoo2dB8MGFJjvg3FVQ0o8Gf0XE9cvj5dtk73f6AyiuYTeLL
nD8vY8jbCVGeLcnoDnduK6y6ZLFOUHWfEPH+a1jDFLpXIby0oo3yBWcldzaKJMzf
UP7HoczkDaUo5ykecDjxGkD8kpTmwyQPAgMBAAGjgYUwgYIwHQYDVR0OBBYEFPCY
FNHxZ/eBKLRh009Bm08j8zurMEYGA1UdIwQ/MD2AFPCYFNHxZ/eBKLRh009Bm08j
8zuroRqkGDAWMRQwEgYDVQQDDAtFYXN5LVJTQSBDQYIJAJgy1QReG9VmMAwGA1Ud
EwQFMAMBAf8wCwYDVR0PBAQDAgEGMA0GCSqGSIb3DQEBCwUAA4IBAQCYFaym5wCr
lti+7p9MqLm4UF7pOmZQ2NamZjP1cQuMh2SgdJphddZEhEUO5NOQms8gMJsZ3sd7
DIul+XkDcbhjKNNxD4oeXiITR8BgLsCkqtLStwWtOSLGxgHHWD3S+IBSM21A4Rxy
hE4VUr81i9XUM2lI7ml5RgCVTvbWosCnVFuXypaYs4/c1yJJ1I578M6oVWjahJOx
ENoeYYSI/V+2ySTtRQlW8HQEc4GhSeybhmXgrfLKhmHTVl/ZqZg5zp3kwBcnsrUQ
junuLBLMMYSLPXhJQFU/10EMxv/9AAdBGiO3RL0G2qYc0JF11qVpmD9nwP9f/YR3
Yvs7E2kwDViH
-----END CERTIFICATE-----
&lt;/ca&gt;
cipher AES-256-CBC
comp-lzo
verb 3
auth-user-pass              #使用用户名密码登录openvpn服务器
auth-nocache


证书方式

client
dev tun
proto tcp
remote 公网ipxxx.xxx.xxx.xxx 1194
resolv-retry infinite
nobind
persist-key
persist-tun
ca ca.crt
cert client1.crt  #拷贝自服务端
key client1.key   #拷贝自服务端 
remote-cert-tls server
cipher AES-256-CBC
comp-lzo
verb 3
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>搭建k8s</title>
    <url>/posts/6f994fe6.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>普通心理学笔记1</title>
    <url>/posts/257fa2ac.html</url>
    <content><![CDATA[<p>#心理学</p>
<pre><code>心理学研究行为和心理过程
一门多个专业领域的的科学
</code></pre>
<p>#心理学三大分支</p>
<pre><code>实验心理学 
    实验心理学家 最少的
心理学教学
    心理学教师
应用心理学
    工业与组织心理学家
    运动心里学家
    学校心理学家
    临床和咨询心理学家
    法医心理学家
    环境心理学家
</code></pre>
<p>#心理学与精神病学区别</p>
<pre><code>精神病学是医学 接受过治疗精神与行为疾病的训练
具有开具处方的执照
从医学角度看问题

心理学关注更为广泛 人类的行为和心理过程
大脑功能到社会交往
心里健康到心理障碍
心理学角度 来访者
</code></pre>
<p>#批判性思考技巧</p>
<pre><code>1.其来源出自哪里 问题的来源

    提出问题的人 是否擅长啊
    由于什么原因 提出了这个问题

2.这个观点是合理的还是极端的

3.证据是什么

4.是否有影响结论的偏差
    验证性偏差 只记得验证成功的那一面

5.推理是否避开了常见谬误
    避免 常识

6.看待这个问题是否需要多种角度
</code></pre>
]]></content>
      <categories>
        <category>心理学</category>
      </categories>
  </entry>
  <entry>
    <title>特殊的SQL语句</title>
    <url>/posts/ee8708d7.html</url>
    <content><![CDATA[<h1 id="使用逗号分割拆分"><a href="#使用逗号分割拆分" class="headerlink" title="使用逗号分割拆分"></a>使用逗号分割拆分</h1><p>查询出field字段中有value的记录<br>SELECT * FROM table WHERE FIND_IN_SET(‘value’, field)&gt;0</p>
<p> FIND_IN_SET(‘value’, field)<font color=Red>&gt;0</font>  查询的是字段中<font color=Red>包含了</font>查询字符value的<br> FIND_IN_SET(‘value’, field)<font color=Red>=0</font>   查询的是字段中<font color=Red>不包含</font>了查询字符value的</p>
<h1 id="SUBSTRING-INDEX-函数"><a href="#SUBSTRING-INDEX-函数" class="headerlink" title="SUBSTRING_INDEX 函数"></a>SUBSTRING_INDEX 函数</h1><p>string：用于截取目标字符串的字符串。可为字段，表达式等。</p>
<p>sep：分隔符，string存在且用于分割的字符，比如“，”、“.”等。</p>
<p>num：序号 <font color=Red>负数 从右边取   正数从左边取 取几个值</font></p>
<p>示例 field  a1,b2,c3<br>SUBSTRING_INDEX(field, ‘,’, 1) 取值就是 a1<br><font color=Red>SUBSTRING_INDEX(field, ‘,’, 2) 取值就是 a1,b2</font></p>
<p><font color=Red>根据，分割拆分多条数据sql：</font></p>
<pre><code>SELECT SUBSTRING_INDEX(field, &#39;,&#39;, 1) AS value1,
    SUBSTRING_INDEX(SUBSTRING_INDEX(field, &#39;,&#39;, 2), &#39;,&#39;, -1) AS value2,
    SUBSTRING_INDEX(SUBSTRING_INDEX(field, &#39;,&#39;, 3), &#39;,&#39;, -1) AS value3
    SUBSTRING_INDEX(field, &#39;,&#39;, -1) AS value4
FROM table
</code></pre>
<h2 id="根据，隔开字段-分组统计"><a href="#根据，隔开字段-分组统计" class="headerlink" title="根据，隔开字段 分组统计"></a>根据，隔开字段 分组统计</h2><p>根据，隔开字段拆分成多行数据 多会拆分成3行了</p>
<p>SELECT SUBSTRING_INDEX(SUBSTRING_INDEX(comInputField163, ‘,’,numbers.n), ‘,’, -1) AS tag ,numbers.n,a.*<br>      #,COUNT(*) AS count<br>FROM mida_gd_2023101116015948 a<br>JOIN (<br>  SELECT 1 AS n UNION ALL SELECT 2 UNION ALL SELECT 3                                   <font color=Red>#这边SELECT 数 根据，隔开最多项来，写到SELECT 5只有数据中只有2项它也要关联5个出来</font><br>) AS numbers<br>WHERE CHAR_LENGTH(comInputField163) - CHAR_LENGTH(REPLACE(comInputField163, ‘,’, ‘’)) &gt;= numbers.n-1  #通过这个来限制,<font color=Red>统计，数量</font> 判断需要几个<br>GROUP BY tag;</p>
<h1 id="两表连接的SQL语句"><a href="#两表连接的SQL语句" class="headerlink" title="两表连接的SQL语句"></a>两表连接的SQL语句</h1><p>select A.c1,A.c2,B.c1,B.c2<br>from table1 A,table2 B<br>where A.id=B.id</p>
<p>select A.c1,A.c2,B.c1,B.c2<br>from table1 A join table2 B<br>on A.id=B.id</p>
<p>select A.c1,A.c2,B.c1,B.c2<br>from table1 A inner join table2 B<br>on A.id=B.id</p>
<p>join on与inner join on是相同</p>
<p>默认JOIN就是指的INNER JOIN</p>
<p>内连接推荐 join 方式 通过where 的方式 性能较差<br>有的数据库底层 认为是交叉 连接</p>
]]></content>
  </entry>
  <entry>
    <title>vmvare-esxi虚拟机扩容</title>
    <url>/posts/undefined.html</url>
    <content><![CDATA[<p>修改硬盘大小</p>
<pre><code>先虚拟机管理页面修改硬盘大小
    注：不删除快照是 无法修改成功的
</code></pre>
<p>分区  </p>
<pre><code>fdisk /dev/sda    
n
p
默认确定
w
</code></pre>
<p>手动同步磁盘到系统内核</p>
<pre><code>partprobe
</code></pre>
<p>创建物理卷</p>
<pre><code>pvcreate /dev/sda3          #【/dev/sda3 是根据fdisk来的】
</code></pre>
<p>查看卷组</p>
<pre><code>vgdisplay
</code></pre>
<p>添加物理卷（/dev/sda3）到卷组（centos）</p>
<pre><code>vgextend centos /dev/sda3   #此处的centos根据vgdisplay查看得来
</code></pre>
<p>将空闲的空间都分配给root文件系统 </p>
<pre><code> lvextend -L +250G /dev/centos/root   【/dev/centos/root  就是要扩容的目录通过df 可查看】
</code></pre>
<p>对root文件系统执行扩容</p>
<pre><code>xfs_growfs /dev/centos/root
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>普通心理学笔记2</title>
    <url>/posts/bc76f316.html</url>
    <content><![CDATA[<h1 id="现代心理学6个视角"><a href="#现代心理学6个视角" class="headerlink" title="现代心理学6个视角"></a>现代心理学6个视角</h1><pre><code>起源：古希腊哲学家 苏格拉底 柏拉图 亚里士多德 意识和疯癫的理解
亚洲和非洲 瑜伽和佛教 探索意识 通过冥想控制意识
天主教
1.生物视角
    
    大脑、神经系统、内分泌系统（激素）和基因        笛卡尔

2.认知视角

    每个人有各自的知觉模式、解释、预期、信念和记忆   威廉。冯特 威廉詹姆斯     
    
3.行为视角
    
    环境的刺激和先前行为的结果                   约翰。华生 斯金纳

4.全人视角                                   弗洛伊德 古希腊   
    
    心理动力：无意识心理的过程
    人本主义
    特质和气质：

5.发展视角                                   安斯沃思

    遗传和环境的交互作用，在毕生发展中塑造
    
6.社会文化视角                                津巴多
    
    环境的影响。社会和文化比其他因素更能决定行为
</code></pre>
<p>笛卡尔 精神和肉体是分离的  由此生物学视角诞生</p>
<p>生物学主题</p>
<pre><code>神经科学
进化心理学
</code></pre>
<p>德国科学家  威廉 冯特 |内省法  格式塔心理学家</p>
<pre><code>科学心理学和现代认知视角的建立
元素周期表  研究自然世界的科学方法  结构主义
纳克立方体
</code></pre>
]]></content>
      <categories>
        <category>心理学</category>
      </categories>
  </entry>
  <entry>
    <title>高德地图-点位展示开发</title>
    <url>/posts/fa30932c.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>跨域问题总结</title>
    <url>/posts/54e89ac9.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
