<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yszhao的博客</title>
  
  <subtitle>记录我的生活 学习</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-11-01T03:13:31.043Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>yszhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>wordpress相关</title>
    <link href="http://example.com/2023/11/01/wordpress%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2023/11/01/wordpress%E7%9B%B8%E5%85%B3/</id>
    <published>2023-11-01T03:01:22.000Z</published>
    <updated>2023-11-01T03:13:31.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wordpress-迁移后还是访问之前的域名"><a href="#wordpress-迁移后还是访问之前的域名" class="headerlink" title="wordpress 迁移后还是访问之前的域名"></a>wordpress 迁移后还是访问之前的域名</h1><pre><code>1.找到 前缀_options 表修改 siteurl  home字段 2.或者登录后台修改</code></pre><h1 id="wordpress-迁移后栏目打开是404"><a href="#wordpress-迁移后栏目打开是404" class="headerlink" title="wordpress 迁移后栏目打开是404"></a>wordpress 迁移后栏目打开是404</h1><pre><code>nginx加上如下配置location / &#123; try_files $uri $uri/ /index.php?$args;&#125;# Add trailing slash to */wp-admin requests.rewrite /wp-admin$ $scheme://$host$uri/ permanent;</code></pre><h1 id="修改忘记密码-修改"><a href="#修改忘记密码-修改" class="headerlink" title="修改忘记密码 修改"></a>修改忘记密码 修改</h1><pre><code>修改 前缀_users 表    user_pass 字段 MD5 加密</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;wordpress-迁移后还是访问之前的域名&quot;&gt;&lt;a href=&quot;#wordpress-迁移后还是访问之前的域名&quot; class=&quot;headerlink&quot; title=&quot;wordpress 迁移后还是访问之前的域名&quot;&gt;&lt;/a&gt;wordpress 迁移后还是访问之前的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>docker学习4-网络</title>
    <link href="http://example.com/2023/10/26/docker%E5%AD%A6%E4%B9%A04-%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2023/10/26/docker%E5%AD%A6%E4%B9%A04-%E7%BD%91%E7%BB%9C/</id>
    <published>2023-10-26T13:56:52.000Z</published>
    <updated>2023-11-01T02:48:52.627Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理linux-network-namespace"><a href="#原理linux-network-namespace" class="headerlink" title="原理linux network namespace"></a>原理linux network namespace</h1><h1 id="docker-bridge-网络"><a href="#docker-bridge-网络" class="headerlink" title="docker  bridge 网络"></a>docker  bridge 网络</h1><h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><h2 id="自定义-docker-网络"><a href="#自定义-docker-网络" class="headerlink" title="自定义 docker 网络"></a>自定义 docker 网络</h2><h1 id="docker端口映射"><a href="#docker端口映射" class="headerlink" title="docker端口映射"></a>docker端口映射</h1><h1 id="docker-host-网络"><a href="#docker-host-网络" class="headerlink" title="docker host 网络"></a>docker host 网络</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理linux-network-namespace&quot;&gt;&lt;a href=&quot;#原理linux-network-namespace&quot; class=&quot;headerlink&quot; title=&quot;原理linux network namespace&quot;&gt;&lt;/a&gt;原理linux net</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux之LVM(逻辑卷管理)</title>
    <link href="http://example.com/2023/10/19/Linux%E4%B9%8BLVM-%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/10/19/Linux%E4%B9%8BLVM-%E9%80%BB%E8%BE%91%E5%8D%B7%E7%AE%A1%E7%90%86/</id>
    <published>2023-10-19T04:50:58.000Z</published>
    <updated>2023-10-19T04:50:58.587Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>mysql的常用应用</title>
    <link href="http://example.com/2023/10/17/mysql%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8/"/>
    <id>http://example.com/2023/10/17/mysql%E7%9A%84%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8/</id>
    <published>2023-10-17T02:12:16.000Z</published>
    <updated>2023-10-17T02:23:35.409Z</updated>
    
    <content type="html"><![CDATA[<p>#mysql忘记密码,重置密码</p><p>1.修改my.cnf</p><p>添加</p><pre><code>--skip-grant-tables</code></pre><p>2.进入数据</p><pre><code>执行use mysql;mysql&gt; update user set password=password(&#39;123&#39;) where user=&#39;root&#39; and host=&#39;localhost&#39;;mysql&gt; flush privileges;</code></pre><p>#mysql导出、导入数据命令</p><p>导出<br>mysqldump -u &lt;用户名&gt; -p&lt;密码&gt; &lt;数据库名&gt; &gt; &lt;输出文件路径&gt;</p><p>示例</p><pre><code> mysqldump  -u root -p wastewater.iguanwei.com &gt;bak.sql</code></pre><p>导入</p><pre><code>方法一：mysql -u用户名 -p 数据库名 &lt; 123.sql方法二：source 123.sql;</code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#mysql忘记密码,重置密码&lt;/p&gt;
&lt;p&gt;1.修改my.cnf&lt;/p&gt;
&lt;p&gt;添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--skip-grant-tables
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.进入数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;执行
use mysql;
mysql</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>php扩展安装</title>
    <link href="http://example.com/2023/10/16/php%E6%89%A9%E5%B1%95%E5%AE%89%E8%A3%85-1/"/>
    <id>http://example.com/2023/10/16/php%E6%89%A9%E5%B1%95%E5%AE%89%E8%A3%85-1/</id>
    <published>2023-10-16T10:54:48.000Z</published>
    <updated>2023-10-17T01:20:03.751Z</updated>
    
    <content type="html"><![CDATA[<p>#下载相应的扩展并phpize</p><pre><code>到扩展目录下执行phpize1.phpize 不是系统命令时候find / -name phpize 后找到相应版本的phpize2.报错can‘t find PHP headers in path/phpyum install -y php-devel</code></pre><h1 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h1><p> 项目目录下<br> 执行 ./configure</p><p> 1.报错：configure: error: Cannot find php-config. Please use –with-php-config=PATH</p><p> 执行 find / -name php-config</p><p> 找到相应版本php的 php-config</p><p> ./configure –with-php-config=【php-config路径】</p><h1 id="make-amp-amp-make-install"><a href="#make-amp-amp-make-install" class="headerlink" title="make &amp;&amp; make install"></a>make &amp;&amp; make install</h1><pre><code>执行成功后会提示.so文件的路径</code></pre><p> #配置php.ini</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#下载相应的扩展并phpize&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;到扩展目录下
执行phpize

1.phpize 不是系统命令时候

find / -name phpize 

后找到相应版本的phpize

2.报错can‘t find PHP headers in pa</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis基本数据结构</title>
    <link href="http://example.com/2023/09/26/redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2023/09/26/redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2023-09-26T10:47:44.000Z</published>
    <updated>2023-09-27T07:50:23.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><pre><code>Redis五大数据类型：String、Hash、List、Set、Sorted set</code></pre><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>String类型的最大能存储512M 应用场景 【缓存】</p><pre><code>1.SET key value [EX seconds] [PX milliseconds] [NX|XX]EX和PX参数可选，用于设置键的过期时间，单位分别为秒和毫秒NX表示只在键不存在时创建，XX表示只在键已存在时执行操作。将键 &quot;abc&quot; 设置为值 &quot;123&quot; 并设置过期时间为 12 秒    set abc 123 ex 122. MSET key1 value1 [key2 value2 ...]  设置多条     mset a 1 b 2        3.EXPIRE key seconds    设置过期时间4.SETEX key seconds value 可用于一次设置带有过期时间的键值对select命令切换数据库，分库的作用主要用来业务分片：dbsize查看当前数据库的key的数量flushdb清除当前库所有key(当前库)：</code></pre><h1 id="Hash-哈希表"><a href="#Hash-哈希表" class="headerlink" title="Hash(哈希表)"></a>Hash(哈希表)</h1><pre><code>hget：通过key值，从hash里取对应的valuehset：往hash里，添加key-valuehmsethmget：一次性获取多个key的valuehmset user:2 name:kati age 28 sex womanhmget user:2 name age sex</code></pre><h1 id="List-列表"><a href="#List-列表" class="headerlink" title="List(列表)"></a>List(列表)</h1><pre><code>lpush：从列表List的左边插入一个元素。lpop：从列表List的左边移出一个元素。rpush：从列表List的右边插入一个元素。rpop：从列表List的右边移出一个元素。llen：打印当前列表List中的元素个数。</code></pre><h1 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set(集合)"></a>Set(集合)</h1><h1 id="Sorted-set-有序集合"><a href="#Sorted-set-有序集合" class="headerlink" title="Sorted set(有序集合)"></a>Sorted set(有序集合)</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;Redis五大数据类型：String、Hash、List、Set、Sorted set
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>redis基础</title>
    <link href="http://example.com/2023/09/25/redis%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/09/25/redis%E5%9F%BA%E7%A1%80/</id>
    <published>2023-09-25T07:48:26.000Z</published>
    <updated>2023-09-26T09:51:45.632Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis-简介"><a href="#redis-简介" class="headerlink" title="redis 简介"></a>redis 简介</h1><p>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储<br>Redis支持数据的备份，即master-slave模式的数据备份</p><p>Redis是单进程的</p><h1 id="redis-持久化方案"><a href="#redis-持久化方案" class="headerlink" title="redis 持久化方案"></a>redis 持久化方案</h1><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>三种写回策略<br>always，同步写回，每个子命令执行完，都立即将日志写回磁盘。</p><p>everysec，每个命令执行完，只是先把日志写到AOF内存缓冲区，每隔一秒同步到磁盘。</p><p>no：只是先把日志写到AOF内存缓冲区，有操作系统去决定何时写入磁盘</p><p>数据保证：我们可以设置fsync策略，一般默认是everysec，也可以设置每次写入追加，<br>所以即使服务死掉了，也最多丢失一秒数据</p><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>体积更小：相同的数据量rdb数据比aof的小，因为rdb是紧凑型文件。<br>恢复更快：因为rdb是数据的快照，基本上就是数据的复制，不用重新读取再写入内存。<br>性能更高:父进程在保存rdb时候只需要fork一个子进程，无需父进程的进行其他io操作，也保证了服务器的性能。</p><h2 id="如何选择RDB和AOF"><a href="#如何选择RDB和AOF" class="headerlink" title="如何选择RDB和AOF"></a>如何选择RDB和AOF</h2><p>如果数据不能丢失，RDB和AOF混用<br>如果只作为缓存使用，可以承受几分钟的数据丢失的话，可以只使用RDB。<br>如果只使用AOF，优先使用everysec的写回策略。</p><h1 id="RDB-快照-持久化-配置"><a href="#RDB-快照-持久化-配置" class="headerlink" title="RDB(快照)持久化 配置"></a>RDB(快照)持久化 配置</h1><pre><code>#   900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）  #   300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）  #   60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化） save 900 1  save 300 10  save 60 10000 #在默认情况下，如果RDB快照持久化操作被激活（至少一个条件被激活）并且持久化操作失败，Redis则会停止接受更新操作。  #这样会让用户了解到数据没有被正确的存储到磁盘上。否则没人会注意到这个问题，可能会造成灾难。  #  #如果后台存储（持久化）操作进程再次工作，Redis会自动允许更新操作。  #  #然而，如果你已经恰当的配置了对Redis服务器的监视和备份，你也许想关掉这项功能。  #如此一来即使后台保存操作出错,redis也仍然可以继续像平常一样工作。  stop-writes-on-bgsave-error yes#是否压缩数据rdbcompression yes#没有校验的RDB文件会有一个0校验位，来告诉加载代码跳过校验检查。  rdbchecksum yes # 导出数据库的文件名称  dbfilename dump.rdbdir ./</code></pre><h1 id="AOF-Append-Only-File-日志-配置"><a href="#AOF-Append-Only-File-日志-配置" class="headerlink" title="AOF(Append Only File 日志)  配置"></a>AOF(Append Only File 日志)  配置</h1><pre><code>appendonly yesappendfilename &quot;appendonly_6379.aof&quot;appendfsync everysec1、不适用fsync模式，仅仅使用操作系统的写数据策略；（no）2、总是启动用fsync；（always） 3、每秒同步一次。（everyse）#在rewrite的时候不进行fsync，避免响应过慢。为了避免丢数据建议设置成no#rewrite操作时，appendfsync会被阻塞。如果当前AOF文件很大，#那么相应的rewrite时间会变长，appendfsync被阻塞的时间也会更长no-appendfsync-on-rewrite no#AOF文件如果不执行rewrite，文件会不断的增长。#可以设置达到一定量就开始执行rewrite，避免磁盘耗尽auto-aof-rewrite-percentage 100#过最后一次rewrite文件大小的百分比，如果设置为0表示不自动aof。#如果数据量比较小，设置百分比就会一直执行rewrite，消耗信息，这时候就可以设置最小rewrite的大小。auto-aof-rewrite-min-size 64mb#如果redis异常推出，会导致aof不完整，#如果设置为yes，启动时就会加载aof异常文件，如果设置为no，就不会加载，启动失败。aof-load-truncated yes#启动的时候使用rdb文件会加载数据比较快，再执行aof操作，可以减少数据加载时间aof-use-rdb-preamble yes</code></pre><h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><pre><code>redis默认是没有使用守护进程进行运行。可以通过daemonize参数进行设置  daemonize yesloglevel noticerequirepass  密码#有限时间内,移除那些TTL值最小的key,ttl最小代表最近要过期maxmemory-policy  allkeys-lru设置在执行淘汰策略时，要考虑的样本数量。较大的样本数可以提高淘汰算法的准确性，但也会增加CPU负载。默认值为5，您可以根据实际情况进行调整maxmemory-samples 10noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）allkeys-lru：从所有key中使用LRU算法进行淘汰volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰allkeys-random：从所有key中随机淘汰数据volatile-random：从设置了过期时间的key中随机淘汰volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰#用于设置慢查询的评定时间，也就是说超过此配置项的命令，将会被当成慢操作记录在慢查询日志中，它执行单位是微秒 (1 秒等于 1000000 微秒)slowlog-log-slower-than:100#用来配置慢查询日志的最大记录数slowlog-max-len:100#表示当 Redis 运行内存超过最大内存时，是否开启 lazy free 机制删除lazyfree-lazy-eviction no #表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除lazyfree-lazy-expire no #有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如rename(修改key的名称) 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除lazyfree-lazy-server-del no #针对 slave(从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除slave-lazy-flush no</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;redis-简介&quot;&gt;&lt;a href=&quot;#redis-简介&quot; class=&quot;headerlink&quot; title=&quot;redis 简介&quot;&gt;&lt;/a&gt;redis 简介&lt;/h1&gt;&lt;p&gt;Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建nps内网穿透</title>
    <link href="http://example.com/2023/08/29/%E6%90%AD%E5%BB%BAnps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <id>http://example.com/2023/08/29/%E6%90%AD%E5%BB%BAnps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</id>
    <published>2023-08-29T07:19:19.000Z</published>
    <updated>2023-08-29T07:57:04.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>内网穿透的方式有很多种，什么Frp、Ngrok、NPS、蒲公英等等，</p><h1 id="NPS简介"><a href="#NPS简介" class="headerlink" title="NPS简介"></a>NPS简介</h1><p>nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，<br>可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），<br>此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端</p><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><pre><code>配置docker阿里云 镜像yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo    yum install docker-ce docker-ce-cli containerd.io</code></pre><h1 id="安装nps"><a href="#安装nps" class="headerlink" title="安装nps"></a>安装nps</h1><pre><code>拉取镜像docker pull ffdfgdfg/nps添加配置文件创建nps挂载文件目录(自己随意设置)mkdir -p /docker/nps/conf配置下载地址 https://github.com/ehang-io/nps/blob/master/conf修改刚下载的conf文件夹里的/docker/nps/conf/nps.conf文件：web_host=a.o.com   #修改为你的域名admin.nps.youdomain.comweb_username=admin web_password=123   #修改为一个强密码，毕竟是放在公网上的服务web_port = 8090    访问的端口号web_ip=0.0.0.0运行npsdocker run -d   --restart=always --name nps --net=host -v /docker/nps/conf:/conf ffdfgdfg/nps</code></pre><h1 id="客户端安装npc"><a href="#客户端安装npc" class="headerlink" title="客户端安装npc"></a>客户端安装npc</h1><pre><code>拉取npc镜像docker pull ffdfgdfg/npcdocker run -d --restart=always --name npc-227 --net=host ffdfgdfg/npc -server=111.231.69.227:8024 -vkey=dle31e3ry1yl616p【参数 -server 服务端获取  -vkey 服务端获取】 </code></pre><h1 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h1><pre><code>http://ip/8090  账号密码 配置文件中   </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;内网穿透的方式有很多种，什么Frp、Ngrok、NPS、蒲公英等等，&lt;/p&gt;
&lt;h1 id=&quot;NPS简介&quot;&gt;&lt;a href=&quot;#NPS简介&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vmvare-esxi虚拟机扩容</title>
    <link href="http://example.com/2023/08/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%AE%B9/"/>
    <id>http://example.com/2023/08/28/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%89%A9%E5%AE%B9/</id>
    <published>2023-08-28T06:55:16.000Z</published>
    <updated>2023-08-28T07:19:29.037Z</updated>
    
    <content type="html"><![CDATA[<p>修改硬盘大小</p><pre><code>先虚拟机管理页面修改硬盘大小    注：不删除快照是 无法修改成功的</code></pre><p>分区  </p><pre><code>fdisk /dev/sda    np默认确定w</code></pre><p>手动同步磁盘到系统内核</p><pre><code>partprobe</code></pre><p>创建物理卷</p><pre><code>pvcreate /dev/sda3          #【/dev/sda3 是根据fdisk来的】</code></pre><p>查看卷组</p><pre><code>vgdisplay</code></pre><p>添加物理卷（/dev/sda3）到卷组（centos）</p><pre><code>vgextend centos /dev/sda3   #此处的centos根据vgdisplay查看得来</code></pre><p>将空闲的空间都分配给root文件系统 </p><pre><code> lvextend -L +250G /dev/centos/root   【/dev/centos/root  就是要扩容的目录通过df 可查看】</code></pre><p>对root文件系统执行扩容</p><pre><code>xfs_growfs /dev/centos/root</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;修改硬盘大小&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;先虚拟机管理页面修改硬盘大小
    注：不删除快照是 无法修改成功的
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;分区  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fdisk /dev/sda    
n
p
默认确定
w
&lt;/code&gt;&lt;/pre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搭建openvpn</title>
    <link href="http://example.com/2023/08/28/%E6%90%AD%E5%BB%BAopenvpn/"/>
    <id>http://example.com/2023/08/28/%E6%90%AD%E5%BB%BAopenvpn/</id>
    <published>2023-08-28T05:42:06.000Z</published>
    <updated>2023-08-28T06:52:47.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h1><h2 id="1-1、安装epel库和openvpn软件"><a href="#1-1、安装epel库和openvpn软件" class="headerlink" title="1.1、安装epel库和openvpn软件"></a>1.1、安装epel库和openvpn软件</h2><pre><code>yum -y install openvpn easy-rsa firewalldyum install epel-release -y</code></pre><h2 id="1-2、开启路由转发"><a href="#1-2、开启路由转发" class="headerlink" title="1.2、开启路由转发"></a>1.2、开启路由转发</h2><pre><code> echo  &quot;net.ipv4.ip_forward = 1&quot; &gt;&gt;/etc/sysctl.conf sysctl -p</code></pre><h2 id="1-3、创建OpenVPN相关的密钥"><a href="#1-3、创建OpenVPN相关的密钥" class="headerlink" title="1.3、创建OpenVPN相关的密钥"></a>1.3、创建OpenVPN相关的密钥</h2><pre><code> cp -rf /usr/share/easy-rsa/3.0/* /etc/openvpn/easy-rsa/ cp -p /usr/share/doc/easy-rsa-3.0.6/vars.example /etc/openvpn/easy-rsa/vars cd /etc/openvpn/easy-rsa/</code></pre><h3 id="1-3-1、创建ca证书"><a href="#1-3-1、创建ca证书" class="headerlink" title="1.3.1、创建ca证书"></a>1.3.1、创建ca证书</h3><pre><code>/usr/share/easy-rsa/3/easyrsa init-pki/usr/share/easy-rsa/3/easyrsa build-ca nopass</code></pre><h3 id="1-3-2、创建client证书和签名"><a href="#1-3-2、创建client证书和签名" class="headerlink" title="1.3..2、创建client证书和签名"></a>1.3..2、创建client证书和签名</h3><pre><code>/usr/share/easy-rsa/3/easyrsa gen-req client1 nopass           #Enter/usr/share/easy-rsa/3/easyrsa sign-req client client1          #需要输入yes创建dh、tls、crl（证书撤销秘钥）/usr/share/easy-rsa/3/easyrsa gen-dhopenvpn --genkey --secret /etc/openvpn/easy-rsa/ta.key/usr/share/easy-rsa/3/easyrsa  gen-crl</code></pre><h3 id="1-3-3、将秘钥拷贝至相应目录"><a href="#1-3-3、将秘钥拷贝至相应目录" class="headerlink" title="1.3.3、将秘钥拷贝至相应目录"></a>1.3.3、将秘钥拷贝至相应目录</h3><pre><code>cp -p pki/ca.crt /etc/openvpn/server/cp -p pki/issued/server1.crt /etc/openvpn/server/cp -p pki/private/server1.key /etc/openvpn/server/cp -p ta.key /etc/openvpn/server/cp -p pki/ca.crt /etc/openvpn/client/cp -p pki/issued/client1.crt /etc/openvpn/client/cp -p pki/private/client1.key /etc/openvpn/client/cp -p ta.key /etc/openvpn/client/cp pki/dh.pem /etc/openvpn/server/cp pki/crl.pem /etc/openvpn/server/cp /usr/share/doc/openvpn-2.4.11/sample/sample-config-files/server.conf /etc/openvpn/</code></pre><h1 id="二、配置-openvpn"><a href="#二、配置-openvpn" class="headerlink" title="二、配置 openvpn"></a>二、配置 openvpn</h1><h2 id="2-1、编辑配置文件-etc-openvpn-server-conf"><a href="#2-1、编辑配置文件-etc-openvpn-server-conf" class="headerlink" title="2.1、编辑配置文件 /etc/openvpn/server.conf"></a>2.1、编辑配置文件 /etc/openvpn/server.conf</h2><pre><code>cp /usr/share/doc/openvpn-2.4.11/sample/sample-config-files/server.conf /etc/openvpn/      #拷贝实例修改或直接拷贝以下内容vim /etc/openvpn/server.conflocal 0.0.0.0    #监听地址port 1194        #监听端口proto tcp        #监听协议dev tun          #采用路由隧道模式ca /etc/openvpn/server/ca.crt              #ca证书路径cert /etc/openvpn/server/server1.crt       #服务器证书key /etc/openvpn/server/server1.key        #服务器秘钥dh /etc/openvpn/server/dh.pem              #密钥交换协议文件#####注意在设备中加一条到10.100.100.0虚拟网段的路由！！！！server 10.100.100.0 255.255.255.0          ####给客户端分配地址池，注意：不能和VPN服务器内网网段有相同#####注意在设备中加一条到10.100.100.0虚拟网段的路由！！！！ifconfig-pool-persist ipp.txt#push &quot;redirect-gateway def1 bypass-dhcp&quot;      #推送默认路由（所有流量走vpn）push &quot;route 192.168.0.0 255.255.255.0&quot;           #推送客户端常用路由（根据自己内网网段来写或修改客户端配置添加路由）push &quot;dhcp-option DNS 192.168.5.251&quot;           #dhcp分配dnsclient-to-client       #客户端之间互相通信keepalive 10 120       #存活时间，10秒ping一次,120 如未收到响应则视为断线comp-lzo               #传输数据压缩max-clients 100        #最多允许 100 客户端连接user openvpn           #用户group openvpn          #用户组cipher AES-256-CBC     #加密方式--客户端必须一致persist-keypersist-tunstatus /var/log/openvpn-status.loglog         /var/log/openvpn.logverb 3#以下参数为用户认证使用script-security 3auth-user-pass-verify /etc/openvpn/checkpsw.sh via-env    #指定用户认证脚本username-as-common-nameverify-client-cert none</code></pre><h2 id="2-2虚拟网段的路由"><a href="#2-2虚拟网段的路由" class="headerlink" title="2.2虚拟网段的路由"></a>2.2虚拟网段的路由</h2><pre><code>iptables -t nat -A POSTROUTING -s 10.100.100.0/24 -j MASQUERADE</code></pre><h1 id="三、用户认证"><a href="#三、用户认证" class="headerlink" title="三、用户认证"></a>三、用户认证</h1><h2 id="3-1编写用户认证脚本文件-脚本是由openvpn官网提供"><a href="#3-1编写用户认证脚本文件-脚本是由openvpn官网提供" class="headerlink" title="3.1编写用户认证脚本文件 (脚本是由openvpn官网提供)"></a>3.1编写用户认证脚本文件 (脚本是由openvpn官网提供)</h2><pre><code>vim /etc/openvpn/checkpsw.sh#!/bin/sh############################################################ checkpsw.sh (C) 2004 Mathias Sundman # This script will authenticate OpenVPN users against# a plain text file. The passfile should simply contain# one row per user with the username first followed by# one or more space(s) or tab(s) and then the password.PASSFILE=&quot;/etc/openvpn/psw-file&quot;LOG_FILE=&quot;/etc/openvpn/openvpn-password.log&quot;TIME_STAMP=`date &quot;+%Y-%m-%d %T&quot;`###########################################################if [ ! -r &quot;$&#123;PASSFILE&#125;&quot; ]; then  echo &quot;$&#123;TIME_STAMP&#125;: Could not open password file \&quot;$&#123;PASSFILE&#125;\&quot; for reading.&quot; &gt;&gt;$&#123;LOG_FILE&#125;  exit 1fiCORRECT_PASSWORD=`awk &#39;!/^;/&amp;&amp;!/^#/&amp;&amp;$1==&quot;&#39;$&#123;username&#125;&#39;&quot;&#123;print $2;exit&#125;&#39; $&#123;PASSFILE&#125;`if [ &quot;$&#123;CORRECT_PASSWORD&#125;&quot; = &quot;&quot; ]; then   echo &quot;$&#123;TIME_STAMP&#125;: User does not exist: username=\&quot;$&#123;username&#125;\&quot;, password=\&quot;$&#123;password&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;  exit 1fiif [ &quot;$&#123;password&#125;&quot; = &quot;$&#123;CORRECT_PASSWORD&#125;&quot; ]; then   echo &quot;$&#123;TIME_STAMP&#125;: Successful authentication: username=\&quot;$&#123;username&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;  exit 0fiecho &quot;$&#123;TIME_STAMP&#125;: Incorrect password: username=\&quot;$&#123;username&#125;\&quot;,     password=\&quot;$&#123;password&#125;\&quot;.&quot; &gt;&gt; $&#123;LOG_FILE&#125;exit 1</code></pre><h2 id="3-2-加权限及添加用户账号"><a href="#3-2-加权限及添加用户账号" class="headerlink" title="3.2 加权限及添加用户账号"></a>3.2 加权限及添加用户账号</h2><pre><code>给脚本添加执行权限chmod 755 /etc/openvpn/checkpsw.sh编辑密码文件vim /etc/openvpn/psw-filetom  123456Jerry 654321#前面为用户名，后面为密码。 中间使用空格分开</code></pre><h1 id="四、客户端配置"><a href="#四、客户端配置" class="headerlink" title="四、客户端配置"></a>四、客户端配置</h1><pre><code>client.ovpn##---------以下为将ca.crt证书写入到客户端文件的方式（直接给一个client.ovpn文件即可）------------##clientdev tunproto tcp   #根据服务端的来remote utnanjing.tpddns.cn 11194resolv-retry infinitenobindpersist-keypersist-tun&lt;ca&gt;-----BEGIN CERTIFICATE-----MIIDNTCCAh2gAwIBAgIJAJgy1QReG9VmMA0GCSqGSIb3DQEBCwUAMBYxFDASBgNVBAMMC0Vhc3ktUlNBIENBMB4XDTIzMDgyNDA5NTgzN1oXDTMzMDgyMTA5NTgzN1owFjEUMBIGA1UEAwwLRWFzeS1SU0EgQ0EwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDLutXX/OaN1muPGKQV2uiEaZbQy9F0PptJxM3ZTHdyn+HuQ/3xqYHzz6hgIr2IjWtD5pqZXGMwIxbpNFKfPfJtwU5xpuUA6hxWV3yYtaXGsaLvFA0StL/NP5/3VgL1KpdcivjMejgVCwX5CkN97hsS6uk9Z/PUB9OEAWygeRHS8CYQ37PhXmDCh/1VeXWZDHJzxCD1fqoo2dB8MGFJjvg3FVQ0o8Gf0XE9cvj5dtk73f6AyiuYTeLLnD8vY8jbCVGeLcnoDnduK6y6ZLFOUHWfEPH+a1jDFLpXIby0oo3yBWcldzaKJMzfUP7HoczkDaUo5ykecDjxGkD8kpTmwyQPAgMBAAGjgYUwgYIwHQYDVR0OBBYEFPCYFNHxZ/eBKLRh009Bm08j8zurMEYGA1UdIwQ/MD2AFPCYFNHxZ/eBKLRh009Bm08j8zuroRqkGDAWMRQwEgYDVQQDDAtFYXN5LVJTQSBDQYIJAJgy1QReG9VmMAwGA1UdEwQFMAMBAf8wCwYDVR0PBAQDAgEGMA0GCSqGSIb3DQEBCwUAA4IBAQCYFaym5wCrlti+7p9MqLm4UF7pOmZQ2NamZjP1cQuMh2SgdJphddZEhEUO5NOQms8gMJsZ3sd7DIul+XkDcbhjKNNxD4oeXiITR8BgLsCkqtLStwWtOSLGxgHHWD3S+IBSM21A4RxyhE4VUr81i9XUM2lI7ml5RgCVTvbWosCnVFuXypaYs4/c1yJJ1I578M6oVWjahJOxENoeYYSI/V+2ySTtRQlW8HQEc4GhSeybhmXgrfLKhmHTVl/ZqZg5zp3kwBcnsrUQjunuLBLMMYSLPXhJQFU/10EMxv/9AAdBGiO3RL0G2qYc0JF11qVpmD9nwP9f/YR3Yvs7E2kwDViH-----END CERTIFICATE-----&lt;/ca&gt;cipher AES-256-CBCcomp-lzoverb 3auth-user-pass              #使用用户名密码登录openvpn服务器auth-nocache证书方式clientdev tunproto tcpremote 公网ipxxx.xxx.xxx.xxx 1194resolv-retry infinitenobindpersist-keypersist-tunca ca.crtcert client1.crt  #拷贝自服务端key client1.key   #拷贝自服务端 remote-cert-tls servercipher AES-256-CBCcomp-lzoverb 3</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、安装&quot;&gt;&lt;a href=&quot;#一、安装&quot; class=&quot;headerlink&quot; title=&quot;一、安装&quot;&gt;&lt;/a&gt;一、安装&lt;/h1&gt;&lt;h2 id=&quot;1-1、安装epel库和openvpn软件&quot;&gt;&lt;a href=&quot;#1-1、安装epel库和openvpn软件&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>springboot学习</title>
    <link href="http://example.com/2023/08/01/springboot%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/08/01/springboot%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-08-01T12:20:47.000Z</published>
    <updated>2023-08-02T02:27:33.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建基于springboot-项目"><a href="#创建基于springboot-项目" class="headerlink" title="创建基于springboot 项目"></a>创建基于springboot 项目</h2><h2 id="1-maven方式"><a href="#1-maven方式" class="headerlink" title="1.maven方式"></a>1.maven方式</h2><pre><code>pom.xml文件加入  &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.5.6&lt;/version&gt;   &lt;/parent&gt;         &lt;dependencies&gt;       &lt;!-- Web 依赖 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;!-- Web 依赖 --&gt;   &lt;/dependencies&gt;更新库就可以</code></pre><h2 id="2-通过官网的spring-initializr安装"><a href="#2-通过官网的spring-initializr安装" class="headerlink" title="2. 通过官网的spring initializr安装"></a>2. 通过官网的spring initializr安装</h2><pre><code>https://start.spring.io/  </code></pre><h2 id="3-idea旗舰版-新建时-可以选"><a href="#3-idea旗舰版-新建时-可以选" class="headerlink" title="3.idea旗舰版 新建时 可以选"></a>3.idea旗舰版 新建时 可以选</h2><h2 id="Spring-Boot-应用启动类，"><a href="#Spring-Boot-应用启动类，" class="headerlink" title="Spring Boot 应用启动类，"></a>Spring Boot 应用启动类，</h2><p> 在package创建类加上@SpringBootApplication</p><pre><code>package com.zysstudy;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class StartApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(StartApplication.class,args);    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建基于springboot-项目&quot;&gt;&lt;a href=&quot;#创建基于springboot-项目&quot; class=&quot;headerlink&quot; title=&quot;创建基于springboot 项目&quot;&gt;&lt;/a&gt;创建基于springboot 项目&lt;/h2&gt;&lt;h2 id=&quot;1-mav</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>升级openssh</title>
    <link href="http://example.com/2023/08/01/%E5%8D%87%E7%BA%A7openssh/"/>
    <id>http://example.com/2023/08/01/%E5%8D%87%E7%BA%A7openssh/</id>
    <published>2023-08-01T11:48:14.000Z</published>
    <updated>2023-08-01T12:09:29.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="centos系统"><a href="#centos系统" class="headerlink" title="centos系统"></a>centos系统</h1><h2 id="查看是否安装openssh"><a href="#查看是否安装openssh" class="headerlink" title="查看是否安装openssh"></a>查看是否安装openssh</h2><pre><code>rpm -qa|grep openssh有则卸载卸载用rpm -e 如果出现依赖包导致无法卸载，在最后面加上--nodeps即可rpm -e openssl --nodepsyum remove openssh-server卸载还可以手动删除  /etc/init.d/sshd   /etc/ssh  /usr/bin/ssh  /usr/sbin/sshd      </code></pre><h2 id="查当前openssh版本是否需要升级"><a href="#查当前openssh版本是否需要升级" class="headerlink" title="查当前openssh版本是否需要升级"></a>查当前openssh版本是否需要升级</h2><pre><code>ssh -V</code></pre><h2 id="备份配置文件"><a href="#备份配置文件" class="headerlink" title="备份配置文件"></a>备份配置文件</h2><pre><code>mv /etc/ssh /etc/ssh.bak</code></pre><h2 id="下载最新版本"><a href="#下载最新版本" class="headerlink" title="下载最新版本"></a>下载最新版本</h2><pre><code>https://www.openssh.com/openbsd.html    </code></pre><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><pre><code>./configure \  --prefix=/usr \  --sysconfdir=/etc/ssh \  --with-md5-passwords \  --with-pam \  --with-tcp-wrappers \  --with-ssl-dir=/usr/local/ssl      make &amp;&amp; make install    </code></pre><h2 id="修改相关配置"><a href="#修改相关配置" class="headerlink" title="修改相关配置"></a>修改相关配置</h2><pre><code>cp -p contrib/redhat/sshd.init /etc/init.d/sshd chmod u+x /etc/init.d/sshd /etc/init.d/sshd start 此命令后就加入systemctlsystemctl enable sshd 加入开机启动# vim /etc/ssh/sshd_configPermitRootLogin yes                #允许root账户登录，单root账户必须加上，其他的参数请自行修改</code></pre><h2 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h2><pre><code>1.编译时报错    configure: error: PAM headers not found    解决方法        yum -y install pam-devel        2.编译别的目录，然后通过相应文件覆盖或者软连接方式更新  如果密码正确 就是登录不上    删除重装     </code></pre><h1 id="ubutun系统"><a href="#ubutun系统" class="headerlink" title="ubutun系统"></a>ubutun系统</h1><h2 id="查看是否安装"><a href="#查看是否安装" class="headerlink" title="查看是否安装"></a>查看是否安装</h2><pre><code>dpkg --list|grep ssh卸载sudo apt-get remove openssh-server </code></pre><h2 id="编译过程参考centos即可"><a href="#编译过程参考centos即可" class="headerlink" title="编译过程参考centos即可"></a>编译过程参考centos即可</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;centos系统&quot;&gt;&lt;a href=&quot;#centos系统&quot; class=&quot;headerlink&quot; title=&quot;centos系统&quot;&gt;&lt;/a&gt;centos系统&lt;/h1&gt;&lt;h2 id=&quot;查看是否安装openssh&quot;&gt;&lt;a href=&quot;#查看是否安装openssh&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nginx之location</title>
    <link href="http://example.com/2023/07/29/nginx%E4%B9%8Blocation/"/>
    <id>http://example.com/2023/07/29/nginx%E4%B9%8Blocation/</id>
    <published>2023-07-29T07:33:47.000Z</published>
    <updated>2023-07-29T07:33:47.373Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>shell脚本学习2</title>
    <link href="http://example.com/2023/07/29/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A02/"/>
    <id>http://example.com/2023/07/29/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A02/</id>
    <published>2023-07-29T06:58:19.000Z</published>
    <updated>2023-09-13T04:37:57.961Z</updated>
    
    <content type="html"><![CDATA[<p>搜索出当前目录下包含某个字符串的文件  并替换文件中的xx字符串为bb字符串<br>    sed -i “s/xx/bb/g” <code>grep -rl &quot;xx ./</code><br>    sed -i “s/http://121.229.56.251:8082/https://zkzp.jyrcfzjt.com:8082/g” <code>grep -rl &quot;http://121.229.56.251:8082&quot; ./</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;搜索出当前目录下包含某个字符串的文件  并替换文件中的xx字符串为bb字符串&lt;br&gt;    sed -i “s/xx/bb/g” &lt;code&gt;grep -rl &amp;quot;xx ./&lt;/code&gt;&lt;br&gt;    sed -i “s/http://121.229.56.251</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>nginx配置</title>
    <link href="http://example.com/2023/07/27/nginx%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2023/07/27/nginx%E9%85%8D%E7%BD%AE/</id>
    <published>2023-07-27T06:17:43.000Z</published>
    <updated>2023-07-29T07:31:08.100Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-、配置详解"><a href="#一-、配置详解" class="headerlink" title="一 、配置详解"></a>一 、配置详解</h1><h2 id="1-1nginx配置文件"><a href="#1-1nginx配置文件" class="headerlink" title="1.1nginx配置文件"></a>1.1nginx配置文件</h2><pre><code>#nginx 已那个用户身份访问文件user  www;  #指定nginx使用的worker进程数worker_processes 8;   #worker_cpu_affinity是一个用于配置工作进程CPU亲和性的选项。#CPU亲和性是指将进程或线程绑定到特定的CPU核心上，以提高性能和效率。#通常cpu几核，就配置几个worker_cpu_affinity 0000001 00000010 00000011 00000100 00000101 00000110 00000111 00001000;#PID配置项是用于指定保存主进程ID的文件路径pid        /var/run/nginx.pid;#用于限制每个worker进程可以打开的最大文件描述符数量。#ulimit -n 查看系统文件句柄数   设置为系统允许的最大文件句柄数的 80% - 90%worker_rlimit_nofile 65535;#用于控制Nginx服务器的事件模型和并发处理方式。events &#123;    #用于设置每个worker进程的最大并发连接数 即每个worker进程可以同时处理的最大客户端连接数    worker_connections 1024;        #常见的事件模型包括epoll、kqueue和select等。    use epoll;        #用于指定是否允许一个worker进程同时接受多个新连接    multi_accept on;&#125;#用于代理TCP和UDP流量，允许将Nginx作为代理服务器来处理网络流量#使用stream模块可以使Nginx具备代理TCP和UDP流量的能力stream &#123;       include /etc/nginx/stream/*.conf;&#125;#此模块用于配置HTTP服务器，允许主机作为Web服务器来处理HTTP请求http &#123;    #引入mime头文件  定义了Nginx的mime类型        include       mime.types;        #指令用于设置在请求无法匹配到任何MIME类型时的默认类型    default_type  application/octet-stream;        #定义日志格式  main 为日志格式 名称    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;                          #定义访问日志路径 main 指用那个日志格式名称                      access_log  /var/log/nginx/access.log  main;        # 当将sendfile设置为on时，Nginx使用sendfile()系统调用来直接将文件从磁盘传输到网络，    # 而无需将文件数据复制到用户空间。这样可以显着提高文件传输速度和效率。    sendfile on;        #将tcp_nopush设置为on时，Nginx会禁用TCP_CORK    #允许在nginx worker进程发送数据时立即将响应发送到客户端，而无需等待TCP缓冲区填满。    #将tcp_nopush设置为on可以提高响应的实时性，允许立即发送数据到客户端    tcp_nopush on;        #将tcp_nodelay设置为on时，Nginx会打开TCP_NODELAY，这将禁用TCP的Nagle算法，    #以便在发送小数据包或有延迟要求的数据时能够及时发送数据。    #将tcp_nodelay设置为on可以减少TCP延迟，适用于实时性要求高的应用场景。    tcp_nodelay on;            #配置空主机头 404 就是禁用http通过ip访问    server &#123;       listen 80 default;       server_name _;       root html;       location / &#123; return 404;&#125;       location ~ /.ht &#123; deny all; &#125;    &#125;        include /etc/nginx/conf.d/*.conf;&#125;</code></pre><h2 id="1-2log-format可用变量"><a href="#1-2log-format可用变量" class="headerlink" title="1.2log_format可用变量"></a>1.2log_format可用变量</h2><pre><code>$remote_addr：客户端的IP地址。$remote_user：客户端的用户名称（如果有授权）。$time_local：访问时间和日期（格式：[day/month/year:hour:minute:second zone]）。$request_method：HTTP请求的方法（例如GET或POST）。$request_uri：完整的请求URI。$request_length：请求的长度（包括请求行，请求头和请求体）。$status：HTTP响应的状态码。$body_bytes_sent：发送给客户端的响应体的字节数。$http_referer：请求中的“Referer”头部字段，包含了前一个页面的URL。$http_user_agent：请求的用户代理头部字段，表示发起请求的客户端工具或库。</code></pre><h2 id="1-3host配置文件"><a href="#1-3host配置文件" class="headerlink" title="1.3host配置文件"></a>1.3host配置文件</h2><h3 id="upstream-模块"><a href="#upstream-模块" class="headerlink" title="upstream 模块"></a>upstream 模块</h3><pre><code>#定义负载均衡#放置在 http 或 server 块upstream name &#123;         #用于指定上游服务器的地址和端口。可以指定多个server来定义多个上游服务器。     server backend1.example.com;          #max_fails 和 fail_timeout：用于设置上游服务器的故障处理策略     #max_fails 指定在多少次失败请求后将服务器标记为不可用     #fail_timeout 指定在服务器被标记为不可用后，多长时间内不再尝试请求。     server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;        #设置与上游服务器的连接保持活动的时间。可以提高性能并减少连接建立的开销。    keepalive:32;&#125;#weight：用于设置服务器的权重。权重越高，Nginx 转发给该服务器的请求越多。#示例：upstream backend &#123;    server backend1.example.com weight=3;    server backend2.example.com weight=2;&#125;#ip_hash：使用客户端的IP地址进行负载均衡，使得来自同一IP地址的请求始终被转发到同一台上游服务器。#示例：upstream backend &#123;    ip_hash;    server backend1.example.com;    server backend2.example.com;&#125;</code></pre><h3 id="Server模块"><a href="#Server模块" class="headerlink" title="Server模块"></a>Server模块</h3><pre><code>server：定义一个虚拟主机server&#123;    listen：指定服务器监听的端口    server_name：配置域名或IP地址    root：指定网站文件的根目录    index：定义当访问网站时默认显示的文件    location：定义请求的URL匹配规则和对应的处理方法。    proxy_pass：用于反向代理服务器的配置。    ssl_certificate和ssl_certificate_key：配置SSL/TLS证书。    try_files：定义文件检查规则        gzip on;    将 Gzip 压缩功能开启。        将所有类型的文件都进行 Gzip 压缩。这意味着无论是文本文件、图像文件还是视频文件，    都将进行压缩传输。如果你希望只压缩特定类型的文件，可以指定具体的文件类型，    例如 gzip_types text/plain text/css application/javascript;。    gzip_types *;       (gzip_proxied on or gzip_proxied off or gzip_proxied expired no-cache no-store private auth) 指定需要压缩的响应类型，    并且设置允许或者不允许使用代理服务器进行压缩。any 表示无论何时都进行压缩。    gzip_proxied any;&#125;</code></pre><h1 id="二、常用示例"><a href="#二、常用示例" class="headerlink" title="二、常用示例"></a>二、常用示例</h1><h2 id="2-1-mysql-代理示例"><a href="#2-1-mysql-代理示例" class="headerlink" title="2.1 mysql 代理示例"></a>2.1 mysql 代理示例</h2><pre><code>stream &#123;        server &#123;            listen 63306;            proxy_connect_timeout 8s;            proxy_timeout 24h;            proxy_pass 192.168.0.108:3306;        &#125;&#125;</code></pre><h2 id="2-3-带upstream的写法"><a href="#2-3-带upstream的写法" class="headerlink" title="2.3 带upstream的写法"></a>2.3 带upstream的写法</h2><pre><code>upstream rd_servers &#123;  server 127.0.0.1:5000;&#125;server&#123;  server_tokens off;  listen 80;  server_name redash.xxxxx.com;  access_log /var/log/nginx/rd.access.log;  gzip on;  gzip_types *;  gzip_proxied any;  location / &#123;    proxy_set_header Host $http_host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header X-Forwarded-Proto $scheme;    proxy_pass       http://rd_servers;  &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一-、配置详解&quot;&gt;&lt;a href=&quot;#一-、配置详解&quot; class=&quot;headerlink&quot; title=&quot;一 、配置详解&quot;&gt;&lt;/a&gt;一 、配置详解&lt;/h1&gt;&lt;h2 id=&quot;1-1nginx配置文件&quot;&gt;&lt;a href=&quot;#1-1nginx配置文件&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>linux-iptables使用总结</title>
    <link href="http://example.com/2023/07/26/linux-iptables%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/07/26/linux-iptables%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</id>
    <published>2023-07-26T07:31:32.000Z</published>
    <updated>2023-07-26T08:17:15.314Z</updated>
    
    <content type="html"><![CDATA[<p>一、iptables<br>    iptables防火墙没有启用,iptables命令仍然会显示默认的规则.</p><p>二、常用命令</p><p>常用参数</p><pre><code>-n 参数表示将 IP 地址和端口号显示为数字形式，而不是解析为主机名和服务名。-L 选项用于列出防火墙规则。-t nat 参数指定了要操作的表为 NAT 表，NAT 表用于处理网络地址转换相关的规则。</code></pre><p>iptables -n -L           显示当前防火墙规则列表。</p><p>iptables -t nat -n -L    看 iptables 中 NAT（Network Address Translation）表的规则。</p><p>结果怎么看</p><pre><code>Chain INPUT (policy ACCEPT)target     prot opt source               destination         ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0            state NEW udp dpt:2333ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:2333Chain FORWARD (policy DROP)target     prot opt source               destination         DOCKER-USER  all  --  0.0.0.0/0            0.0.0.0/0           DOCKER-ISOLATION-STAGE-1  all  --  0.0.0.0/0            0.0.0.0/0           ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            ctstate RELATED,ESTABLISHEDDOCKER     all  --  0.0.0.0/0            0.0.0.0/0           ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           Chain OUTPUT (policy ACCEPT)target     prot opt source               destination         Chain DOCKER (1 references)target     prot opt source               destination         ACCEPT     udp  --  0.0.0.0/0            172.17.0.2           udp dpt:60050ACCEPT     udp  --  0.0.0.0/0            172.17.0.2           udp dpt:60049ACCEPT     udp  --  0.0.0.0/0            172.17.0.2           udp dpt:60048ACCEPT     udp  --  0.0.0.0/0            172.17.0.2           udp dpt:60047Chain DOCKER-ISOLATION-STAGE-1 (1 references)target     prot opt source               destination         DOCKER-ISOLATION-STAGE-2  all  --  0.0.0.0/0            0.0.0.0/0           RETURN     all  --  0.0.0.0/0            0.0.0.0/0           Chain DOCKER-ISOLATION-STAGE-2 (1 references)target     prot opt source               destination         DROP       all  --  0.0.0.0/0            0.0.0.0/0           RETURN     all  --  0.0.0.0/0            0.0.0.0/0           Chain DOCKER-USER (1 references)target     prot opt source               destination         RETURN     all  --  0.0.0.0/0            0.0.0.0/0  &quot;LIBVIRT_FWI&quot;是一个iptables防火墙的链，并且该链已经被引用了一次允许所有协议（all）的流量从任意源IP地址（0.0.0.0/0）进入到目标IP地址为172.17.0.2  60047端口REJECT 拒绝ACCEPT 允许DROP   丢弃</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一、iptables&lt;br&gt;    iptables防火墙没有启用,iptables命令仍然会显示默认的规则.&lt;/p&gt;
&lt;p&gt;二、常用命令&lt;/p&gt;
&lt;p&gt;常用参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-n 参数表示将 IP 地址和端口号显示为数字形式，而不是解析为主机名和服务名。</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>php常用函数总结</title>
    <link href="http://example.com/2023/07/25/php%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/07/25/php%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</id>
    <published>2023-07-25T07:54:20.000Z</published>
    <updated>2023-07-25T08:29:31.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、字符串处理函数"><a href="#一、字符串处理函数" class="headerlink" title="一、字符串处理函数"></a>一、字符串处理函数</h1><h2 id="1-1-str-pad"><a href="#1-1-str-pad" class="headerlink" title="1.1 str_pad()"></a>1.1 str_pad()</h2><p>str_pad(【必填 需要处理的字符串】,【必填 填充的长度】，【 可选 填充的字符串，默认空白】，【可选 填充字符串的哪边】)</p><pre><code>规定填充字符串的哪边 可能的值：STR_PAD_BOTH - 填充字符串的两侧。如果不是偶数，则右侧获得额外的填充。STR_PAD_LEFT - 填充字符串的左侧。STR_PAD_RIGHT - 填充字符串的右侧。这是默认的。</code></pre><p>示例 $str=10 ; echo str_pad($str,4,”0”,STR_PAD_LEFT);  <font color="red">意思就4位长度 不够就往左边补0</font></p><h2 id="2-1-strpos、stripos-、strrpos"><a href="#2-1-strpos、stripos-、strrpos" class="headerlink" title="2.1 strpos、stripos 、strrpos"></a>2.1 strpos、stripos 、strrpos</h2><h2 id="2-3-substr"><a href="#2-3-substr" class="headerlink" title="2.3 substr"></a>2.3 substr</h2><h2 id="2-4-strtolower-strtouplower-strlen-mb-strlen-trim-ltrim-rtrim-explode-implode常用"><a href="#2-4-strtolower-strtouplower-strlen-mb-strlen-trim-ltrim-rtrim-explode-implode常用" class="headerlink" title="2.4 strtolower strtouplower strlen mb_strlen trim ltrim rtrim explode implode常用"></a>2.4 strtolower strtouplower strlen mb_strlen trim ltrim rtrim explode implode常用</h2><pre><code>比较常用，不在赘述</code></pre><h1 id="二、数组处理函数"><a href="#二、数组处理函数" class="headerlink" title="二、数组处理函数"></a>二、数组处理函数</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、字符串处理函数&quot;&gt;&lt;a href=&quot;#一、字符串处理函数&quot; class=&quot;headerlink&quot; title=&quot;一、字符串处理函数&quot;&gt;&lt;/a&gt;一、字符串处理函数&lt;/h1&gt;&lt;h2 id=&quot;1-1-str-pad&quot;&gt;&lt;a href=&quot;#1-1-str-pad&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>跨域问题总结</title>
    <link href="http://example.com/2023/07/21/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2023/07/21/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</id>
    <published>2023-07-21T08:26:13.000Z</published>
    <updated>2023-07-21T08:26:13.871Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>session和cookie</title>
    <link href="http://example.com/2023/07/21/session%E5%92%8Ccookie/"/>
    <id>http://example.com/2023/07/21/session%E5%92%8Ccookie/</id>
    <published>2023-07-21T08:25:34.000Z</published>
    <updated>2023-07-21T08:25:34.576Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux服务之crond</title>
    <link href="http://example.com/2023/07/19/Linux%E6%9C%8D%E5%8A%A1%E4%B9%8Bcrond/"/>
    <id>http://example.com/2023/07/19/Linux%E6%9C%8D%E5%8A%A1%E4%B9%8Bcrond/</id>
    <published>2023-07-19T06:20:19.000Z</published>
    <updated>2023-07-19T09:32:19.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Cron介绍"><a href="#一、Cron介绍" class="headerlink" title="一、Cron介绍"></a>一、Cron介绍</h1><p>Cron被用来进行Linux系统的计划任务执行</p><h1 id="二、相关目录"><a href="#二、相关目录" class="headerlink" title="二、相关目录"></a>二、相关目录</h1><p>cron.d/*用来存放一些软件的Cron设置</p><p>cron.daily/每天执行一次的任务</p><p>cron.hourly/每小时执行一次的任务</p><p>cron.monthly/每个月执行一次的任务</p><p>cron.weekly/，每周执行一次的任务</p><p>每分钟执行一次脚本</p><pre><code>crontab -e</code></pre><h1 id="三、crontab使用"><a href="#三、crontab使用" class="headerlink" title="三、crontab使用"></a>三、crontab使用</h1><pre><code>*  *  *   *  *  命令/脚本分 时 日 月 周1  *  *   *  *  命令/脚本   指的是每个小时的第一分钟*/1 * * * *     命令/脚本   每分钟执行脚本crontab -l查看计划任务列表   </code></pre><h1 id="四、-etc-cron-daily-与crontab-e-定义的区别"><a href="#四、-etc-cron-daily-与crontab-e-定义的区别" class="headerlink" title="四、/etc/cron.daily 与crontab -e 定义的区别"></a>四、/etc/cron.daily 与crontab -e 定义的区别</h1><pre><code>/etc/cron.daily 和 crontab -e 都是用来设置定时任务的方式，但它们有一些不同之处。/etc/cron.daily 是一个目录，里面存放着以 &quot;cron&quot; 格式命名的脚本文件。这些脚本会每天执行一次，通常在系统闲置时执行。这个目录中的脚本是全局的，适用于整个系统的所有用户。而 crontab -e 则是一个命令，用于编辑和管理用户个人的 crontab 文件。crontab 文件中定义了用户的定时任务计划。通过编辑 crontab 文件，用户可以设置自己的定时任务，包括每天、每周、每月或其他时间间隔的执行。因此，主要区别在于：/etc/cron.daily 适用于全局系统级别的定时任务，而 crontab -e 是用户级别的定时任务。/etc/cron.daily 中的脚本在每天执行一次，而 crontab -e 可以更精确地设置时间间隔。/etc/cron.daily 中的脚本对所有用户有效，而 crontab -e 只对当前用户有效。需要注意的是，修改 /etc/cron.daily 目录中的文件需要 root 权限，而 crontab -e 只需要用户自己的权限</code></pre><h1 id="五、Linux-anacron"><a href="#五、Linux-anacron" class="headerlink" title="五、Linux anacron"></a>五、Linux anacron</h1><p> 执行由于关机  忘记执行的任务</p><p> 配置好 /etc/anacrontab 文件</p><p> 更具体学习参考<a href="http://c.biancheng.net/view/1095.html">http://c.biancheng.net/view/1095.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、Cron介绍&quot;&gt;&lt;a href=&quot;#一、Cron介绍&quot; class=&quot;headerlink&quot; title=&quot;一、Cron介绍&quot;&gt;&lt;/a&gt;一、Cron介绍&lt;/h1&gt;&lt;p&gt;Cron被用来进行Linux系统的计划任务执行&lt;/p&gt;
&lt;h1 id=&quot;二、相关目录&quot;&gt;&lt;a</summary>
      
    
    
    
    
  </entry>
  
</feed>
